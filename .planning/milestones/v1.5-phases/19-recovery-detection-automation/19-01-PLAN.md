---
phase: 19-recovery-detection-automation
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - worker/recovery.py
  - tests/worker/test_recovery.py
autonomous: true

must_haves:
  truths:
    - "RecoveryScheduler only probes when circuit is OPEN or HALF_OPEN"
    - "Recovery state persists across plugin invocations"
    - "Successful health check in HALF_OPEN state calls circuit_breaker.record_success()"
    - "Failed health check in HALF_OPEN state calls circuit_breaker.record_failure()"
    - "Recovery event is logged and counted when circuit transitions to CLOSED"
    - "Corrupted or missing state file defaults to safe initial values"
  artifacts:
    - path: "worker/recovery.py"
      provides: "RecoveryScheduler class with RecoveryState dataclass"
      exports: ["RecoveryScheduler", "RecoveryState"]
    - path: "tests/worker/test_recovery.py"
      provides: "Full test coverage for RecoveryScheduler"
      min_lines: 100
  key_links:
    - from: "worker/recovery.py"
      to: "worker/circuit_breaker.py"
      via: "record_success() and record_failure() calls"
      pattern: "circuit_breaker\\.record_(success|failure)"
    - from: "worker/recovery.py"
      to: "recovery_state.json"
      via: "load_state/save_state with atomic write"
      pattern: "os\\.replace"
---

<objective>
TDD: Build RecoveryScheduler class that manages recovery detection scheduling via persisted state, mirroring ReconciliationScheduler's check-on-invocation pattern.

Purpose: This is the core logic for automatic Plex recovery detection. On each plugin invocation, RecoveryScheduler determines if a health probe is due, and when health checks succeed, orchestrates circuit breaker state transitions to close the circuit and allow queue drain.

Output: worker/recovery.py with RecoveryState dataclass and RecoveryScheduler class, fully tested via TDD.
</objective>

<execution_context>
@/Users/trekkie/.claude/get-shit-done/workflows/execute-plan.md
@/Users/trekkie/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@reconciliation/scheduler.py
@worker/circuit_breaker.py
@plex/health.py
</context>

<feature>
  <name>RecoveryScheduler with check-on-invocation pattern</name>
  <files>worker/recovery.py, tests/worker/test_recovery.py</files>
  <behavior>
    RecoveryScheduler manages recovery detection for Plex outages.
    It is NOT a timer/thread. On each plugin invocation, the caller
    checks should_check_recovery() to decide if a health probe is due.

    RecoveryState dataclass (persisted to recovery_state.json):
    - last_check_time: float = 0.0 (time.time() of last health check)
    - consecutive_successes: int = 0
    - consecutive_failures: int = 0
    - last_recovery_time: float = 0.0 (when circuit last closed after outage)
    - recovery_count: int = 0 (total recoveries detected)

    RecoveryScheduler class:
    - __init__(data_dir: str) — sets state_path = os.path.join(data_dir, 'recovery_state.json')
    - STATE_FILE = 'recovery_state.json' (class constant)
    - load_state() -> RecoveryState — same pattern as ReconciliationScheduler:
      - Read JSON, construct RecoveryState(**data)
      - Handle JSONDecodeError, TypeError, KeyError with defaults
      - Return RecoveryState() if file missing
    - save_state(state: RecoveryState) -> None — atomic write:
      - Write to .tmp file, os.replace to final path
      - Handle OSError gracefully (log_debug)
    - should_check_recovery(circuit_state: CircuitState, now: Optional[float] = None) -> bool:
      - Return False if circuit_state is CLOSED (no recovery needed)
      - Return True if circuit_state is OPEN or HALF_OPEN AND >= 5.0s since last check
      - Use now parameter for testability (default: time.time())
    - record_health_check(success: bool, latency_ms: float, circuit_breaker: CircuitBreaker) -> None:
      - Load state, update last_check_time
      - If success:
        - Increment consecutive_successes, reset consecutive_failures
        - If circuit_breaker.state == HALF_OPEN: call circuit_breaker.record_success()
        - If circuit_breaker.state is now CLOSED (recovery complete):
          - Update last_recovery_time, increment recovery_count
          - Log recovery at info level: "Recovery detected: Plex is back online (recovery #{count})"
          - Reset consecutive_successes to 0
        - If circuit_breaker.state == OPEN (hasn't transitioned to HALF_OPEN yet):
          - Just log at debug: "Health check passed but circuit still OPEN (awaiting recovery_timeout)"
      - If failure:
        - Increment consecutive_failures, reset consecutive_successes
        - If circuit_breaker.state == HALF_OPEN: call circuit_breaker.record_failure()
        - Log at debug level (expected during outage)
      - Save state

    IMPORTANT DETAIL about OPEN -> HALF_OPEN:
    The circuit breaker's .state property auto-transitions OPEN -> HALF_OPEN when
    recovery_timeout has elapsed. So when RecoveryScheduler reads circuit_breaker.state,
    it may get HALF_OPEN even though the circuit was OPEN moments before. This is the
    designed behavior — the .state property call triggers the transition.

    Test cases:
    - should_check_recovery(CLOSED) -> False
    - should_check_recovery(OPEN, now=last_check+3) -> False (too soon)
    - should_check_recovery(OPEN, now=last_check+5) -> True
    - should_check_recovery(HALF_OPEN, now=last_check+5) -> True
    - record_health_check(success=True) with HALF_OPEN circuit -> calls record_success()
    - record_health_check(success=True) with OPEN circuit (not yet HALF_OPEN) -> no record_success()
    - record_health_check(success=False) with HALF_OPEN circuit -> calls record_failure()
    - record_health_check(success=True) that closes circuit -> recovery logged, count incremented
    - load_state with missing file -> default RecoveryState
    - load_state with corrupted JSON -> default RecoveryState
    - save_state uses atomic write (os.replace)
    - Consecutive counters track correctly across multiple calls
  </behavior>
  <implementation>
    Mirror reconciliation/scheduler.py structure exactly:
    - Same import pattern (json, os, time, dataclasses, typing, shared.log)
    - Same load_state/save_state pattern (try/except with graceful defaults)
    - Same atomic write pattern (tmp file + os.replace)
    - Use create_logger("Recovery") for log functions
    - Import CircuitState and CircuitBreaker from worker.circuit_breaker
    - Add __all__ = ['RecoveryScheduler', 'RecoveryState']

    CRITICAL: Do NOT modify circuit breaker state directly (_state, _opened_at, etc).
    Use ONLY circuit_breaker.record_success() and circuit_breaker.record_failure().
    This preserves transition logging, state persistence, and file locking.

    CRITICAL: should_check_recovery must handle BOTH OPEN and HALF_OPEN states.
    The circuit can be in HALF_OPEN if recovery_timeout has elapsed. Recovery detection
    must still run during HALF_OPEN to complete the recovery via record_success().
  </implementation>
</feature>

<verification>
- `python3 -m pytest tests/worker/test_recovery.py -v` — all tests pass
- `python3 -m pytest tests/ -x -q` — no regressions (1043+ tests pass)
- `grep "record_success\|record_failure" worker/recovery.py` — uses circuit breaker API, not direct state modification
- `grep "os.replace" worker/recovery.py` — atomic write pattern
- `grep "CircuitState.CLOSED" worker/recovery.py` — CLOSED state check in should_check_recovery
</verification>

<success_criteria>
- RecoveryScheduler class exists in worker/recovery.py with full implementation
- RecoveryState dataclass with all 5 fields
- should_check_recovery returns False for CLOSED, True for OPEN/HALF_OPEN when interval elapsed
- record_health_check transitions circuit breaker via record_success/record_failure
- Recovery event logged and counted when circuit closes
- State persists via JSON with atomic write and corruption handling
- All tests pass with no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/19-recovery-detection-automation/19-01-SUMMARY.md`
</output>
