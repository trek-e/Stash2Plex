---
phase: 19-recovery-detection-automation
plan: 02
type: execute
wave: 2
depends_on: ["19-01"]
files_modified:
  - Stash2Plex.py
  - tests/test_main.py
autonomous: true

must_haves:
  truths:
    - "Recovery detection runs on every plugin invocation before auto-reconciliation"
    - "Queue automatically drains when Plex recovers (no manual intervention)"
    - "Recovery check is lightweight when circuit is CLOSED (early return, no I/O)"
    - "Recovery check failures do not crash the plugin"
  artifacts:
    - path: "Stash2Plex.py"
      provides: "maybe_check_recovery() function wired into main()"
      contains: "maybe_check_recovery"
    - path: "tests/test_main.py"
      provides: "Integration tests for recovery detection in main flow"
      min_lines: 30
  key_links:
    - from: "Stash2Plex.py"
      to: "worker/recovery.py"
      via: "imports RecoveryScheduler"
      pattern: "from worker\\.recovery import RecoveryScheduler"
    - from: "Stash2Plex.py"
      to: "plex/health.py"
      via: "imports check_plex_health for recovery probes"
      pattern: "from plex\\.health import check_plex_health"
    - from: "Stash2Plex.py maybe_check_recovery()"
      to: "main()"
      via: "called before maybe_auto_reconcile()"
      pattern: "maybe_check_recovery.*\\n.*maybe_auto_reconcile"
---

<objective>
Wire RecoveryScheduler into the plugin main loop so recovery detection runs on every plugin invocation, enabling automatic queue drain when Plex recovers.

Purpose: RecoveryScheduler (Plan 01) has the logic but no integration point. This plan connects it to the plugin lifecycle using the same check-on-invocation pattern as maybe_auto_reconcile(). When circuit breaker transitions to CLOSED, the existing worker loop naturally resumes queue processing — no additional drain logic needed.

Output: maybe_check_recovery() function in Stash2Plex.py, called on every invocation, with integration tests.
</objective>

<execution_context>
@/Users/trekkie/.claude/get-shit-done/workflows/execute-plan.md
@/Users/trekkie/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-recovery-detection-automation/19-01-SUMMARY.md
@Stash2Plex.py
@worker/recovery.py
@worker/circuit_breaker.py
@plex/health.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add maybe_check_recovery() to Stash2Plex.py</name>
  <files>Stash2Plex.py</files>
  <action>
    Add a `maybe_check_recovery()` function to Stash2Plex.py, placed BEFORE the existing `maybe_auto_reconcile()` function definition. Follow the exact same pattern as maybe_auto_reconcile() for structure, error handling, and guard clauses.

    Implementation:

    ```python
    def maybe_check_recovery():
        """Check if recovery detection is due and run it if so.

        Called on every plugin invocation (hook or task) BEFORE maybe_auto_reconcile().
        If circuit breaker is OPEN/HALF_OPEN and check interval has elapsed, probes
        Plex health and transitions circuit breaker state based on result.

        This is a lightweight check when circuit is CLOSED (reads circuit state only).
        Only creates PlexClient and runs health check when recovery probe is actually due.
        """
        if not config or not worker:
            return

        try:
            # Quick check: if circuit is CLOSED, nothing to recover
            circuit_state = worker.circuit_breaker.state
            from worker.circuit_breaker import CircuitState
            if circuit_state == CircuitState.CLOSED:
                return

            data_dir = get_plugin_data_dir()
            from worker.recovery import RecoveryScheduler

            scheduler = RecoveryScheduler(data_dir)

            if not scheduler.should_check_recovery(circuit_state):
                return

            # Recovery probe is due - run health check
            from plex.client import PlexClient
            from plex.health import check_plex_health

            client = PlexClient(
                url=config.plex_url,
                token=config.plex_token,
                connect_timeout=5.0,
                read_timeout=5.0
            )

            is_healthy, latency_ms = check_plex_health(client, timeout=5.0)
            scheduler.record_health_check(is_healthy, latency_ms, worker.circuit_breaker)

            # Log queue drain info if recovery completed
            if is_healthy and worker.circuit_breaker.state == CircuitState.CLOSED:
                queue = queue_manager.get_queue() if queue_manager else None
                pending = queue.size if queue else 0
                if pending > 0:
                    log_info(f"Queue will drain automatically ({pending} jobs pending)")

        except Exception as e:
            log_debug(f"Recovery check failed: {e}")
    ```

    Then in the `main()` function, add the call BEFORE `maybe_auto_reconcile()`:

    Find line:
    ```python
        # Auto-reconciliation check (runs on every invocation, lightweight)
        maybe_auto_reconcile()
    ```

    Replace with:
    ```python
        # Recovery detection (runs on every invocation, lightweight when circuit CLOSED)
        maybe_check_recovery()

        # Auto-reconciliation check (runs on every invocation, lightweight)
        maybe_auto_reconcile()
    ```

    IMPORTANT details:
    - Use lazy imports (inside function body) matching maybe_auto_reconcile() pattern
    - Early return when circuit is CLOSED (most common case, zero I/O)
    - 5.0s timeout for both connect and read (matches health check task, not config.plex_read_timeout)
    - catch all exceptions with log_debug (recovery check failure must never crash plugin)
    - Use worker.circuit_breaker.state (property, triggers OPEN->HALF_OPEN if timeout elapsed)
  </action>
  <verify>
    - `grep -n "maybe_check_recovery" Stash2Plex.py` shows function definition and call in main()
    - `grep -B2 "maybe_auto_reconcile()" Stash2Plex.py` shows maybe_check_recovery() is called first
    - `python3 -c "import Stash2Plex"` does not error (syntax check)
  </verify>
  <done>
    maybe_check_recovery() function exists in Stash2Plex.py and is called in main() before maybe_auto_reconcile()
  </done>
</task>

<task type="auto">
  <name>Task 2: Integration tests for recovery detection in main loop</name>
  <files>tests/test_main.py</files>
  <action>
    Create or extend tests/test_main.py with integration tests for maybe_check_recovery().
    If the file already exists, add a new test class. If not, create it.

    Test class: TestMaybeCheckRecovery

    Tests to write:

    1. `test_skips_when_no_config` — Set config=None, call maybe_check_recovery(), verify no errors and no RecoveryScheduler instantiation.

    2. `test_skips_when_no_worker` — Set worker=None, call maybe_check_recovery(), verify no errors.

    3. `test_skips_when_circuit_closed` — Mock worker.circuit_breaker.state to return CircuitState.CLOSED, call maybe_check_recovery(), verify RecoveryScheduler is NOT imported/instantiated (early return before any I/O).

    4. `test_runs_health_check_when_circuit_open` — Mock worker.circuit_breaker.state to return CircuitState.OPEN, mock RecoveryScheduler.should_check_recovery to return True, mock check_plex_health to return (True, 50.0), call maybe_check_recovery(), verify check_plex_health was called and scheduler.record_health_check was called with (True, 50.0, circuit_breaker).

    5. `test_skips_when_not_due` — Mock circuit_state=OPEN, mock should_check_recovery to return False, verify check_plex_health is NOT called.

    6. `test_logs_queue_drain_on_recovery` — Mock circuit initially OPEN, health check returns True, after record_health_check circuit transitions to CLOSED, queue has 5 pending items. Verify log_info called with message containing "Queue will drain automatically" and "5 jobs pending".

    7. `test_exception_does_not_crash` — Mock RecoveryScheduler to raise Exception, verify maybe_check_recovery() returns without error (exception caught and logged at debug level).

    Use the same test patterns as existing tests in the codebase:
    - `@patch` decorators for mocking
    - Stash2Plex module-level globals (config, worker, queue_manager) set via patching
    - Import maybe_check_recovery from Stash2Plex

    All tests must mock external I/O (no real file system, no real Plex connection).
  </action>
  <verify>
    - `python3 -m pytest tests/test_main.py -v -k "TestMaybeCheckRecovery"` — all 7 tests pass
    - `python3 -m pytest tests/ -x -q` — no regressions (1050+ tests total)
  </verify>
  <done>
    7 integration tests pass for maybe_check_recovery() covering: guard clauses (config/worker/circuit-closed), health check execution, skip-when-not-due, queue drain logging, and exception safety
  </done>
</task>

</tasks>

<verification>
Phase 19 complete verification:

1. **RECV-01 (automatic queue drain):** When circuit transitions CLOSED, existing worker loop's can_execute() returns True and resumes processing. No manual "Process Queue" needed.
   - Verify: `grep "can_execute" worker/processor.py` shows worker checks circuit before each job

2. **RECV-02 (active health check during OPEN):** maybe_check_recovery() calls check_plex_health when circuit is OPEN/HALF_OPEN.
   - Verify: `grep "check_plex_health" Stash2Plex.py` shows health check in recovery function

3. **RECV-03 (recovery notification):** RecoveryScheduler.record_health_check logs at info level when circuit closes.
   - Verify: `grep "Recovery detected" worker/recovery.py`

4. **STAT-02 (persisted recovery state):** RecoveryScheduler saves to recovery_state.json.
   - Verify: `grep "recovery_state.json" worker/recovery.py`

5. **Check-on-invocation pattern:** maybe_check_recovery() called on every invocation in main().
   - Verify: `grep -A1 "maybe_check_recovery" Stash2Plex.py` shows call before maybe_auto_reconcile

6. **No regressions:** `python3 -m pytest tests/ -x -q` — all tests pass
</verification>

<success_criteria>
- maybe_check_recovery() exists in Stash2Plex.py and runs before maybe_auto_reconcile()
- Recovery detection probes Plex when circuit is OPEN/HALF_OPEN
- Circuit transitions to CLOSED when health check succeeds (via record_success)
- Existing worker loop automatically resumes queue processing (no new drain logic)
- Recovery notification logged at info level
- 7+ integration tests pass with no regressions
- All 4 requirements satisfied: RECV-01, RECV-02, RECV-03, STAT-02
</success_criteria>

<output>
After completion, create `.planning/phases/19-recovery-detection-automation/19-02-SUMMARY.md`
</output>
