---
phase: 21-outage-visibility-history
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - worker/outage_history.py
  - tests/worker/test_outage_history.py
autonomous: true

must_haves:
  truths:
    - "OutageHistory stores up to 30 outage records in a deque(maxlen=30)"
    - "record_outage_start() appends a new OutageRecord with started_at timestamp"
    - "record_outage_end() updates the most recent ongoing outage with ended_at, duration, and jobs_affected"
    - "Outage history persists to outage_history.json and survives re-instantiation"
    - "format_duration() converts seconds to human-readable strings (e.g., 65 -> '1m 5s')"
    - "format_elapsed_since() returns relative time strings (e.g., '5m 30s ago')"
    - "calculate_outage_metrics() returns MTTR, MTBF, availability, total_downtime, outage_count"
    - "MTBF requires >= 2 completed outages, returns 0.0 otherwise"
    - "Ongoing outages (ended_at=None) are excluded from MTTR calculation"
  artifacts:
    - path: "worker/outage_history.py"
      provides: "OutageRecord dataclass, OutageHistory manager, format_duration, format_elapsed_since, calculate_outage_metrics"
      exports: ["OutageRecord", "OutageHistory", "format_duration", "format_elapsed_since", "calculate_outage_metrics"]
    - path: "tests/worker/test_outage_history.py"
      provides: "Comprehensive tests for outage history and metrics"
      min_lines: 150
  key_links:
    - from: "worker/outage_history.py"
      to: "outage_history.json"
      via: "atomic JSON persistence (tmp + os.replace)"
      pattern: "os\\.replace.*outage_history"
---

<objective>
TDD: Build OutageHistory manager class with circular buffer persistence, time formatting helpers, and outage metrics calculation.

Purpose: Phase 21 needs outage tracking and metrics. OutageHistory is pure business logic with well-defined inputs/outputs -- ideal for TDD. This plan builds the core data layer that Plan 02 will wire into the circuit breaker and status UI.

Output: worker/outage_history.py with OutageRecord, OutageHistory, format_duration, format_elapsed_since, calculate_outage_metrics. Full test suite.
</objective>

<execution_context>
@/Users/trekkie/.claude/get-shit-done/workflows/execute-plan.md
@/Users/trekkie/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-outage-visibility-history/21-RESEARCH.md
@worker/circuit_breaker.py
@worker/recovery.py
@worker/stats.py
</context>

<feature>
  <name>OutageHistory Manager with Metrics</name>
  <files>worker/outage_history.py, tests/worker/test_outage_history.py</files>
  <behavior>
    OutageRecord dataclass:
    - Fields: started_at (float), ended_at (float|None, default None), duration (float|None, default None), jobs_affected (int, default 0)

    OutageHistory class:
    - __init__(data_dir: str): creates deque(maxlen=30), loads from outage_history.json if exists
    - record_outage_start(started_at: float): appends new OutageRecord, saves to disk
    - record_outage_end(ended_at: float, jobs_affected: int = 0): updates most recent record (if ended_at is None), calculates duration, saves
    - get_history() -> list[OutageRecord]: returns list copy of history
    - get_current_outage() -> OutageRecord|None: returns most recent record if ended_at is None
    - _load_state(): loads from outage_history.json, handles corruption gracefully (empty deque)
    - _save_state(): atomic write via tmp + os.replace (same pattern as circuit_breaker.json, recovery_state.json)

    Persistence behavior:
    - outage_history.json stores list of dicts (one per OutageRecord)
    - Corrupted JSON resets to empty deque (no crash)
    - Re-instantiation from same data_dir loads prior history
    - deque(maxlen=30) automatically drops oldest when full

    format_duration(seconds: float) -> str:
    - 0 -> "0s"
    - 65 -> "1m 5s"
    - 3661 -> "1h 1m"
    - 86401 -> "1d 0h"
    - Negative -> "0s"
    - Show at most 2 units for brevity

    format_elapsed_since(timestamp: float, now: float = None) -> str:
    - Returns "{format_duration(elapsed)} ago"
    - Accept optional 'now' parameter for deterministic testing

    calculate_outage_metrics(history: list[OutageRecord]) -> dict:
    - Returns dict with keys: mttr, mtbf, availability, total_downtime, outage_count
    - Empty list -> mttr=0, mtbf=0, availability=100.0, total_downtime=0, outage_count=0
    - Only completed outages (ended_at is not None) count
    - MTTR = total_downtime / completed_count
    - MTBF = time_span / (completed_count - 1) -- requires >= 2 completed
    - 1 completed outage -> MTBF=0.0
    - availability = (mtbf / (mtbf + mttr)) * 100 when mtbf > 0, else 100.0
  </behavior>
  <implementation>
    Follow existing patterns from worker/circuit_breaker.py and worker/recovery.py:
    - Use dataclasses.dataclass and dataclasses.asdict for serialization
    - Use collections.deque(maxlen=30) for circular buffer
    - Use shared.log create_logger for logging
    - Atomic persistence: write to .tmp, os.replace to final path
    - Accept data_dir in constructor, build state_path from it
    - STATE_FILE = 'outage_history.json' class constant
    - MAX_OUTAGES = 30 class constant

    Time formatting functions should be module-level (not class methods) since they are reused by handle_queue_status() and handle_outage_summary() in Plan 02.

    calculate_outage_metrics should also be module-level function accepting a list, not a method on OutageHistory -- keeps it testable and reusable.

    Use typing imports: Optional, List, Dict. Use float|None syntax for dataclass fields (matches circuit_breaker.py pattern).
  </implementation>
</feature>

<verification>
```bash
# RED: Tests fail (no implementation yet)
pytest tests/worker/test_outage_history.py -v --tb=short 2>&1 | grep -E "FAILED|PASSED|ERROR"

# GREEN: All tests pass after implementation
pytest tests/worker/test_outage_history.py -v --tb=short

# Full suite still passes
pytest --tb=short -q
```
</verification>

<success_criteria>
- worker/outage_history.py exists with OutageRecord, OutageHistory, format_duration, format_elapsed_since, calculate_outage_metrics
- tests/worker/test_outage_history.py has comprehensive coverage of all behaviors listed above
- All new tests pass
- Full test suite passes (1136+ tests)
- Coverage above 80% threshold
</success_criteria>

<output>
After completion, create `.planning/phases/21-outage-visibility-history/21-01-SUMMARY.md`
</output>
