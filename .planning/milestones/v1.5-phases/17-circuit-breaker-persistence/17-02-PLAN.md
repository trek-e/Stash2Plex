---
phase: 17-circuit-breaker-persistence
plan: 02
type: execute
wave: 2
depends_on: ["17-01"]
files_modified:
  - worker/processor.py
  - tests/integration/test_circuit_breaker_integration.py
autonomous: true

must_haves:
  truths:
    - "SyncWorker passes data_dir-based state_file path to CircuitBreaker"
    - "Plugin restart during Plex outage preserves OPEN circuit state (no retry exhaustion)"
    - "Worker integration tests verify persistence across simulated restarts"
    - "Existing integration tests pass without modification"
  artifacts:
    - path: "worker/processor.py"
      provides: "CircuitBreaker instantiation with state_file parameter"
      contains: "state_file"
    - path: "tests/integration/test_circuit_breaker_integration.py"
      provides: "Integration tests for persistence across worker instances"
      contains: "test_state_persists_across_worker_instances"
  key_links:
    - from: "worker/processor.py"
      to: "worker/circuit_breaker.py"
      via: "CircuitBreaker(state_file=cb_state_file)"
      pattern: "state_file.*circuit_breaker\\.json"
---

<objective>
Wire CircuitBreaker state persistence into SyncWorker and add integration tests verifying persistence across simulated plugin restarts.

Purpose: The CircuitBreaker class now supports persistence (Plan 01), but SyncWorker doesn't pass a state_file yet. This plan completes the integration so that real plugin restarts preserve circuit state. Integration tests simulate the restart scenario (create worker, open circuit, create new worker from same data_dir, verify OPEN state preserved).

Output: Wired processor.py + integration tests proving restart resilience
</objective>

<execution_context>
@/Users/trekkie/.claude/get-shit-done/workflows/execute-plan.md
@/Users/trekkie/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-circuit-breaker-persistence/17-01-SUMMARY.md

@worker/processor.py (lines 60-107: SyncWorker.__init__)
@worker/circuit_breaker.py (after Plan 01 modifications)
@tests/integration/test_circuit_breaker_integration.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire state_file into SyncWorker and add integration tests</name>
  <files>worker/processor.py, tests/integration/test_circuit_breaker_integration.py</files>
  <action>
**Step 1: Modify worker/processor.py SyncWorker.__init__**

In the circuit breaker initialization block (around lines 101-107), change from:

```python
from worker.circuit_breaker import CircuitBreaker
self.circuit_breaker = CircuitBreaker(
    failure_threshold=5,
    recovery_timeout=60.0,
    success_threshold=1
)
```

To:

```python
from worker.circuit_breaker import CircuitBreaker

# Enable state persistence when data_dir is available
cb_state_file = None
if data_dir is not None:
    cb_state_file = os.path.join(data_dir, 'circuit_breaker.json')

self.circuit_breaker = CircuitBreaker(
    failure_threshold=5,
    recovery_timeout=60.0,
    success_threshold=1,
    state_file=cb_state_file
)
```

This follows the exact same pattern as stats.json initialization on lines 93-95 (data_dir check → os.path.join → pass to constructor). When data_dir is None (tests without persistence), no state file is used.

**Step 2: Add integration tests to tests/integration/test_circuit_breaker_integration.py**

Add a new test class `TestCircuitBreakerPersistenceIntegration` (keep ALL existing test classes unchanged):

```python
@pytest.mark.integration
class TestCircuitBreakerPersistenceIntegration:
    """Tests for circuit breaker state persistence across worker instances."""

    def test_state_persists_across_worker_instances(self, mock_queue, mock_dlq, mock_config, tmp_path):
        """Circuit breaker OPEN state survives creating a new worker (simulates plugin restart)."""
        from worker.processor import SyncWorker
        from worker.circuit_breaker import CircuitState

        # First worker instance: open circuit via 5 failures
        worker1 = SyncWorker(
            queue=mock_queue,
            dlq=mock_dlq,
            config=mock_config,
            data_dir=str(tmp_path),
        )
        for _ in range(5):
            worker1.circuit_breaker.record_failure()
        assert worker1.circuit_breaker.state == CircuitState.OPEN

        # Verify state file created
        state_file = tmp_path / "circuit_breaker.json"
        assert state_file.exists()

        # Second worker instance (simulates plugin restart): loads OPEN state
        worker2 = SyncWorker(
            queue=mock_queue,
            dlq=mock_dlq,
            config=mock_config,
            data_dir=str(tmp_path),
        )
        assert worker2.circuit_breaker.state == CircuitState.OPEN
        assert worker2.circuit_breaker.can_execute() is False

    def test_closed_state_persists_after_recovery(self, mock_queue, mock_dlq, mock_config, tmp_path):
        """After recovery (HALF_OPEN -> CLOSED), new worker sees CLOSED state."""
        from worker.processor import SyncWorker
        from worker.circuit_breaker import CircuitState

        # First worker: open circuit
        worker1 = SyncWorker(
            queue=mock_queue,
            dlq=mock_dlq,
            config=mock_config,
            data_dir=str(tmp_path),
        )
        for _ in range(5):
            worker1.circuit_breaker.record_failure()
        assert worker1.circuit_breaker.state == CircuitState.OPEN

        # Force HALF_OPEN and recover
        worker1.circuit_breaker._state = CircuitState.HALF_OPEN
        worker1.circuit_breaker.record_success()
        assert worker1.circuit_breaker.state == CircuitState.CLOSED

        # New worker: should be CLOSED
        worker2 = SyncWorker(
            queue=mock_queue,
            dlq=mock_dlq,
            config=mock_config,
            data_dir=str(tmp_path),
        )
        assert worker2.circuit_breaker.state == CircuitState.CLOSED
        assert worker2.circuit_breaker.can_execute() is True

    def test_no_state_file_without_data_dir(self, mock_queue, mock_dlq, mock_config):
        """Worker without data_dir creates circuit breaker without persistence."""
        from worker.processor import SyncWorker

        worker = SyncWorker(
            queue=mock_queue,
            dlq=mock_dlq,
            config=mock_config,
            data_dir=None,
        )
        assert worker.circuit_breaker._state_file is None

    @freeze_time("2026-01-01 12:00:00")
    def test_half_open_state_persists_across_restart(self, mock_queue, mock_dlq, mock_config, tmp_path):
        """HALF_OPEN state persists, allowing recovery test on restart."""
        from worker.processor import SyncWorker
        from worker.circuit_breaker import CircuitState

        # First worker: open circuit
        worker1 = SyncWorker(
            queue=mock_queue,
            dlq=mock_dlq,
            config=mock_config,
            data_dir=str(tmp_path),
        )
        for _ in range(5):
            worker1.circuit_breaker.record_failure()

        # Advance time past recovery timeout to trigger HALF_OPEN
        with freeze_time("2026-01-01 12:01:01"):
            assert worker1.circuit_breaker.state == CircuitState.HALF_OPEN

            # New worker should load HALF_OPEN state
            worker2 = SyncWorker(
                queue=mock_queue,
                dlq=mock_dlq,
                config=mock_config,
                data_dir=str(tmp_path),
            )
            assert worker2.circuit_breaker.state == CircuitState.HALF_OPEN
            assert worker2.circuit_breaker.can_execute() is True

    def test_state_file_location(self, mock_queue, mock_dlq, mock_config, tmp_path):
        """State file is stored in data_dir as circuit_breaker.json."""
        from worker.processor import SyncWorker

        worker = SyncWorker(
            queue=mock_queue,
            dlq=mock_dlq,
            config=mock_config,
            data_dir=str(tmp_path),
        )

        expected_path = str(tmp_path / "circuit_breaker.json")
        assert worker.circuit_breaker._state_file == expected_path
```

Add the `freeze_time` import at the top of the file if not already imported (it IS already imported on line 17, so just use it).

**Step 3: Run all tests**

Run `python -m pytest tests/integration/test_circuit_breaker_integration.py -v` to verify new and existing tests pass.
Run `python -m pytest tests/ -x -q` for full regression check.
  </action>
  <verify>
Run: `python -m pytest tests/integration/test_circuit_breaker_integration.py -v`
All existing integration tests pass. All new persistence integration tests pass.

Run: `python -m pytest tests/ -x -q` — full suite passes.

Verify: `grep -n "state_file" worker/processor.py` shows state_file wiring.
Verify: `grep -n "circuit_breaker.json" worker/processor.py` shows correct file name.
  </verify>
  <done>
- SyncWorker passes data_dir/circuit_breaker.json as state_file to CircuitBreaker
- SyncWorker without data_dir (tests) creates CircuitBreaker with no persistence (backward compatible)
- Integration tests prove OPEN state survives across worker instances (simulated restart)
- Integration tests prove CLOSED state after recovery persists
- Integration tests prove HALF_OPEN state persists
- All existing integration tests unmodified and passing
  </done>
</task>

</tasks>

<verification>
1. `python -m pytest tests/integration/test_circuit_breaker_integration.py -v` — all tests pass
2. `python -m pytest tests/ -x -q` — full suite passes, zero regressions
3. `grep "state_file" worker/processor.py` — confirms wiring exists
4. `grep "circuit_breaker.json" worker/processor.py` — confirms correct file path
5. No new dependencies in requirements.txt
</verification>

<success_criteria>
- SyncWorker creates CircuitBreaker with state_file when data_dir is provided
- Plugin restart during Plex outage preserves OPEN circuit (proven by integration test)
- Recovery after outage (CLOSED) persists across restart (proven by integration test)
- data_dir=None (test mode) works without persistence (backward compatible)
- All 999+ existing tests pass without modification
</success_criteria>

<output>
After completion, create `.planning/phases/17-circuit-breaker-persistence/17-02-SUMMARY.md`
</output>
