---
phase: 17-circuit-breaker-persistence
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - worker/circuit_breaker.py
  - tests/test_circuit_breaker.py
autonomous: true

must_haves:
  truths:
    - "CircuitBreaker with state_file saves state to JSON on every transition"
    - "CircuitBreaker loads persisted state on init, preserving OPEN during outage"
    - "Corrupted/missing state file gracefully defaults to CLOSED"
    - "All state transitions (CLOSED->OPEN, OPEN->HALF_OPEN, HALF_OPEN->CLOSED/OPEN) emit log_info messages"
    - "File locking prevents concurrent state modifications (fcntl advisory lock)"
    - "CircuitBreaker without state_file works identically to current behavior (backward compatible)"
  artifacts:
    - path: "worker/circuit_breaker.py"
      provides: "Persistent circuit breaker with save/load, logging, locking"
      contains: "save_state"
    - path: "tests/test_circuit_breaker.py"
      provides: "Unit tests for persistence, logging, locking, corruption handling"
      contains: "test_state_persistence"
  key_links:
    - from: "worker/circuit_breaker.py"
      to: "circuit_breaker.json"
      via: "save_state/load_state with atomic write (os.replace)"
      pattern: "os\\.replace"
    - from: "worker/circuit_breaker.py"
      to: "shared/log.py"
      via: "log_info calls on state transitions"
      pattern: "log_info.*Circuit breaker"
---

<objective>
Add state persistence, transition logging, and file locking to CircuitBreaker class using TDD.

Purpose: Circuit breaker state must survive plugin restarts so that an OPEN circuit during a Plex outage remains OPEN after Stash restarts (preventing retry exhaustion). Transition logging (VISB-02) gives users visibility into why queue processing paused.

Output: Enhanced circuit_breaker.py with save_state/load_state/locking + comprehensive unit tests
</objective>

<execution_context>
@/Users/trekkie/.claude/get-shit-done/workflows/execute-plan.md
@/Users/trekkie/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-circuit-breaker-persistence/17-RESEARCH.md

@worker/circuit_breaker.py
@tests/test_circuit_breaker.py
@reconciliation/scheduler.py (atomic write pattern reference: lines 60-79)
@shared/log.py (logging functions reference)
</context>

<tasks>

<task type="auto">
  <name>Task 1: TDD — Persistence, logging, and locking for CircuitBreaker</name>
  <files>worker/circuit_breaker.py, tests/test_circuit_breaker.py</files>
  <action>
**RED phase — Write failing tests first in tests/test_circuit_breaker.py:**

Add these new test classes (keep ALL existing tests unchanged):

1. `TestCircuitBreakerStatePersistence` — tests for save/load:
   - `test_state_persisted_on_open`: Create breaker with `state_file=str(tmp_path / "cb.json")`, trigger 5 failures to OPEN. Assert cb.json exists. Create new breaker with same state_file. Assert state is OPEN, opened_at is preserved.
   - `test_state_persisted_on_close`: Open circuit, force HALF_OPEN, record success. Create new breaker from same file. Assert CLOSED.
   - `test_state_persisted_on_half_open`: Open circuit, mock time to trigger HALF_OPEN via `breaker.state` property. Create new breaker. Assert HALF_OPEN.
   - `test_no_persistence_without_state_file`: Create breaker with `state_file=None` (default). Trigger transitions. Assert no file created. Verify all state machine behavior still works identically.
   - `test_failure_count_persisted`: Record 3 failures (below threshold of 5). New breaker from same file. Record 2 more. Assert OPEN (3+2=5).
   - `test_success_count_persisted_in_half_open`: Force HALF_OPEN with success_threshold=3. Record 1 success. New breaker. Record 2 more. Assert CLOSED.

2. `TestCircuitBreakerStateCorruption` — graceful degradation:
   - `test_corrupted_json_defaults_to_closed`: Write garbage to state_file. Create breaker. Assert CLOSED, no exception.
   - `test_missing_keys_defaults_to_closed`: Write `{"state": "open"}` (missing other fields). Create breaker. Assert CLOSED.
   - `test_invalid_state_value_defaults_to_closed`: Write `{"state": "invalid", ...}`. Create breaker. Assert CLOSED.
   - `test_nonexistent_file_defaults_to_closed`: Create breaker with state_file pointing to nonexistent path. Assert CLOSED.
   - `test_save_failure_nonfatal`: Mock `builtins.open` to raise OSError during save. Assert no exception, breaker still transitions in-memory.

3. `TestCircuitBreakerTransitionLogging` — VISB-02 requirement:
   - `test_log_on_open`: Patch `worker.circuit_breaker.log_info`. Trigger OPEN transition. Assert log_info called with message containing "OPENED" and "consecutive failures".
   - `test_log_on_close`: Force HALF_OPEN, record success. Assert log_info called with "CLOSED" and "recovery".
   - `test_log_on_half_open`: Open circuit, mock time for timeout. Access `breaker.state`. Assert log_info called with "HALF_OPEN" and "timeout".
   - `test_log_on_reopen_from_half_open`: Force HALF_OPEN, record failure. Assert log_info called with "reopening" or "OPENED".
   - `test_no_log_on_failure_below_threshold`: Record 1 failure. Assert log_info NOT called (state didn't change).

4. `TestCircuitBreakerFileLocking` — concurrent access safety:
   - `test_lock_file_created_on_save`: Create breaker with state_file. Trigger transition. Assert `.lock` file exists alongside state file.
   - `test_concurrent_save_skipped_when_locked`: Acquire exclusive lock on `.lock` file manually (fcntl.flock). Then trigger breaker transition. Assert no exception (save skipped gracefully). Release lock.
   - `test_save_works_after_lock_released`: Acquire then release lock. Trigger transition. Assert state_file updated correctly.

**GREEN phase — Implement in worker/circuit_breaker.py:**

Modify the existing CircuitBreaker class (do NOT create new file):

1. Add imports at top:
   ```python
   import json
   import os
   import fcntl
   from typing import Optional
   from shared.log import create_logger
   log_trace, log_debug, log_info, log_warn, log_error = create_logger("CircuitBreaker")
   ```

2. Add `state_file` parameter to `__init__`:
   ```python
   def __init__(
       self,
       failure_threshold: int = 5,
       recovery_timeout: float = 60.0,
       success_threshold: int = 1,
       state_file: Optional[str] = None
   ):
   ```
   Store `self._state_file = state_file`. After setting defaults, call `self._load_state()` if state_file is provided.

3. Add `_load_state()` method:
   - If `self._state_file` is None or file doesn't exist, return immediately
   - Try: open file, json.load, set self._state (CircuitState(data['state'])), self._failure_count, self._success_count, self._opened_at
   - Log loaded state with log_debug
   - Catch (json.JSONDecodeError, TypeError, KeyError, ValueError) → log_warn "Circuit breaker state corrupted, using defaults: {e}"
   - Pattern: follow reconciliation/scheduler.py:60-69

4. Add `_save_state()` method:
   - If `self._state_file` is None, return immediately
   - Build dict: state (self._state.value), failure_count, success_count, opened_at
   - Use atomic write pattern: write to `self._state_file + '.tmp'`, then `os.replace(tmp, self._state_file)`
   - Wrap entire save in try/except OSError → log_debug "Failed to save circuit breaker state: {e}" (non-fatal)
   - Pattern: follow reconciliation/scheduler.py:71-79

5. Add `_save_state_locked()` method:
   - If `self._state_file` is None, return immediately
   - lock_path = self._state_file + '.lock'
   - Open lock file, fcntl.flock(LOCK_EX | LOCK_NB)
   - Call self._save_state()
   - Catch BlockingIOError → log_trace "state save skipped (locked)"
   - Catch OSError → log_debug
   - Finally: unlock (LOCK_UN) and close lock file

6. Modify `_open()`:
   - Add after existing logic: `log_info(f"Circuit breaker OPENED after {self._failure_threshold} consecutive failures")`
   - Add: `self._save_state_locked()`

7. Modify `_close()`:
   - Add after existing logic: `log_info("Circuit breaker CLOSED after successful recovery")`
   - Add: `self._save_state_locked()`

8. Modify `state` property:
   - Inside the OPEN→HALF_OPEN transition block, add before returning:
     `log_info(f"Circuit breaker entering HALF_OPEN state after {self._recovery_timeout}s timeout")`
   - Add: `self._save_state_locked()`

9. Modify `record_success()`:
   - After `self._failure_count = 0` in CLOSED branch, add `self._save_state_locked()`
   - After `self._success_count += 1` in HALF_OPEN branch (when threshold NOT yet reached), add `self._save_state_locked()`

10. Modify `record_failure()`:
    - After `self._failure_count += 1` in CLOSED branch (when threshold NOT yet reached), add `self._save_state_locked()`

11. Modify `reset()`:
    - Add `log_info("Circuit breaker manually reset to CLOSED")` and `self._save_state_locked()` after `self._close()`
    - Note: `_close()` already saves, but reset() should log its own message. Actually, to avoid double-save, just let _close() handle it. Only add the reset-specific log line before calling _close().

**REFACTOR phase:**
- Ensure all existing tests still pass (the default state_file=None means zero behavior change for existing code)
- Run full test suite: `python -m pytest tests/test_circuit_breaker.py -v`
  </action>
  <verify>
Run: `python -m pytest tests/test_circuit_breaker.py -v`
All existing tests pass (no regressions). All new persistence/logging/locking tests pass.

Run: `python -m pytest tests/ -x -q` to verify no other test breakage.
  </verify>
  <done>
- CircuitBreaker with state_file persists state on every transition (save_state_locked)
- CircuitBreaker loads persisted state on init (load_state with graceful degradation)
- Corrupted/missing state files default to CLOSED without exceptions
- All state transitions emit log_info messages (VISB-02)
- File locking prevents concurrent state modification (fcntl LOCK_EX | LOCK_NB)
- state_file=None (default) preserves 100% backward compatibility
- All existing tests unmodified and passing
  </done>
</task>

</tasks>

<verification>
1. `python -m pytest tests/test_circuit_breaker.py -v` — all tests pass (existing + new)
2. `python -m pytest tests/ -x -q` — full suite passes, no regressions
3. Verify circuit_breaker.py contains: save_state, _load_state, _save_state_locked, log_info calls
4. Verify no new external dependencies added (all stdlib: json, os, fcntl, typing)
</verification>

<success_criteria>
- CircuitBreaker with state_file=path persists state to JSON on every transition
- CircuitBreaker with state_file=None works identically to v1.4 (backward compatible)
- State survives across CircuitBreaker instances (simulating plugin restart)
- Corrupted state gracefully defaults to CLOSED
- All transitions logged with descriptive messages visible in Stash logs
- File locking prevents concurrent modification
- Zero new dependencies
</success_criteria>

<output>
After completion, create `.planning/phases/17-circuit-breaker-persistence/17-01-SUMMARY.md`
</output>
