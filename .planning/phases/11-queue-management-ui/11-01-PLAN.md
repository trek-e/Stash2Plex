---
phase: 11-queue-management-ui
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Stash2Plex.yml
  - Stash2Plex.py
  - sync_queue/operations.py
autonomous: true

must_haves:
  truths:
    - "User can view queue status from Stash UI Tasks menu"
    - "User can clear pending queue items from Stash UI"
    - "User can clear dead letter queue items from Stash UI"
    - "User can purge old DLQ entries from Stash UI"
    - "User sees status feedback in Stash logs after each operation"
  artifacts:
    - path: "Stash2Plex.yml"
      provides: "Task definitions for queue management"
      contains: "mode: queue_status"
    - path: "Stash2Plex.py"
      provides: "Handler functions for queue operations"
      contains: "def handle_queue_status"
    - path: "sync_queue/operations.py"
      provides: "clear_pending_items function"
      contains: "def clear_pending_items"
  key_links:
    - from: "Stash2Plex.yml"
      to: "Stash2Plex.py"
      via: "mode argument in defaultArgs"
      pattern: "mode: queue_status|clear_queue|clear_dlq|purge_dlq"
    - from: "Stash2Plex.py handle_task"
      to: "handler functions"
      via: "mode dispatch"
      pattern: "elif mode == 'queue_status'"
    - from: "handle_clear_queue"
      to: "sync_queue/operations.py"
      via: "clear_pending_items import"
      pattern: "from sync_queue.operations import.*clear_pending_items"
---

<objective>
Add queue management tasks to Stash2Plex plugin menu

Purpose: Allow users to view queue status and clear stuck/dead queue items directly from Stash UI without manual database intervention

Output: Four new tasks in Stash plugin menu (View Queue Status, Clear Pending Queue, Clear Dead Letter Queue, Purge Old DLQ Entries) with full logging feedback
</objective>

<execution_context>
@/Users/trekkie/.claude/get-shit-done/workflows/execute-plan.md
@/Users/trekkie/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-queue-management-ui/11-RESEARCH.md

# Source files
@Stash2Plex.yml
@Stash2Plex.py
@sync_queue/operations.py
@sync_queue/dlq.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add queue operations helper function</name>
  <files>sync_queue/operations.py</files>
  <action>
Add a new function `clear_pending_items(queue_path: str) -> int` to sync_queue/operations.py that:

1. Connects to the SQLite database at `queue_path/data.db`
2. Finds the ack_queue table name (same pattern as get_stats)
3. Deletes items with status IN (0, 1) - pending items only
4. Returns the count of deleted items
5. Properly closes the connection in a finally block

Pattern to follow (from get_stats):
```python
def clear_pending_items(queue_path: str) -> int:
    """
    Clear all pending items from queue.

    Deletes items with status 0 (inited) or 1 (ready).
    Does NOT delete in-progress (2), completed (5), or failed (9) items.

    Args:
        queue_path: Path to queue directory (contains data.db)

    Returns:
        Number of items deleted
    """
    db_path = os.path.join(queue_path, 'data.db')

    if not os.path.exists(db_path):
        return 0

    conn = sqlite3.connect(db_path)
    try:
        cursor = conn.execute(
            "SELECT name FROM sqlite_master WHERE type='table' AND name LIKE 'ack_queue%'"
        )
        table = cursor.fetchone()
        if not table:
            return 0

        table_name = table[0]
        cursor = conn.execute(
            f"DELETE FROM {table_name} WHERE status IN (0, 1)"
        )
        deleted = cursor.rowcount
        conn.commit()
        return deleted
    finally:
        conn.close()
```

Place the function after `get_stats()` and before the timestamp functions.
  </action>
  <verify>
Run: `python -c "from sync_queue.operations import clear_pending_items; print('Import OK')"`
Verify function signature matches expected.
  </verify>
  <done>clear_pending_items function exists in sync_queue/operations.py and is importable</done>
</task>

<task type="auto">
  <name>Task 2: Add task definitions to plugin YAML</name>
  <files>Stash2Plex.yml</files>
  <action>
Add 4 new tasks to the `tasks:` section in Stash2Plex.yml after the existing "Sync Recent Scenes to Plex" task:

```yaml
  - name: View Queue Status
    description: Show current queue and DLQ statistics in logs
    defaultArgs:
      mode: queue_status
  - name: Clear Pending Queue
    description: "WARNING: Remove all pending queue items (completed/in-progress unaffected)"
    defaultArgs:
      mode: clear_queue
  - name: Clear Dead Letter Queue
    description: "WARNING: Remove all items from dead letter queue"
    defaultArgs:
      mode: clear_dlq
  - name: Purge Old DLQ Entries
    description: Remove DLQ entries older than 30 days
    defaultArgs:
      mode: purge_dlq
      days: 30
```

The WARNING prefix in descriptions serves as confirmation (Stash plugins are non-interactive).
Maintain exact YAML indentation (2 spaces for list items under tasks).
  </action>
  <verify>
Run: `python -c "import yaml; yaml.safe_load(open('Stash2Plex.yml')); print('YAML valid')"`
Verify 6 total tasks exist (2 original + 4 new).
  </verify>
  <done>Stash2Plex.yml has 6 tasks including queue_status, clear_queue, clear_dlq, purge_dlq modes</done>
</task>

<task type="auto">
  <name>Task 3: Add handler functions and dispatcher logic</name>
  <files>Stash2Plex.py</files>
  <action>
Add 4 new handler functions and update handle_task() dispatcher in Stash2Plex.py:

1. Add handler functions BEFORE handle_task() (around line 395):

```python
def handle_queue_status():
    """Display current queue and DLQ statistics."""
    try:
        data_dir = get_plugin_data_dir()
        queue_path = os.path.join(data_dir, 'queue')

        from sync_queue.operations import get_stats
        from sync_queue.dlq import DeadLetterQueue

        stats = get_stats(queue_path)
        dlq = DeadLetterQueue(data_dir)
        dlq_count = dlq.get_count()
        dlq_summary = dlq.get_error_summary()

        log_info("=== Queue Status ===")
        log_info(f"Pending: {stats['pending']}")
        log_info(f"In Progress: {stats['in_progress']}")
        log_info(f"Completed: {stats['completed']}")
        log_info(f"Failed (queue): {stats['failed']}")
        log_info(f"Dead Letter Queue: {dlq_count} items")

        if dlq_summary:
            log_info("DLQ Error Breakdown:")
            for error_type, count in dlq_summary.items():
                log_info(f"  {error_type}: {count}")

    except Exception as e:
        log_error(f"Failed to get queue status: {e}")
        import traceback
        traceback.print_exc()


def handle_clear_queue():
    """Clear all pending queue items."""
    try:
        data_dir = get_plugin_data_dir()
        queue_path = os.path.join(data_dir, 'queue')

        from sync_queue.operations import get_stats, clear_pending_items

        before_stats = get_stats(queue_path)
        pending = before_stats['pending']

        if pending == 0:
            log_info("Queue is empty - nothing to clear")
            return

        log_warn(f"Clearing {pending} pending queue items...")
        deleted = clear_pending_items(queue_path)
        log_info(f"Successfully cleared {deleted} pending items from queue")

        after_stats = get_stats(queue_path)
        log_info(f"Remaining - Pending: {after_stats['pending']}, In Progress: {after_stats['in_progress']}")

    except Exception as e:
        log_error(f"Failed to clear queue: {e}")
        import traceback
        traceback.print_exc()


def handle_clear_dlq():
    """Clear all items from dead letter queue."""
    try:
        data_dir = get_plugin_data_dir()

        from sync_queue.dlq import DeadLetterQueue
        dlq = DeadLetterQueue(data_dir)

        count_before = dlq.get_count()

        if count_before == 0:
            log_info("Dead letter queue is empty - nothing to clear")
            return

        log_warn(f"Clearing {count_before} items from dead letter queue...")

        with dlq._get_connection() as conn:
            cursor = conn.execute("DELETE FROM dead_letters")
            deleted = cursor.rowcount
            conn.commit()

        log_info(f"Successfully cleared {deleted} items from DLQ")

    except Exception as e:
        log_error(f"Failed to clear DLQ: {e}")
        import traceback
        traceback.print_exc()


def handle_purge_dlq(days: int = 30):
    """Remove DLQ entries older than specified days."""
    try:
        data_dir = get_plugin_data_dir()

        from sync_queue.dlq import DeadLetterQueue
        dlq = DeadLetterQueue(data_dir)

        count_before = dlq.get_count()
        log_info(f"Purging DLQ entries older than {days} days...")

        dlq.delete_older_than(days)

        count_after = dlq.get_count()
        removed = count_before - count_after

        log_info(f"Removed {removed} old DLQ entries ({count_after} remain)")

    except Exception as e:
        log_error(f"Failed to purge old DLQ entries: {e}")
        import traceback
        traceback.print_exc()
```

2. Update handle_task() to dispatch new modes. Find the existing handle_task function and modify the beginning to add mode dispatch BEFORE the stash check:

Replace:
```python
def handle_task(task_args: dict, stash=None):
    """..."""
    from sync_queue.operations import enqueue

    mode = task_args.get('mode', 'recent')
    log_info(f"Task starting with mode: {mode}")

    if not stash:
        log_error("No Stash connection available")
        return
```

With:
```python
def handle_task(task_args: dict, stash=None):
    """
    Handle manual task trigger from Stash UI.

    Args:
        task_args: Task arguments (mode determines operation)
        stash: StashInterface for API calls (required for sync modes)
    """
    mode = task_args.get('mode', 'recent')
    log_info(f"Task starting with mode: {mode}")

    # Queue management tasks don't need Stash connection
    if mode == 'queue_status':
        handle_queue_status()
        return
    elif mode == 'clear_queue':
        handle_clear_queue()
        return
    elif mode == 'clear_dlq':
        handle_clear_dlq()
        return
    elif mode == 'purge_dlq':
        days = task_args.get('days', 30)
        handle_purge_dlq(days)
        return

    # Sync tasks require Stash connection
    from sync_queue.operations import enqueue

    if not stash:
        log_error("No Stash connection available")
        return
```

This ensures queue management tasks work even without stash connection and return early.
  </action>
  <verify>
Run: `python -c "import Stash2Plex; print('Import OK')"`
Check that handle_queue_status, handle_clear_queue, handle_clear_dlq, handle_purge_dlq functions exist.
  </verify>
  <done>
- 4 handler functions added to Stash2Plex.py
- handle_task dispatcher routes queue_status, clear_queue, clear_dlq, purge_dlq modes
- Queue management tasks work without Stash connection
  </done>
</task>

</tasks>

<verification>
1. YAML validation: `python -c "import yaml; y=yaml.safe_load(open('Stash2Plex.yml')); print(f'{len(y[\"tasks\"])} tasks')"`
   - Expected: "6 tasks"

2. Python imports: `python -c "from sync_queue.operations import get_stats, clear_pending_items; print('operations OK')"`

3. Main module imports: `python -c "import Stash2Plex; print('main OK')"`

4. Function existence check:
```bash
grep -E "^def handle_(queue_status|clear_queue|clear_dlq|purge_dlq)" Stash2Plex.py | wc -l
```
   - Expected: 4

5. Mode dispatch check:
```bash
grep -E "mode == '(queue_status|clear_queue|clear_dlq|purge_dlq)'" Stash2Plex.py | wc -l
```
   - Expected: 4
</verification>

<success_criteria>
- [ ] sync_queue/operations.py has clear_pending_items function
- [ ] Stash2Plex.yml has 6 tasks (2 original + 4 queue management)
- [ ] Stash2Plex.py has 4 handler functions
- [ ] handle_task dispatches to correct handler based on mode
- [ ] All Python files import without error
- [ ] YAML file is valid
</success_criteria>

<output>
After completion, create `.planning/phases/11-queue-management-ui/11-01-SUMMARY.md`
</output>
