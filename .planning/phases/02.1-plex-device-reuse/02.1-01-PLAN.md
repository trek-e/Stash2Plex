---
phase: 02.1-plex-device-reuse
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - plex/device_identity.py
  - PlexSync.py
  - tests/plex/test_device_identity.py
autonomous: true

must_haves:
  truths:
    - "Plex shows 'PlexSync Plugin' as a recognized device (not 'PlexAPI' or random identifier)"
    - "Repeated plugin invocations do not trigger 'new device' notifications"
    - "Device ID persists across plugin restarts in data_dir/device_id.json"
  artifacts:
    - path: "plex/device_identity.py"
      provides: "Device identity management"
      exports: ["load_or_create_device_id", "configure_plex_device_identity"]
    - path: "data/device_id.json"
      provides: "Persistent device identifier"
      contains: "device_id"
  key_links:
    - from: "PlexSync.py"
      to: "plex/device_identity.py"
      via: "configure_plex_device_identity(data_dir) call in initialize()"
      pattern: "configure_plex_device_identity"
    - from: "plex/device_identity.py"
      to: "plexapi module"
      via: "plexapi.X_PLEX_IDENTIFIER assignment"
      pattern: "plexapi\\.X_PLEX_IDENTIFIER"
---

<objective>
Fix Plex "new device" notifications by implementing persistent device identity.

Purpose: Each time PlexSync connects to Plex, it currently uses a different X-Plex-Client-Identifier (generated from MAC address), causing Plex to show "new device connected" notifications. This is annoying for users and clutters the Plex devices list.

Output: PlexSync will generate a UUID on first run, persist it to `data_dir/device_id.json`, and reuse it for all Plex connections. Plex will recognize PlexSync as "PlexSync Plugin" consistently.
</objective>

<execution_context>
@/Users/trekkie/.claude/get-shit-done/workflows/execute-plan.md
@/Users/trekkie/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02.1-plex-device-reuse/02.1-RESEARCH.md
@plex/client.py
@PlexSync.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create device identity module</name>
  <files>plex/device_identity.py</files>
  <action>
Create `plex/device_identity.py` with two functions:

1. `load_or_create_device_id(data_dir: str) -> str`:
   - Check if `{data_dir}/device_id.json` exists
   - If exists: load and return the device_id (with try/except for corrupt JSON)
   - If not exists or corrupt: generate `str(uuid.uuid4())`, save to file, return it
   - Ensure data_dir exists with `os.makedirs(data_dir, exist_ok=True)`
   - Log device ID loading/generation (use logging module, logger name 'PlexSync.device')

2. `configure_plex_device_identity(data_dir: str) -> str`:
   - Call `load_or_create_device_id(data_dir)` to get device_id
   - Set module-level plexapi variables:
     - `plexapi.X_PLEX_IDENTIFIER = device_id`
     - `plexapi.X_PLEX_PRODUCT = 'PlexSync'`
     - `plexapi.X_PLEX_DEVICE_NAME = 'PlexSync Plugin'`
   - Call `plexapi.BASE_HEADERS = plexapi.config.reset_base_headers()` to rebuild headers
   - Return device_id

CRITICAL: The import order matters. Import `plexapi` and `plexapi.config` at function call time, not at module level, to avoid any import timing issues.

Include proper docstrings explaining the purpose (avoiding "new device" notifications) and that this MUST be called before any PlexServer connections.
  </action>
  <verify>
    - `python -c "from plex.device_identity import load_or_create_device_id, configure_plex_device_identity; print('imports ok')"`
    - File exists at plex/device_identity.py with both functions
  </verify>
  <done>
    - `load_or_create_device_id()` creates device_id.json on first call
    - `load_or_create_device_id()` returns same ID on subsequent calls
    - `configure_plex_device_identity()` sets plexapi module variables
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate device identity into PlexSync initialization</name>
  <files>PlexSync.py</files>
  <action>
Modify `PlexSync.py` to configure device identity BEFORE any Plex connections:

1. Add import at top (with other plex imports):
   `from plex.device_identity import configure_plex_device_identity`

   Note: Add inside the existing try/except import block (line ~32-45) to handle ImportError gracefully.

2. In `initialize()` function, AFTER getting data_dir but BEFORE creating SyncWorker:
   ```python
   # Configure persistent Plex device identity (must be before PlexClient creation)
   device_id = configure_plex_device_identity(data_dir)
   log_trace(f"Using Plex device ID: {device_id[:8]}...")
   ```

   Insert this around line 218-224, after `data_dir = get_plugin_data_dir()` and before `queue_manager = QueueManager(data_dir)`.

This ensures the plexapi module variables are set before SyncWorker is created, which in turn creates PlexClient when processing jobs.
  </action>
  <verify>
    - `grep -n "configure_plex_device_identity" PlexSync.py` shows import and call
    - `python -c "import PlexSync; print('syntax ok')"` (may fail without Stash, but catches syntax errors)
  </verify>
  <done>
    - PlexSync.py imports configure_plex_device_identity
    - initialize() calls configure_plex_device_identity(data_dir) before SyncWorker creation
    - Device ID is logged on startup
  </done>
</task>

<task type="auto">
  <name>Task 3: Add unit tests for device identity module</name>
  <files>tests/plex/test_device_identity.py</files>
  <action>
Create unit tests for the device identity module:

1. Test `load_or_create_device_id()`:
   - Test creates new file when none exists (use tmp_path fixture)
   - Test returns same ID on subsequent calls
   - Test handles corrupt JSON gracefully (regenerates)
   - Test creates data_dir if it doesn't exist

2. Test `configure_plex_device_identity()`:
   - Mock `plexapi` module
   - Verify X_PLEX_IDENTIFIER is set to the device_id
   - Verify X_PLEX_PRODUCT is set to 'PlexSync'
   - Verify X_PLEX_DEVICE_NAME is set to 'PlexSync Plugin'
   - Verify reset_base_headers() is called

Use pytest with tmp_path fixture for isolated file operations.
Use unittest.mock to mock plexapi module (consistent with existing test patterns).

Follow existing test file structure in tests/plex/ directory.
  </action>
  <verify>
    - `pytest tests/plex/test_device_identity.py -v` passes all tests
    - At least 6 test cases covering main functionality
  </verify>
  <done>
    - Tests verify device ID generation and persistence
    - Tests verify plexapi module configuration
    - All tests pass
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Unit tests pass:**
   ```bash
   pytest tests/plex/test_device_identity.py -v
   ```

2. **Module imports correctly:**
   ```bash
   python -c "from plex.device_identity import configure_plex_device_identity; print('ok')"
   ```

3. **Device ID file created on first run:**
   ```bash
   # In a test environment with data directory:
   ls data/device_id.json  # Should exist after first initialization
   cat data/device_id.json  # Should contain {"device_id": "uuid-here"}
   ```

4. **Integration check (manual - run plugin):**
   - Start Stash with PlexSync enabled
   - Trigger a sync (update a scene)
   - Check Plex devices list shows "PlexSync Plugin"
   - Restart Stash, trigger another sync
   - Plex should NOT show a new device notification
</verification>

<success_criteria>
- [ ] `plex/device_identity.py` exists with both functions
- [ ] `PlexSync.py` calls `configure_plex_device_identity()` before PlexClient creation
- [ ] Device ID persists in `data_dir/device_id.json`
- [ ] Unit tests pass with >90% coverage of new module
- [ ] Plex shows "PlexSync Plugin" in devices list (manual verification)
</success_criteria>

<output>
After completion, create `.planning/phases/02.1-plex-device-reuse/02.1-01-SUMMARY.md`
</output>
