---
phase: 10-metadata-sync-toggles
plan: 02
type: execute
wave: 2
depends_on: ["10-01"]
files_modified:
  - worker/processor.py
  - tests/worker/test_processor.py
  - docs/config.md
autonomous: true

must_haves:
  truths:
    - "Master toggle OFF skips ALL field syncing"
    - "Individual toggle OFF skips that specific field (Plex keeps existing value)"
    - "Toggle OFF does NOT clear field (distinct from None/empty = clear)"
    - "Toggle ON + preserve ON behaves same as before (preserve logic unchanged)"
    - "Users can see new settings documented in config.md"
  artifacts:
    - path: "worker/processor.py"
      provides: "Toggle-aware _update_metadata with master + individual checks"
      contains: "sync_master"
    - path: "tests/worker/test_processor.py"
      provides: "Toggle behavior tests"
      contains: "test_toggle"
    - path: "docs/config.md"
      provides: "Field Sync Settings documentation"
      contains: "sync_studio"
  key_links:
    - from: "worker/processor.py"
      to: "validation/config.py"
      via: "getattr(self.config, 'sync_*', True)"
      pattern: "getattr\\(self\\.config, 'sync_"
---

<objective>
Implement toggle logic in processor and add tests and documentation.

Purpose: Make the processor respect toggle settings to skip disabled fields during sync.
Output: Toggle-aware processor, comprehensive tests, updated documentation.
</objective>

<execution_context>
@/Users/trekkie/.claude/get-shit-done/workflows/execute-plan.md
@/Users/trekkie/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-metadata-sync-toggles/10-CONTEXT.md
@.planning/phases/10-metadata-sync-toggles/10-RESEARCH.md

# Prior plan summary (config fields now available)
@.planning/phases/10-metadata-sync-toggles/10-01-SUMMARY.md

# Source files to modify
@worker/processor.py
@tests/worker/test_processor.py
@docs/config.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add toggle checks to _update_metadata</name>
  <files>worker/processor.py</files>
  <action>
Modify _update_metadata() to check toggles BEFORE existing logic. The pattern is:
- Check toggle FIRST with short-circuit: `if getattr(self.config, 'sync_field', True) and ...`
- Toggle OFF = skip entire block (don't even check if key exists in data)
- This is DISTINCT from the LOCKED Phase 9 clearing logic (key exists with None/empty = clear)

**CRITICAL PITFALL:** Toggle OFF must NOT clear the field. Toggle OFF = skip, LOCKED clearing = different behavior.

Add master toggle check at the start of _update_metadata():

```python
def _update_metadata(self, plex_item, data: dict):
    # ... existing imports ...
    result = PartialSyncResult()
    edits = {}

    # =========================================================================
    # MASTER TOGGLE CHECK - if OFF, skip ALL field syncing
    # =========================================================================
    if not getattr(self.config, 'sync_master', True):
        log_debug("Master sync toggle is OFF - skipping all field syncs")
        return result

    # ... rest of method ...
```

For each field, wrap the existing block with a toggle check. The toggle check goes OUTSIDE the 'in data' check:

**studio field (around lines 721-730):**
```python
# Handle studio field - TOGGLE CHECK FIRST
if getattr(self.config, 'sync_studio', True):
    if 'studio' in data:
        studio_value = data.get('studio')
        if studio_value is None or studio_value == '':
            # LOCKED: Clear existing Plex value
            edits['studio.value'] = ''
            log_debug("Clearing studio (Stash value is empty)")
        else:
            sanitized = sanitize_for_plex(studio_value, max_length=MAX_STUDIO_LENGTH)
            if not self.config.preserve_plex_edits or not plex_item.studio:
                edits['studio.value'] = sanitized
```

Apply the same pattern to ALL fields:
- **summary** (lines ~734-744): wrap with `if getattr(self.config, 'sync_summary', True):`
- **tagline** (lines ~747-756): wrap with `if getattr(self.config, 'sync_tagline', True):`
- **date** (lines ~759-767): wrap with `if getattr(self.config, 'sync_date', True):`
- **performers** (lines ~788-836): wrap with `if getattr(self.config, 'sync_performers', True):`
- **poster** (lines ~839-859): wrap with `if getattr(self.config, 'sync_poster', True):`
- **background** (lines ~862-882): wrap with `if getattr(self.config, 'sync_background', True):`
- **tags** (lines ~886-933): wrap with `if getattr(self.config, 'sync_tags', True):`
- **collection** (lines ~936-955): wrap with `if getattr(self.config, 'sync_collection', True):`

**Note:** Title is NOT toggle-able (LOCKED decision - required for matching). Keep title handling unchanged.

**Note:** The 'if field in data' check stays INSIDE the toggle check. This ensures toggle OFF = skip entirely.
  </action>
  <verify>
Run existing processor tests: `pytest tests/worker/test_processor.py -v`
All existing tests should pass (toggle defaults True = no behavior change).
  </verify>
  <done>
_update_metadata() checks master toggle first, then individual toggles before each field block. Toggle OFF = skip field entirely (no clear, no sync).
  </done>
</task>

<task type="auto">
  <name>Task 2: Add toggle behavior tests</name>
  <files>tests/worker/test_processor.py</files>
  <action>
Add a new test class `TestSyncToggles` to test_processor.py with comprehensive toggle behavior tests:

```python
class TestSyncToggles:
    """Tests for field sync toggle behavior."""

    def test_master_toggle_off_skips_all_fields(self, mock_plex_item, mock_config):
        """When sync_master=False, no fields are synced."""
        mock_config.sync_master = False
        mock_config.sync_studio = True  # Even with individual ON

        processor = create_processor(mock_config)
        data = {'studio': 'Test Studio', 'details': 'Test Summary'}

        result = processor._update_metadata(mock_plex_item, data)

        # edit() should not be called at all
        mock_plex_item.edit.assert_not_called()

    def test_individual_toggle_off_skips_that_field(self, mock_plex_item, mock_config):
        """When individual toggle=False, that field is skipped."""
        mock_config.sync_master = True
        mock_config.sync_studio = False
        mock_config.sync_summary = True

        processor = create_processor(mock_config)
        data = {'studio': 'Test Studio', 'details': 'Test Summary'}

        result = processor._update_metadata(mock_plex_item, data)

        # edit() should be called but only with summary, not studio
        assert mock_plex_item.edit.called
        edit_kwargs = mock_plex_item.edit.call_args_list[0][1]
        assert 'studio.value' not in edit_kwargs
        assert 'summary.value' in edit_kwargs

    def test_toggle_off_does_not_clear_field(self, mock_plex_item, mock_config):
        """Toggle OFF should NOT clear the Plex field (distinct from empty value clearing)."""
        mock_config.sync_master = True
        mock_config.sync_studio = False
        mock_plex_item.studio = "Existing Studio"  # Plex has a value

        processor = create_processor(mock_config)
        data = {'studio': 'New Studio'}  # Stash has a value

        result = processor._update_metadata(mock_plex_item, data)

        # Studio should NOT appear in edits at all (not cleared, not updated)
        if mock_plex_item.edit.called:
            for call in mock_plex_item.edit.call_args_list:
                kwargs = call[1]
                assert 'studio.value' not in kwargs, "Toggle OFF should skip field, not clear it"

    def test_toggle_on_with_empty_value_clears_field(self, mock_plex_item, mock_config):
        """Toggle ON with None/empty value should CLEAR field (LOCKED decision)."""
        mock_config.sync_master = True
        mock_config.sync_studio = True
        mock_plex_item.studio = "Existing Studio"

        processor = create_processor(mock_config)
        data = {'studio': None}  # Stash value is None

        result = processor._update_metadata(mock_plex_item, data)

        # Studio should be cleared (LOCKED Phase 9 behavior)
        edit_kwargs = mock_plex_item.edit.call_args_list[0][1]
        assert edit_kwargs.get('studio.value') == ''

    def test_toggle_on_preserves_preserve_mode_behavior(self, mock_plex_item, mock_config):
        """Toggle ON + preserve_plex_edits ON should preserve existing values."""
        mock_config.sync_master = True
        mock_config.sync_studio = True
        mock_config.preserve_plex_edits = True
        mock_plex_item.studio = "Existing Studio"  # Plex has value

        processor = create_processor(mock_config)
        data = {'studio': 'New Studio'}

        result = processor._update_metadata(mock_plex_item, data)

        # With preserve mode, existing value should be kept
        if mock_plex_item.edit.called:
            for call in mock_plex_item.edit.call_args_list:
                kwargs = call[1]
                assert 'studio.value' not in kwargs, "Preserve mode should skip field with existing value"

    def test_all_individual_toggles_respected(self, mock_plex_item, mock_config):
        """Each individual toggle should control its respective field."""
        # Set all toggles OFF except one
        mock_config.sync_master = True
        mock_config.sync_studio = False
        mock_config.sync_summary = False
        mock_config.sync_tagline = True  # Only this ON
        mock_config.sync_date = False

        processor = create_processor(mock_config)
        data = {
            'studio': 'Test Studio',
            'details': 'Test Summary',
            'tagline': 'Test Tagline',
            'date': '2024-01-01',
        }

        result = processor._update_metadata(mock_plex_item, data)

        # Only tagline should be in edits
        edit_kwargs = mock_plex_item.edit.call_args_list[0][1]
        assert 'studio.value' not in edit_kwargs
        assert 'summary.value' not in edit_kwargs
        assert 'tagline.value' in edit_kwargs
        assert 'originallyAvailableAt.value' not in edit_kwargs

    def test_performers_toggle_off_skips_performers(self, mock_plex_item, mock_config):
        """sync_performers=False should skip performer sync entirely."""
        mock_config.sync_master = True
        mock_config.sync_performers = False
        mock_plex_item.actors = []

        processor = create_processor(mock_config)
        data = {'performers': ['Actor 1', 'Actor 2']}

        result = processor._update_metadata(mock_plex_item, data)

        # No performer-related edits should happen
        for call in mock_plex_item.edit.call_args_list:
            kwargs = call[1]
            assert not any('actor' in k for k in kwargs.keys())

    def test_tags_toggle_off_skips_tags(self, mock_plex_item, mock_config):
        """sync_tags=False should skip tag/genre sync entirely."""
        mock_config.sync_master = True
        mock_config.sync_tags = False
        mock_plex_item.genres = []

        processor = create_processor(mock_config)
        data = {'tags': ['Genre 1', 'Genre 2']}

        result = processor._update_metadata(mock_plex_item, data)

        # No genre-related edits should happen
        for call in mock_plex_item.edit.call_args_list:
            kwargs = call[1]
            assert not any('genre' in k for k in kwargs.keys())

    def test_poster_toggle_off_skips_poster(self, mock_plex_item, mock_config, mocker):
        """sync_poster=False should skip poster upload."""
        mock_config.sync_master = True
        mock_config.sync_poster = False

        processor = create_processor(mock_config)
        # Mock the image fetch to verify it's not called
        fetch_mock = mocker.patch.object(processor, '_fetch_stash_image')

        data = {'poster_url': 'http://stash/image.jpg'}

        result = processor._update_metadata(mock_plex_item, data)

        # uploadPoster should not be called
        mock_plex_item.uploadPoster.assert_not_called()
        # Image fetch might or might not be called, but poster upload shouldn't happen

    def test_collection_toggle_off_skips_collection(self, mock_plex_item, mock_config):
        """sync_collection=False should skip collection assignment."""
        mock_config.sync_master = True
        mock_config.sync_collection = False
        mock_plex_item.collections = []

        processor = create_processor(mock_config)
        data = {'studio': 'Test Studio'}  # Studio triggers collection

        result = processor._update_metadata(mock_plex_item, data)

        # No collection-related edits should happen
        for call in mock_plex_item.edit.call_args_list:
            kwargs = call[1]
            assert not any('collection' in k for k in kwargs.keys())
```

Ensure proper imports at top of file:
- Import `PlexSyncConfig` if not already imported
- Helper function `create_processor` may need to be added or use existing patterns

If `create_processor` helper doesn't exist, add it:
```python
def create_processor(config):
    """Create a SyncWorker for testing _update_metadata."""
    from worker.processor import SyncWorker
    from unittest.mock import MagicMock
    queue = MagicMock()
    dlq = MagicMock()
    return SyncWorker(queue=queue, dlq=dlq, config=config)
```

Add toggle attributes to mock_config fixture if needed.
  </action>
  <verify>
Run toggle tests: `pytest tests/worker/test_processor.py::TestSyncToggles -v`
All 10 tests should pass.
Run full processor tests: `pytest tests/worker/test_processor.py -v`
All tests should pass (existing + new).
  </verify>
  <done>
TestSyncToggles class with 10 tests covering master toggle, individual toggles, toggle OFF vs clearing distinction, and preserve mode interaction.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update config.md documentation</name>
  <files>docs/config.md</files>
  <action>
Add a new "Field Sync Settings" section to docs/config.md after the existing settings documentation.

**Location:** After the "Timeouts" or "Advanced Settings" section, before any examples.

Add this new section:

```markdown
## Field Sync Settings

Control which metadata fields sync from Stash to Plex. All toggles are **enabled by default**.

| Setting | Type | Default | Description |
|---------|------|---------|-------------|
| `sync_master` | boolean | `true` | Master toggle - when OFF, no fields are synced |
| `sync_studio` | boolean | `true` | Sync studio name to Plex |
| `sync_summary` | boolean | `true` | Sync summary/details to Plex |
| `sync_tagline` | boolean | `true` | Sync tagline to Plex |
| `sync_date` | boolean | `true` | Sync release date to Plex |
| `sync_performers` | boolean | `true` | Sync performers as Plex actors |
| `sync_tags` | boolean | `true` | Sync tags as Plex genres |
| `sync_poster` | boolean | `true` | Sync poster image to Plex |
| `sync_background` | boolean | `true` | Sync background/fanart image to Plex |
| `sync_collection` | boolean | `true` | Add to Plex collection based on studio name |

### Toggle Behavior

- **Toggle OFF:** Field is skipped entirely. Plex keeps its existing value.
- **Toggle ON + empty value:** Field is cleared in Plex (per Phase 9 clearing behavior).
- **Toggle ON + `preserve_plex_edits`:** Existing Plex values are preserved if present.

### Common Use Cases

**Sync only core metadata (skip images and collections):**
```
sync_poster: false
sync_background: false
sync_collection: false
```

**Sync only performers (for cast-focused libraries):**
```
sync_studio: false
sync_summary: false
sync_tagline: false
sync_date: false
sync_tags: false
sync_poster: false
sync_background: false
sync_collection: false
# sync_performers defaults to true
```

**Disable all syncing temporarily:**
```
sync_master: false
```

> **Note:** Title and file path are always synced (required for matching) and cannot be toggled off.
```

Also update any examples section that shows configuration to mention toggle settings are available.
  </action>
  <verify>
Build docs: `mkdocs build` (if mkdocs available) or manually verify markdown renders correctly.
Check documentation includes new Field Sync Settings section.
  </verify>
  <done>
docs/config.md has new "Field Sync Settings" section with table of 10 settings, behavior explanation, and common use case examples.
  </done>
</task>

</tasks>

<verification>
1. `pytest tests/worker/test_processor.py -v` - all tests pass including 10 new toggle tests
2. Manual test: Create config with `sync_studio=False`, verify studio not synced
3. `mkdocs build` - documentation builds without errors (if available)
4. All existing functionality preserved (toggle defaults = True = same behavior)
</verification>

<success_criteria>
- _update_metadata() checks sync_master first, then individual toggles
- Toggle OFF skips field entirely (no clear, no sync)
- Toggle ON preserves all existing behavior (preserve mode, clearing)
- 10+ new tests verify toggle behavior
- docs/config.md documents all 10 toggle settings with examples
</success_criteria>

<output>
After completion, create `.planning/phases/10-metadata-sync-toggles/10-02-SUMMARY.md`
</output>
