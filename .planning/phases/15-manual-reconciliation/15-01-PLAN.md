---
phase: 15-manual-reconciliation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Stash2Plex.yml
  - Stash2Plex.py
  - tests/reconciliation/test_reconcile_task.py
autonomous: true
must_haves:
  truths:
    - "User can trigger 'Reconcile Library' task from Stash plugin task menu"
    - "User can choose reconciliation scope: all scenes or recent scenes (last 24 hours)"
    - "Reconciliation logs progress summary showing gap counts by type (empty metadata: X, stale sync: Y, missing from Plex: Z)"
    - "Reconciliation enqueues gaps without processing them inline"
  artifacts:
    - path: "Stash2Plex.yml"
      provides: "Two new task entries for reconciliation"
      contains: "Reconcile Library"
    - path: "Stash2Plex.py"
      provides: "handle_reconcile function and mode dispatch"
      contains: "handle_reconcile"
    - path: "tests/reconciliation/test_reconcile_task.py"
      provides: "Tests for reconciliation task handler"
      min_lines: 80
  key_links:
    - from: "Stash2Plex.yml"
      to: "Stash2Plex.py"
      via: "task defaultArgs mode values"
      pattern: "mode: reconcile_(all|recent)"
    - from: "Stash2Plex.py handle_task()"
      to: "Stash2Plex.py handle_reconcile()"
      via: "mode dispatch in handle_task"
      pattern: "mode.*reconcile"
    - from: "Stash2Plex.py handle_reconcile()"
      to: "reconciliation/engine.py GapDetectionEngine"
      via: "import and instantiation"
      pattern: "GapDetectionEngine"
---

<objective>
Wire the GapDetectionEngine into the Stash plugin task system so users can trigger reconciliation on-demand.

Purpose: This is the user-facing entry point for reconciliation -- Phase 14 built the engine, this phase exposes it through the Stash UI task menu with scope control and progress logging.
Output: Two new Stash tasks ("Reconcile Library (All)" and "Reconcile Library (Recent)"), a handler function, and tests.
</objective>

<execution_context>
@/Users/trekkie/.claude/get-shit-done/workflows/execute-plan.md
@/Users/trekkie/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-gap-detection-engine/14-02-SUMMARY.md
@Stash2Plex.py
@Stash2Plex.yml
@reconciliation/engine.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add reconciliation tasks to plugin YAML and handler to Stash2Plex.py</name>
  <files>Stash2Plex.yml, Stash2Plex.py</files>
  <action>
**Stash2Plex.yml** -- Add two new task entries in the `tasks:` section (after the existing "Process Queue" entry):

```yaml
- name: Reconcile Library (All)
  description: Detect and queue metadata gaps for all scenes (empty metadata, stale syncs, missing from Plex)
  defaultArgs:
    mode: reconcile_all
- name: Reconcile Library (Recent)
  description: Detect and queue metadata gaps for scenes updated in the last 24 hours
  defaultArgs:
    mode: reconcile_recent
```

**Stash2Plex.py** -- Three changes:

1. **Add `handle_reconcile(scope)` function** (place it after `handle_process_queue()`, before `is_scan_job_running()`). Follow the exact pattern of existing handlers (handle_queue_status, handle_clear_queue, etc.):

```python
def handle_reconcile(scope: str):
    """
    Run gap detection and enqueue discovered gaps for sync.

    Args:
        scope: "all" (all scenes) or "recent" (last 24 hours)
    """
    try:
        data_dir = get_plugin_data_dir()

        from reconciliation.engine import GapDetectionEngine, GapDetectionResult

        # Need stash and config globals
        if not stash_interface:
            log_error("No Stash connection available for reconciliation")
            return
        if not config:
            log_error("No config available for reconciliation")
            return

        # Get queue for enqueue mode
        queue = queue_manager.get_queue() if queue_manager else None
        if not queue:
            log_warn("No queue available - running in detection-only mode")

        scope_label = "all scenes" if scope == "all" else "recent scenes (last 24 hours)"
        log_info(f"Starting reconciliation: {scope_label}")

        engine = GapDetectionEngine(
            stash=stash_interface,
            config=config,
            data_dir=data_dir,
            queue=queue
        )
        result = engine.run(scope=scope)

        # Log progress summary (RECON-02: gap counts by type)
        log_info("=== Reconciliation Summary ===")
        log_info(f"Scenes checked: {result.scenes_checked}")
        log_info(f"Gaps found: {result.total_gaps}")
        log_info(f"  Empty metadata: {result.empty_metadata_count}")
        log_info(f"  Stale sync: {result.stale_sync_count}")
        log_info(f"  Missing from Plex: {result.missing_count}")
        if queue:
            log_info(f"Enqueued: {result.enqueued_count}")
            if result.skipped_already_queued:
                log_info(f"Skipped (already queued): {result.skipped_already_queued}")
        else:
            log_info("Detection-only mode (no items enqueued)")

        if result.errors:
            for err in result.errors:
                log_warn(f"Error during reconciliation: {err}")

    except Exception as e:
        log_error(f"Reconciliation failed: {e}")
        import traceback
        traceback.print_exc()
```

2. **Wire into `handle_task()` dispatch** -- Add two new elif branches in the mode dispatch block (after the `process_queue` branch at line 786, before the "Sync tasks require Stash connection" comment at line 789):

```python
    elif mode == 'reconcile_all':
        handle_reconcile('all')
        return
    elif mode == 'reconcile_recent':
        handle_reconcile('recent')
        return
```

3. **Add reconcile modes to management_modes set** -- At line 1019, add `'reconcile_all', 'reconcile_recent'` to the `management_modes` set. Reconcile tasks enqueue gaps but the engine handles logging the summary, and the queue worker processes items asynchronously. We do NOT want the main process to wait/poll for the queued items to finish (reconciliation could enqueue hundreds of items -- the user should trigger "Process Queue" separately if desired).
  </action>
  <verify>
    Run: `python3 -c "from Stash2Plex import handle_reconcile; print('import OK')"`
    Run: `grep -n 'reconcile' Stash2Plex.py` -- should show handle_reconcile function and mode dispatch
    Run: `grep -n 'reconcile' Stash2Plex.yml` -- should show two task entries
  </verify>
  <done>
    - Stash2Plex.yml has two reconciliation task entries with modes reconcile_all and reconcile_recent
    - handle_reconcile(scope) function exists and creates GapDetectionEngine with stash, config, data_dir, queue
    - handle_task() dispatches reconcile_all and reconcile_recent modes to handle_reconcile()
    - Progress summary logs gap counts by type (empty metadata: X, stale sync: Y, missing from Plex: Z)
    - Reconcile modes are in management_modes (no wait-for-queue polling)
  </done>
</task>

<task type="auto">
  <name>Task 2: Add tests for reconciliation task handler</name>
  <files>tests/reconciliation/test_reconcile_task.py</files>
  <action>
Create `tests/reconciliation/test_reconcile_task.py` with tests for the reconciliation task handler. Use the same mocking patterns as tests/reconciliation/test_engine.py (mock stash, config, queue_manager).

**Test cases to cover:**

1. **test_handle_reconcile_all_scope** -- Mock GapDetectionEngine, call handle_reconcile("all"), verify engine.run(scope="all") was called
2. **test_handle_reconcile_recent_scope** -- Same but with "recent" scope
3. **test_handle_reconcile_logs_summary** -- Verify log output contains gap counts by type. Mock engine.run() to return a GapDetectionResult with known counts (e.g., empty_metadata_count=3, stale_sync_count=2, missing_count=5, total_gaps=10, enqueued_count=8, skipped_already_queued=2, scenes_checked=100). Capture stderr and verify it contains "Empty metadata: 3", "Stale sync: 2", "Missing from Plex: 5", "Enqueued: 8", "Skipped (already queued): 2"
4. **test_handle_reconcile_no_stash** -- Set stash_interface to None, call handle_reconcile("all"), verify it logs error and returns without crashing
5. **test_handle_reconcile_no_config** -- Set config to None, call handle_reconcile("all"), verify it logs error and returns
6. **test_handle_reconcile_no_queue** -- Set queue_manager to None, verify it runs in detection-only mode (logs "Detection-only mode")
7. **test_handle_reconcile_engine_errors** -- Set result.errors to ["some error"], verify errors are logged as warnings
8. **test_handle_task_dispatches_reconcile_all** -- Call handle_task({"mode": "reconcile_all"}), verify handle_reconcile is called with "all"
9. **test_handle_task_dispatches_reconcile_recent** -- Call handle_task({"mode": "reconcile_recent"}), verify handle_reconcile is called with "recent"
10. **test_reconcile_modes_in_management_modes** -- Verify reconcile_all and reconcile_recent are in management_modes set (import the line or check behavior: calling handle_task with reconcile mode should not trigger the queue-wait logic)

**Mocking approach:** Since Stash2Plex.py uses module-level globals (stash_interface, config, queue_manager), use `unittest.mock.patch` to set `Stash2Plex.stash_interface`, `Stash2Plex.config`, `Stash2Plex.queue_manager`. For engine, patch `reconciliation.engine.GapDetectionEngine` or patch at the import location within Stash2Plex.

**Important:** Use `capsys` or `capfd` from pytest to capture stderr output (Stash log functions write to stderr). The log functions use the `\x01i\x02` prefix format, so assertions should account for that.
  </action>
  <verify>
    Run: `python3 -m pytest tests/reconciliation/test_reconcile_task.py -v` -- all tests pass
    Run: `python3 -m pytest --cov --cov-fail-under=80` -- full suite passes, coverage maintained
  </verify>
  <done>
    - 10 test cases covering all reconciliation task handler scenarios
    - Tests verify scope dispatch, log output format, error handling, and mode routing
    - Full test suite passes with 80%+ coverage maintained
  </done>
</task>

</tasks>

<verification>
1. `python3 -m pytest tests/reconciliation/test_reconcile_task.py -v` -- all reconciliation task tests pass
2. `python3 -m pytest tests/reconciliation/ -v` -- all reconciliation tests pass (detector + engine + task)
3. `python3 -m pytest --cov --cov-fail-under=80` -- full suite passes, 80%+ coverage maintained
4. `grep 'Reconcile Library' Stash2Plex.yml` -- two task entries visible
5. `grep 'reconcile' Stash2Plex.py | head -20` -- handler function and dispatch visible
</verification>

<success_criteria>
- Two new tasks appear in Stash2Plex.yml: "Reconcile Library (All)" and "Reconcile Library (Recent)"
- handle_reconcile() creates GapDetectionEngine with correct dependencies (stash, config, data_dir, queue)
- handle_task() correctly dispatches reconcile_all/reconcile_recent modes
- Progress summary logs show gap counts by type: "Empty metadata: X", "Stale sync: Y", "Missing from Plex: Z"
- Reconciliation enqueues gaps (does not process inline) and logs enqueue count
- Reconcile modes do not trigger queue-wait polling (in management_modes)
- All tests pass, 80%+ coverage maintained
</success_criteria>

<output>
After completion, create `.planning/phases/15-manual-reconciliation/15-01-SUMMARY.md`
</output>
