---
phase: 16-automated-reconciliation-reporting
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - validation/config.py
  - Stash2Plex.yml
  - reconciliation/scheduler.py
  - reconciliation/__init__.py
  - Stash2Plex.py
autonomous: true

must_haves:
  truths:
    - "Plugin runs periodic reconciliation at configured interval (never/hourly/daily/weekly) without user action"
    - "Plugin auto-triggers reconciliation on Stash startup, scoped to recent scenes only (last 24 hours)"
    - "User can configure reconciliation scope with date range options (all/24h/7days/custom range)"
    - "View Queue Status task displays last reconciliation run time, total gaps found, and gaps queued by type"
  artifacts:
    - path: "validation/config.py"
      provides: "reconcile_interval and reconcile_scope config fields"
      contains: "reconcile_interval"
    - path: "Stash2Plex.yml"
      provides: "New settings for reconciliation scheduling"
      contains: "reconcile_interval"
    - path: "reconciliation/scheduler.py"
      provides: "ReconciliationScheduler class with state persistence and due-check logic"
      exports: ["ReconciliationScheduler"]
    - path: "reconciliation/__init__.py"
      provides: "Re-exports ReconciliationScheduler"
      contains: "ReconciliationScheduler"
    - path: "Stash2Plex.py"
      provides: "Auto-reconciliation on startup/interval, enhanced queue status"
      contains: "maybe_auto_reconcile"
  key_links:
    - from: "Stash2Plex.py main()"
      to: "reconciliation/scheduler.py"
      via: "maybe_auto_reconcile() call after initialization"
      pattern: "maybe_auto_reconcile"
    - from: "reconciliation/scheduler.py"
      to: "reconciliation/engine.py"
      via: "GapDetectionEngine.run() when reconciliation is due"
      pattern: "engine\\.run"
    - from: "Stash2Plex.py handle_queue_status()"
      to: "reconciliation/scheduler.py"
      via: "ReconciliationScheduler.load_state() for last run info"
      pattern: "load_state|last_run"
    - from: "Stash2Plex.yml settings"
      to: "validation/config.py"
      via: "Stash plugin settings -> config fields"
      pattern: "reconcile_interval"
---

<objective>
Implement automated reconciliation scheduling, configurable scope, and enhanced queue status reporting.

Purpose: Complete the v1.4 reconciliation feature set by allowing the plugin to automatically detect and repair metadata gaps on a schedule, with startup triggers and rich status reporting.

Output: Working auto-reconciliation system that triggers on Stash startup (recent scope) and at configurable intervals (never/hourly/daily/weekly), with scope options (all/24h/7days/custom), and enhanced "View Queue Status" showing reconciliation history.
</objective>

<execution_context>
@/Users/trekkie/.claude/get-shit-done/workflows/execute-plan.md
@/Users/trekkie/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-gap-detection-engine/14-02-SUMMARY.md
@.planning/phases/15-manual-reconciliation/15-01-SUMMARY.md
@reconciliation/engine.py
@reconciliation/__init__.py
@validation/config.py
@Stash2Plex.yml
@Stash2Plex.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add config settings and create reconciliation scheduler with state persistence</name>
  <files>
    validation/config.py
    Stash2Plex.yml
    reconciliation/scheduler.py
    reconciliation/__init__.py
  </files>
  <action>
**CRITICAL ARCHITECTURE NOTE:** Stash plugins are NOT long-running daemons. They are invoked per-event (hook or task) and exit when done. The "scheduler" is therefore a **check-on-invocation** pattern: each time the plugin runs, check if reconciliation is due based on persisted state.

**1. validation/config.py** -- Add two new fields to `Stash2PlexConfig`:

```python
# Reconciliation settings
reconcile_interval: str = Field(
    default="never",
    description="Auto-reconciliation interval: never, hourly, daily, weekly"
)
reconcile_scope: str = Field(
    default="24h",
    description="Default reconciliation scope: all, 24h, 7days"
)
```

Add a field_validator for `reconcile_interval`:
```python
@field_validator('reconcile_interval', mode='before')
@classmethod
def validate_reconcile_interval(cls, v):
    valid = ('never', 'hourly', 'daily', 'weekly')
    if isinstance(v, str) and v.lower() in valid:
        return v.lower()
    raise ValueError(f"reconcile_interval must be one of {valid}, got: {v}")
```

Add a field_validator for `reconcile_scope`:
```python
@field_validator('reconcile_scope', mode='before')
@classmethod
def validate_reconcile_scope(cls, v):
    valid = ('all', '24h', '7days')
    if isinstance(v, str) and v.lower() in valid:
        return v.lower()
    raise ValueError(f"reconcile_scope must be one of {valid}, got: {v}")
```

**2. Stash2Plex.yml** -- Add two new settings entries in the settings section (after `obfuscate_paths`):

```yaml
  reconcile_interval:
    displayName: "Auto-Reconciliation Interval"
    description: "How often to auto-check for metadata gaps (never/hourly/daily/weekly). Default: never"
    type: STRING
  reconcile_scope:
    displayName: "Auto-Reconciliation Scope"
    description: "Default scope for auto-reconciliation (all/24h/7days). Default: 24h"
    type: STRING
```

**3. reconciliation/scheduler.py** -- Create new module with `ReconciliationScheduler` class:

```python
"""
Reconciliation scheduler for automatic gap detection.

Since Stash plugins are invoked per-event (not long-running), the scheduler
uses a check-on-invocation pattern: each plugin run checks if reconciliation
is due based on persisted state in reconciliation_state.json.
"""

import json
import os
import sys
import time
from dataclasses import dataclass, field, asdict
from typing import Optional

# Stash plugin log helpers
def log_info(msg): print(f"\x01i\x02[Stash2Plex Scheduler] {msg}", file=sys.stderr)
def log_debug(msg): print(f"\x01d\x02[Stash2Plex Scheduler] {msg}", file=sys.stderr)

# Interval to seconds mapping
INTERVAL_SECONDS = {
    'never': 0,
    'hourly': 3600,
    'daily': 86400,
    'weekly': 604800,
}

# Scope to engine scope mapping
SCOPE_MAP = {
    'all': 'all',
    '24h': 'recent',
    '7days': 'recent_7days',
}


@dataclass
class ReconciliationState:
    """Persisted state for reconciliation scheduling."""
    last_run_time: float = 0.0          # time.time() of last run
    last_run_scope: str = ""            # scope used
    last_gaps_found: int = 0            # total gaps detected
    last_gaps_by_type: dict = field(default_factory=dict)  # {empty: N, stale: N, missing: N}
    last_enqueued: int = 0              # gaps enqueued
    last_scenes_checked: int = 0        # scenes checked
    is_startup_run: bool = False        # was last run a startup trigger?
    run_count: int = 0                  # total runs


class ReconciliationScheduler:
    """Manages auto-reconciliation scheduling via persisted state.

    NOT a timer/thread. On each plugin invocation, call is_due() to check
    if reconciliation should run based on interval config and last run time.
    """

    STATE_FILE = 'reconciliation_state.json'

    def __init__(self, data_dir: str):
        self.data_dir = data_dir
        self.state_path = os.path.join(data_dir, self.STATE_FILE)

    def load_state(self) -> ReconciliationState:
        """Load reconciliation state from disk."""
        try:
            if os.path.exists(self.state_path):
                with open(self.state_path, 'r') as f:
                    data = json.load(f)
                return ReconciliationState(**data)
        except (json.JSONDecodeError, TypeError, KeyError) as e:
            log_debug(f"Failed to load reconciliation state, using defaults: {e}")
        return ReconciliationState()

    def save_state(self, state: ReconciliationState) -> None:
        """Save reconciliation state to disk atomically."""
        tmp_path = self.state_path + '.tmp'
        try:
            with open(tmp_path, 'w') as f:
                json.dump(asdict(state), f, indent=2)
            os.replace(tmp_path, self.state_path)
        except OSError as e:
            log_debug(f"Failed to save reconciliation state: {e}")

    def is_due(self, interval: str, now: Optional[float] = None) -> bool:
        """Check if auto-reconciliation is due based on interval and last run time.

        Args:
            interval: 'never', 'hourly', 'daily', 'weekly'
            now: Current time (default: time.time()). For testing.

        Returns:
            True if reconciliation should run now.
        """
        if interval == 'never':
            return False

        interval_secs = INTERVAL_SECONDS.get(interval, 0)
        if interval_secs == 0:
            return False

        if now is None:
            now = time.time()

        state = self.load_state()
        elapsed = now - state.last_run_time
        return elapsed >= interval_secs

    def is_startup_due(self, now: Optional[float] = None) -> bool:
        """Check if startup reconciliation should run.

        Startup reconciliation runs if the plugin has never run reconciliation
        before, or if more than 1 hour has passed since the last run.
        This avoids re-running on rapid Stash restarts.

        Args:
            now: Current time (default: time.time()). For testing.

        Returns:
            True if startup reconciliation should run.
        """
        if now is None:
            now = time.time()

        state = self.load_state()
        if state.last_run_time == 0.0:
            return True  # Never run before

        elapsed = now - state.last_run_time
        return elapsed >= 3600  # At least 1 hour since last run

    def record_run(self, result, scope: str, is_startup: bool = False) -> None:
        """Record a completed reconciliation run.

        Args:
            result: GapDetectionResult from engine.run()
            scope: Scope string used
            is_startup: Whether this was a startup-triggered run
        """
        state = self.load_state()
        state.last_run_time = time.time()
        state.last_run_scope = scope
        state.last_gaps_found = result.total_gaps
        state.last_gaps_by_type = {
            'empty_metadata': result.empty_metadata_count,
            'stale_sync': result.stale_sync_count,
            'missing': result.missing_count,
        }
        state.last_enqueued = result.enqueued_count
        state.last_scenes_checked = result.scenes_checked
        state.is_startup_run = is_startup
        state.run_count += 1
        self.save_state(state)
```

**4. reconciliation/__init__.py** -- Add re-exports:

Add `ReconciliationScheduler` and `ReconciliationState` to the imports and `__all__`:
```python
from reconciliation.scheduler import ReconciliationScheduler, ReconciliationState
```

Add to `__all__`: `'ReconciliationScheduler'`, `'ReconciliationState'`
  </action>
  <verify>
```bash
python3 -c "from reconciliation.scheduler import ReconciliationScheduler, ReconciliationState, INTERVAL_SECONDS; print('OK')"
python3 -c "from validation.config import Stash2PlexConfig; c = Stash2PlexConfig(plex_url='http://localhost:32400', plex_token='abcdefghijk'); print(c.reconcile_interval, c.reconcile_scope)"
python3 -c "import yaml; d = yaml.safe_load(open('Stash2Plex.yml')); print('reconcile_interval' in d.get('settings', {}))"
```
  </verify>
  <done>
- Stash2PlexConfig has reconcile_interval (never/hourly/daily/weekly, default: never) and reconcile_scope (all/24h/7days, default: 24h) fields with validators
- Stash2Plex.yml has matching settings entries
- ReconciliationScheduler class persists state to reconciliation_state.json
- Scheduler has is_due(), is_startup_due(), load_state(), save_state(), record_run() methods
- ReconciliationState dataclass stores last run time, gaps found by type, enqueued count, scenes checked
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire auto-reconciliation into plugin lifecycle and enhance queue status</name>
  <files>
    Stash2Plex.py
    reconciliation/engine.py
  </files>
  <action>
**1. Stash2Plex.py** -- Add `maybe_auto_reconcile()` function and wire it into `main()`:

**Add `maybe_auto_reconcile()` function** (place it after `handle_reconcile()`, before `handle_task()`):

```python
def maybe_auto_reconcile():
    """Check if auto-reconciliation is due and run it if so.

    Called on every plugin invocation (hook or task). Checks:
    1. If this is the first invocation since Stash startup -> run recent scope
    2. If reconcile_interval has elapsed -> run configured scope

    This is a lightweight check (reads one JSON file) that only triggers
    the heavier gap detection when reconciliation is actually due.
    """
    if not config or config.reconcile_interval == 'never':
        return

    if not stash_interface or not queue_manager:
        return

    try:
        data_dir = get_plugin_data_dir()
        from reconciliation.scheduler import ReconciliationScheduler

        scheduler = ReconciliationScheduler(data_dir)

        # Check startup trigger first (AUTO-02)
        if scheduler.is_startup_due():
            log_info("Auto-reconciliation: startup trigger (recent scenes)")
            _run_auto_reconcile(scheduler, scope="recent", is_startup=True)
            return

        # Check interval trigger (AUTO-01)
        if scheduler.is_due(config.reconcile_interval):
            # Map config scope to engine scope (AUTO-03)
            scope_map = {'all': 'all', '24h': 'recent', '7days': 'recent'}
            engine_scope = scope_map.get(config.reconcile_scope, 'recent')
            log_info(f"Auto-reconciliation: interval trigger ({config.reconcile_interval}, scope: {config.reconcile_scope})")
            _run_auto_reconcile(scheduler, scope=engine_scope, is_startup=False)
            return

    except Exception as e:
        log_warn(f"Auto-reconciliation check failed: {e}")


def _run_auto_reconcile(scheduler, scope: str, is_startup: bool):
    """Execute auto-reconciliation and record results.

    Args:
        scheduler: ReconciliationScheduler instance
        scope: Engine scope ('all' or 'recent')
        is_startup: Whether triggered by startup
    """
    try:
        data_dir = get_plugin_data_dir()
        from reconciliation.engine import GapDetectionEngine

        queue = queue_manager.get_queue() if queue_manager else None

        engine = GapDetectionEngine(
            stash=stash_interface,
            config=config,
            data_dir=data_dir,
            queue=queue
        )
        result = engine.run(scope=scope)

        # Record the run
        scope_label = config.reconcile_scope if not is_startup else "recent (startup)"
        scheduler.record_run(result, scope=scope_label, is_startup=is_startup)

        log_info(f"Auto-reconciliation complete: {result.total_gaps} gaps found, {result.enqueued_count} enqueued")

    except Exception as e:
        log_warn(f"Auto-reconciliation failed: {e}")
```

**Wire into main():** In the `main()` function, add a call to `maybe_auto_reconcile()` AFTER the initialization block (after line ~1059 `initialize(config_dict)`) but BEFORE the hook/task handling. Place it right before the `# Check if plugin is disabled` block at line ~1061, or after the disabled check. The exact insertion point is after:
```python
    if config and not config.enabled:
        print(json.dumps({"output": "disabled"}))
        return
```
And before the hook/task handling block. Add:
```python
    # Auto-reconciliation check (runs on every invocation, lightweight)
    maybe_auto_reconcile()
```

**Also update handle_reconcile():** After the engine.run() call and logging, add a call to record the manual run in the scheduler state too, so manual runs reset the timer:

After the existing `log_info` block in `handle_reconcile()` (around line 812), before the error check, add:
```python
        # Record run in scheduler state (resets auto-reconcile timer)
        from reconciliation.scheduler import ReconciliationScheduler
        scheduler = ReconciliationScheduler(data_dir)
        scheduler.record_run(result, scope=scope, is_startup=False)
```

**2. reconciliation/engine.py** -- Add support for "recent_7days" scope:

In the `_fetch_stash_scenes()` method, add a new scope branch. Currently it handles "recent" (24h) and "all". Add "recent_7days":

```python
if scope == "recent":
    yesterday = (datetime.now() - timedelta(days=1)).strftime("%Y-%m-%d %H:%M:%S")
    log_debug(f"Fetching scenes updated since {yesterday}")
    scenes = self.stash.find_scenes(
        f={"updated_at": {"value": yesterday, "modifier": "GREATER_THAN"}},
        fragment=fragment
    )
elif scope == "recent_7days":
    week_ago = (datetime.now() - timedelta(days=7)).strftime("%Y-%m-%d %H:%M:%S")
    log_debug(f"Fetching scenes updated since {week_ago}")
    scenes = self.stash.find_scenes(
        f={"updated_at": {"value": week_ago, "modifier": "GREATER_THAN"}},
        fragment=fragment
    )
else:  # "all"
    log_debug("Fetching all scenes")
    scenes = self.stash.find_scenes(fragment=fragment)
```

**3. Stash2Plex.py handle_queue_status()** -- Enhance with reconciliation info (RPT-01):

After the existing DLQ error breakdown section (around line 541), before the except block, add:

```python
        # Reconciliation status (RPT-01)
        try:
            from reconciliation.scheduler import ReconciliationScheduler
            scheduler = ReconciliationScheduler(data_dir)
            state = scheduler.load_state()

            log_info("=== Reconciliation Status ===")
            if state.last_run_time > 0:
                import datetime
                last_run_dt = datetime.datetime.fromtimestamp(state.last_run_time)
                log_info(f"Last run: {last_run_dt.strftime('%Y-%m-%d %H:%M:%S')}")
                log_info(f"Scope: {state.last_run_scope}")
                log_info(f"Scenes checked: {state.last_scenes_checked}")
                log_info(f"Gaps found: {state.last_gaps_found}")
                if state.last_gaps_by_type:
                    log_info(f"  Empty metadata: {state.last_gaps_by_type.get('empty_metadata', 0)}")
                    log_info(f"  Stale sync: {state.last_gaps_by_type.get('stale_sync', 0)}")
                    log_info(f"  Missing from Plex: {state.last_gaps_by_type.get('missing', 0)}")
                log_info(f"Enqueued: {state.last_enqueued}")
                if state.is_startup_run:
                    log_info("(Triggered by startup)")
                log_info(f"Total reconciliation runs: {state.run_count}")
            else:
                log_info("No reconciliation runs yet")
        except Exception as e:
            log_debug(f"Failed to load reconciliation status: {e}")
```

**4. Update Stash2Plex.yml task descriptions:** Update the two existing reconciliation task descriptions to mention the new scope options. Update "Reconcile Library (Recent)" description to: `"Detect and queue metadata gaps for scenes updated in the last 24 hours"` (no change needed, already correct).

Add a new task entry for 7-day reconciliation scope (AUTO-03):
```yaml
  - name: Reconcile Library (Last 7 Days)
    description: Detect and queue metadata gaps for scenes updated in the last 7 days
    defaultArgs:
      mode: reconcile_7days
```

**5. Stash2Plex.py** -- Add mode dispatch for `reconcile_7days`:

In `handle_task()`, add dispatch for the new mode alongside the existing reconcile modes:
```python
    elif mode == 'reconcile_7days':
        handle_reconcile('recent_7days')
        return
```

Also add `'reconcile_7days'` to the `management_modes` set in `main()`.
  </action>
  <verify>
```bash
# Check new function exists
grep -n "def maybe_auto_reconcile" Stash2Plex.py
grep -n "def _run_auto_reconcile" Stash2Plex.py
grep -n "maybe_auto_reconcile()" Stash2Plex.py

# Check enhanced queue status
grep -n "Reconciliation Status" Stash2Plex.py

# Check 7-day scope
grep -n "recent_7days" reconciliation/engine.py
grep -n "reconcile_7days" Stash2Plex.py Stash2Plex.yml

# Check management modes updated
grep -n "reconcile_7days" Stash2Plex.py

# Full test suite
python3 -m pytest --cov --cov-fail-under=80
```
  </verify>
  <done>
- maybe_auto_reconcile() is called on every plugin invocation (lightweight JSON check)
- Startup trigger runs recent-scope reconciliation if >1 hour since last run
- Interval trigger runs at configured interval with configured scope
- handle_reconcile() records manual runs (resets auto timer)
- handle_queue_status() shows last reconciliation run time, gaps found by type, enqueued count
- Engine supports "recent_7days" scope for 7-day window
- New "Reconcile Library (Last 7 Days)" task available in Stash UI
- All existing tests still pass with 80%+ coverage
  </done>
</task>

</tasks>

<verification>
1. Config validation:
```bash
python3 -c "
from validation.config import Stash2PlexConfig
# Valid intervals
for interval in ['never', 'hourly', 'daily', 'weekly']:
    c = Stash2PlexConfig(plex_url='http://localhost:32400', plex_token='abcdefghijk', reconcile_interval=interval)
    print(f'{interval}: OK')
# Valid scopes
for scope in ['all', '24h', '7days']:
    c = Stash2PlexConfig(plex_url='http://localhost:32400', plex_token='abcdefghijk', reconcile_scope=scope)
    print(f'{scope}: OK')
"
```

2. Scheduler state persistence:
```bash
python3 -c "
import tempfile, os
from reconciliation.scheduler import ReconciliationScheduler, ReconciliationState
tmpdir = tempfile.mkdtemp()
sched = ReconciliationScheduler(tmpdir)
state = sched.load_state()
print(f'Default state: last_run_time={state.last_run_time}')
assert state.last_run_time == 0.0
print('Scheduler state persistence: OK')
"
```

3. Full test suite passes:
```bash
python3 -m pytest --cov --cov-fail-under=80
```

4. YAML valid with new settings:
```bash
python3 -c "import yaml; d = yaml.safe_load(open('Stash2Plex.yml')); settings = d['settings']; assert 'reconcile_interval' in settings; assert 'reconcile_scope' in settings; print('YAML valid:', len(d['tasks']), 'tasks,', len(settings), 'settings')"
```
</verification>

<success_criteria>
- Plugin has reconcile_interval setting (never/hourly/daily/weekly, default: never)
- Plugin has reconcile_scope setting (all/24h/7days, default: 24h)
- ReconciliationScheduler persists state to reconciliation_state.json
- Auto-reconciliation checks on every invocation (lightweight)
- Startup trigger runs recent-scope if >1 hour since last run
- Interval trigger respects configured interval
- Manual reconciliation resets the auto timer
- "View Queue Status" displays last reconciliation run time, gaps found by type, enqueued count
- Engine supports "recent_7days" scope
- "Reconcile Library (Last 7 Days)" task available in Stash UI
- All tests pass with 80%+ coverage
</success_criteria>

<output>
After completion, create `.planning/phases/16-automated-reconciliation-reporting/16-01-SUMMARY.md`
</output>
