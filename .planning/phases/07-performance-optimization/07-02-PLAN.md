---
phase: 07-performance-optimization
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - plex/cache.py
  - plex/matcher.py
autonomous: true

must_haves:
  truths:
    - "Match results are cached and reused on subsequent lookups"
    - "Cached match returns Plex item without searching library"
    - "Failed match invalidates stale cache entry"
  artifacts:
    - path: "plex/cache.py"
      provides: "MatchCache class for path-to-item mappings"
      contains: "class MatchCache"
    - path: "plex/matcher.py"
      provides: "Cache-aware matching functions"
      contains: "PlexCache"
  key_links:
    - from: "plex/matcher.py"
      to: "plex/cache.py"
      via: "import and cache usage"
      pattern: "from plex.cache import"
---

<objective>
Add match result caching and integrate caching into the Plex matcher module.

Purpose: Cache file path to Plex item mappings so repeated syncs for the same file skip expensive library searches. This is the primary API call reduction mechanism.

Output: MatchCache class for path caching, and cache-integrated versions of find_plex_item_by_path and find_plex_items_with_confidence.
</objective>

<execution_context>
@/Users/trekkie/.claude/get-shit-done/workflows/execute-plan.md
@/Users/trekkie/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-performance-optimization/07-RESEARCH.md
@.planning/phases/07-performance-optimization/07-01-SUMMARY.md

# Files being modified
@plex/cache.py
@plex/matcher.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add MatchCache class for path-to-item caching</name>
  <files>plex/cache.py</files>
  <action>
Extend plex/cache.py to add MatchCache class for caching file path to Plex item key mappings.

Key differences from library cache:
- No TTL (matches are stable until library changes)
- Keys are f"match:{library_name}:{file_path}"
- Store only the Plex item key (string), not the full item
- Auto-invalidate on match failure (stale cache detection per RESEARCH.md)

Class structure:
```python
class MatchCache:
    """Cache for file path to Plex item key mappings."""

    def __init__(self, data_dir: str, size_limit: int = 50*1024*1024):
        """Initialize cache in data_dir/match_cache/ directory."""

    def get_match(self, library_name: str, file_path: str) -> Optional[str]:
        """Get cached Plex item key for file path."""

    def set_match(self, library_name: str, file_path: str, plex_key: str) -> None:
        """Cache path to Plex item key mapping (no TTL)."""

    def invalidate(self, library_name: str, file_path: str) -> None:
        """Invalidate a specific match (e.g., on PlexNotFound)."""

    def invalidate_library(self, library_name: str) -> None:
        """Invalidate all matches for a library (e.g., after library scan)."""

    def clear(self) -> None:
        """Clear all match cache data."""

    def get_stats(self) -> dict:
        """Get cache hit/miss statistics."""
```

Use lowercase file paths as keys for case-insensitive matching consistency with existing matcher logic.
  </action>
  <verify>
Run Python to verify:
```python
from plex.cache import MatchCache
import tempfile
mc = MatchCache(tempfile.mkdtemp())
mc.set_match("Movies", "/path/to/file.mp4", "/library/metadata/12345")
print(mc.get_match("Movies", "/path/to/file.mp4"))  # Should print the key
```
  </verify>
  <done>MatchCache class added to plex/cache.py with get/set/invalidate methods</done>
</task>

<task type="auto">
  <name>Task 2: Integrate caching into plex/matcher.py</name>
  <files>plex/matcher.py</files>
  <action>
Modify plex/matcher.py to use caching for both library data and match results.

Changes required:

1. Add optional cache parameters to matching functions:
```python
def find_plex_items_with_confidence(
    library: "LibrarySection",
    stash_path: str,
    plex_path_prefix: Optional[str] = None,
    stash_path_prefix: Optional[str] = None,
    library_cache: Optional["PlexCache"] = None,
    match_cache: Optional["MatchCache"] = None,
) -> tuple[MatchConfidence, Optional["Video"], list["Video"]]:
```

2. At start of function, check match_cache for existing match:
   - If cache hit and item still exists in Plex, return immediately (HIGH confidence)
   - If cache hit but item not found (stale), invalidate cache and continue

3. For library.search() calls, check library_cache first:
   - Cache key: f"search:{library.title}:{title}"
   - On cache hit, reconstruct minimal item data for matching

4. For library.all() fallback, check library_cache:
   - Cache key: f"all:{library.title}"
   - On cache hit, use cached item data for filename matching

5. After successful match, store in match_cache:
   - Key: file path (lowercased)
   - Value: Plex item key

6. On PlexNotFound, invalidate match_cache entry if one existed

IMPORTANT: The cache stores simplified dicts, but matching needs to return actual plexapi Video objects. When cache hit occurs for match_cache:
- Use the cached Plex item key to fetch the item directly via library.fetchItem(key)
- This is still faster than searching (1 API call vs N)
- If fetchItem fails, invalidate cache and fall back to search

For library_cache hits (search/all results):
- The cache contains file paths and keys
- Build a lookup dict from cached data for filename matching
- Once matched, fetch the actual item via library.fetchItem(key)
  </action>
  <verify>
The module should still work without caches (backward compatible):
```python
from plex.matcher import find_plex_items_with_confidence
# Should work without cache params (existing behavior)
```
  </verify>
  <done>plex/matcher.py uses optional caches for library data and match results</done>
</task>

<task type="auto">
  <name>Task 3: Add cache integration tests</name>
  <files>tests/test_cache.py</files>
  <action>
Extend tests/test_cache.py with tests for:

1. MatchCache basic operations (get/set/invalidate)
2. MatchCache library invalidation
3. MatchCache case-insensitive path handling
4. MatchCache statistics

Also add tests in tests/test_matcher.py (create if not exists):

1. find_plex_items_with_confidence with mock match_cache hit
2. find_plex_items_with_confidence with mock match_cache miss -> stores result
3. find_plex_items_with_confidence with stale cache -> invalidates and re-searches

Use mock objects for LibrarySection that return predictable items.
  </action>
  <verify>Run `pytest tests/test_cache.py tests/test_matcher.py -v` and all tests pass</verify>
  <done>Cache integration tests pass, covering cache hits, misses, and invalidation</done>
</task>

</tasks>

<verification>
1. `python -c "from plex.cache import MatchCache; print('OK')"` succeeds
2. `pytest tests/test_cache.py -v` all tests pass
3. `pytest tests/test_matcher.py -v` all tests pass (if exists)
4. Matcher functions work with and without cache parameters (backward compatible)
</verification>

<success_criteria>
- MatchCache class provides no-TTL caching for path-to-key mappings
- Matcher functions accept optional cache parameters
- Cache hits return results without full library search
- Stale cache entries are auto-invalidated on match failure
- All existing tests still pass (backward compatibility)
</success_criteria>

<output>
After completion, create `.planning/phases/07-performance-optimization/07-02-SUMMARY.md`
</output>
