---
phase: 03-integration-tests
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - requirements-dev.txt
  - tests/integration/__init__.py
  - tests/integration/conftest.py
autonomous: true

must_haves:
  truths:
    - "freezegun is available for time-controlled tests"
    - "pytest-timeout prevents hanging integration tests"
    - "Integration fixtures compose existing unit test fixtures into workflow scenarios"
    - "@pytest.mark.integration marker selects only integration tests"
  artifacts:
    - path: "requirements-dev.txt"
      provides: "freezegun and pytest-timeout dependencies"
      contains: "freezegun"
    - path: "tests/integration/__init__.py"
      provides: "Integration test package"
    - path: "tests/integration/conftest.py"
      provides: "Integration-specific fixtures"
      min_lines: 50
  key_links:
    - from: "tests/integration/conftest.py"
      to: "tests/conftest.py"
      via: "pytest fixture inheritance"
      pattern: "mock_queue|mock_plex_item|mock_config"
---

<objective>
Set up integration test infrastructure with freezegun for time control and workflow-level fixtures.

Purpose: Provide foundation for integration tests that exercise full sync workflows with mocked external services (Plex, Stash).
Output: tests/integration/ directory with fixtures that compose existing mocks into complete test scenarios.
</objective>

<execution_context>
@/Users/trekkie/.claude/get-shit-done/workflows/execute-plan.md
@/Users/trekkie/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-integration-tests/03-RESEARCH.md

# Existing test infrastructure to build on
@tests/conftest.py
@tests/test_retry_orchestration.py
@pytest.ini
@requirements-dev.txt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add test dependencies for time control and timeouts</name>
  <files>requirements-dev.txt</files>
  <action>
Add freezegun and pytest-timeout to requirements-dev.txt:

```
freezegun>=1.4.0
pytest-timeout>=2.3.0
```

freezegun provides time mocking for circuit breaker recovery tests and backoff delay tests.
pytest-timeout prevents integration tests from hanging if something goes wrong.

After updating, run `pip install -r requirements-dev.txt` to verify installation.
  </action>
  <verify>
Run: `pip install -r requirements-dev.txt`
Run: `python -c "import freezegun; print(freezegun.__version__)"`
Run: `python -c "import pytest_timeout; print('pytest-timeout installed')"`
  </verify>
  <done>
freezegun>=1.4.0 and pytest-timeout>=2.3.0 in requirements-dev.txt, both importable.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create integration test directory and fixtures</name>
  <files>tests/integration/__init__.py, tests/integration/conftest.py</files>
  <action>
Create tests/integration/ directory structure:

1. `tests/integration/__init__.py` - empty package marker

2. `tests/integration/conftest.py` - integration-specific fixtures that compose existing unit test fixtures:

```python
"""
Integration test fixtures for PlexSync.

These fixtures compose the unit test fixtures from tests/conftest.py
into complete workflow scenarios for testing:
- Full sync workflows
- Error scenarios
- Queue persistence
- Circuit breaker behavior

All integration tests should be marked with @pytest.mark.integration
"""

import pytest
from unittest.mock import Mock, MagicMock, patch
import time


# Integration fixtures inherit from tests/conftest.py automatically via pytest


@pytest.fixture
def integration_worker(mock_queue, mock_dlq, mock_config, mock_plex_item, tmp_path):
    """
    Complete SyncWorker with all dependencies mocked for integration testing.

    Provides:
        - worker: SyncWorker instance with mocked queue, DLQ, config
        - mock_plex_item: The mock Plex item that will be "found"
        - Plex client mocked to return mock_plex_item on search

    Usage:
        def test_sync_workflow(integration_worker):
            worker, plex_item = integration_worker
            # worker processes jobs, plex_item.edit() will be called
    """
    from worker.processor import SyncWorker

    worker = SyncWorker(
        queue=mock_queue,
        dlq=mock_dlq,
        config=mock_config,
        data_dir=str(tmp_path),
    )

    # Mock Plex client to return found item
    mock_section = MagicMock()
    mock_section.search.return_value = [mock_plex_item]
    mock_section.all.return_value = [mock_plex_item]
    mock_section.title = "Test Library"
    mock_section.type = "movie"

    mock_client = MagicMock()
    mock_client.server.library.sections.return_value = [mock_section]
    mock_client.server.library.section.return_value = mock_section
    worker._plex_client = mock_client

    return worker, mock_plex_item


@pytest.fixture
def integration_worker_no_match(mock_queue, mock_dlq, mock_config, tmp_path):
    """
    SyncWorker configured to return no Plex matches (PlexNotFound scenario).

    Usage:
        def test_not_found_scenario(integration_worker_no_match):
            worker = integration_worker_no_match
            # Processing will raise PlexNotFound
    """
    from worker.processor import SyncWorker

    worker = SyncWorker(
        queue=mock_queue,
        dlq=mock_dlq,
        config=mock_config,
        data_dir=str(tmp_path),
    )

    # Mock Plex client to return empty results
    mock_section = MagicMock()
    mock_section.search.return_value = []
    mock_section.all.return_value = []
    mock_section.title = "Test Library"

    mock_client = MagicMock()
    mock_client.server.library.sections.return_value = [mock_section]
    mock_client.server.library.section.return_value = mock_section
    worker._plex_client = mock_client

    return worker


@pytest.fixture
def integration_worker_connection_error(mock_queue, mock_dlq, mock_config, tmp_path):
    """
    SyncWorker configured to raise connection errors (Plex down scenario).

    Usage:
        def test_plex_down_scenario(integration_worker_connection_error):
            worker = integration_worker_connection_error
            # Processing will raise PlexTemporaryError
    """
    from worker.processor import SyncWorker

    worker = SyncWorker(
        queue=mock_queue,
        dlq=mock_dlq,
        config=mock_config,
        data_dir=str(tmp_path),
    )

    # Mock Plex client to raise connection error
    mock_client = MagicMock()
    mock_client.server.library.section.side_effect = ConnectionError("Connection refused")
    mock_client.server.library.sections.side_effect = ConnectionError("Connection refused")
    worker._plex_client = mock_client

    return worker


@pytest.fixture
def real_queue(tmp_path):
    """
    Real SQLiteAckQueue for testing persistence across restarts.

    Uses tmp_path to create isolated database per test.

    Usage:
        def test_queue_persistence(real_queue):
            real_queue.put({'scene_id': 123})
            # Simulate restart by creating new queue with same path
    """
    import persistqueue
    queue_path = str(tmp_path / "test_queue")
    return persistqueue.SQLiteAckQueue(queue_path, auto_resume=True)


@pytest.fixture
def sample_sync_job():
    """
    Complete sync job dictionary for integration tests.

    Contains all fields expected by SyncWorker._process_job().
    """
    return {
        'scene_id': 123,
        'update_type': 'metadata',
        'data': {
            'path': '/media/videos/test_scene.mp4',
            'title': 'Test Scene Title',
            'studio': 'Test Studio',
            'details': 'A test scene description.',
            'performers': ['Performer One', 'Performer Two'],
            'tags': ['Tag One', 'Tag Two'],
        },
        'enqueued_at': time.time(),
        'job_key': 'scene_123',
        'pqid': 1,
    }


@pytest.fixture
def fresh_circuit_breaker():
    """
    Fresh circuit breaker instance for each test.

    Prevents state leakage between tests.
    """
    from worker.circuit_breaker import CircuitBreaker
    return CircuitBreaker(
        failure_threshold=5,
        recovery_timeout=60.0,
        success_threshold=1
    )
```

Note: These fixtures build on the existing fixtures in tests/conftest.py (mock_queue, mock_dlq, mock_config, mock_plex_item, etc.) which are automatically available via pytest's fixture inheritance.
  </action>
  <verify>
Run: `pytest tests/integration/ --collect-only`
Should show the conftest.py fixtures are discovered without import errors.
  </verify>
  <done>
tests/integration/ directory exists with __init__.py and conftest.py.
Fixtures compose existing mocks into integration scenarios.
`pytest --collect-only tests/integration/` runs without errors.
  </done>
</task>

</tasks>

<verification>
```bash
# Verify dependencies installed
pip install -r requirements-dev.txt
python -c "import freezegun; import pytest_timeout; print('Dependencies OK')"

# Verify directory structure
ls -la tests/integration/

# Verify fixtures discoverable (no import errors)
pytest tests/integration/ --collect-only

# Verify integration marker recognized
pytest --markers | grep integration
```
</verification>

<success_criteria>
- freezegun>=1.4.0 and pytest-timeout>=2.3.0 in requirements-dev.txt
- tests/integration/ directory with __init__.py and conftest.py
- Integration fixtures (integration_worker, real_queue, etc.) discoverable
- No import errors when collecting integration tests
- @pytest.mark.integration marker available
</success_criteria>

<output>
After completion, create `.planning/phases/03-integration-tests/03-01-SUMMARY.md`
</output>
