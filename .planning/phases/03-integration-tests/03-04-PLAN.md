---
phase: 03-integration-tests
plan: 04
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - tests/integration/test_error_scenarios.py
autonomous: true

must_haves:
  truths:
    - "Connection errors translate to PlexTemporaryError and trigger retry"
    - "PlexNotFound triggers longer retry window (12 retries vs 5)"
    - "Permanent errors move jobs directly to DLQ without retry"
    - "Multiple matches in strict_matching mode raises PermanentError"
    - "Scene unmarked from pending on all error types"
  artifacts:
    - path: "tests/integration/test_error_scenarios.py"
      provides: "Error scenario tests for Plex down, Stash timeout"
      min_lines: 100
  key_links:
    - from: "tests/integration/test_error_scenarios.py"
      to: "plex/exceptions.py"
      via: "Exception translation"
      pattern: "PlexTemporaryError|PlexNotFound|PlexPermanentError"
    - from: "tests/integration/test_error_scenarios.py"
      to: "worker/processor.py"
      via: "Error handling in _process_job"
      pattern: "TransientError|PermanentError"
---

<objective>
Create integration tests for error scenarios and failure handling.

Purpose: Verify error conditions are handled as designed with correct retry behavior.
Output: test_error_scenarios.py covering Plex down, not found, permanent errors, and strict matching.
</objective>

<execution_context>
@/Users/trekkie/.claude/get-shit-done/workflows/execute-plan.md
@/Users/trekkie/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-integration-tests/03-RESEARCH.md

# Integration fixtures from Plan 01
@tests/integration/conftest.py

# Source modules being tested
@worker/processor.py
@plex/exceptions.py
@plex/matcher.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create error scenario integration tests</name>
  <files>tests/integration/test_error_scenarios.py</files>
  <action>
Create tests/integration/test_error_scenarios.py with tests for error handling:

```python
"""
Integration tests for error scenarios.

Tests verify error handling for:
- Plex server down (connection errors)
- Plex item not found
- Stash timeout
- Authentication failures
- Multiple matches (strict mode)
- Missing file path

Error classification is critical for retry behavior:
- TransientError/PlexTemporaryError: Retry with backoff
- PlexNotFound: Retry with longer window (library scanning)
- PermanentError/PlexPermanentError: Move to DLQ immediately
"""

import pytest
from unittest.mock import Mock, MagicMock, patch


@pytest.mark.integration
class TestPlexDownScenarios:
    """Tests for when Plex server is unavailable."""

    def test_connection_refused_raises_transient(self, integration_worker_connection_error):
        """Connection refused translates to TransientError for retry."""
        from worker.processor import TransientError
        from plex.exceptions import PlexTemporaryError

        worker = integration_worker_connection_error

        job = {
            'scene_id': 123,
            'update_type': 'metadata',
            'data': {'path': '/media/test.mp4'},
            'pqid': 1,
        }

        with pytest.raises((TransientError, PlexTemporaryError)):
            worker._process_job(job)

    def test_timeout_error_raises_transient(self, mock_queue, mock_dlq, mock_config, tmp_path):
        """Socket timeout translates to TransientError for retry."""
        from worker.processor import SyncWorker, TransientError
        from plex.exceptions import PlexTemporaryError
        import socket

        worker = SyncWorker(
            queue=mock_queue,
            dlq=mock_dlq,
            config=mock_config,
            data_dir=str(tmp_path),
        )

        # Mock Plex client to raise timeout
        mock_client = MagicMock()
        mock_client.server.library.section.side_effect = socket.timeout("timed out")
        worker._plex_client = mock_client

        job = {
            'scene_id': 123,
            'update_type': 'metadata',
            'data': {'path': '/media/test.mp4'},
            'pqid': 1,
        }

        with pytest.raises((TransientError, PlexTemporaryError)):
            worker._process_job(job)

    def test_http_500_raises_transient(self, mock_queue, mock_dlq, mock_config, tmp_path):
        """HTTP 500 error translates to TransientError for retry."""
        from worker.processor import SyncWorker, TransientError
        from plex.exceptions import PlexTemporaryError
        from urllib.error import HTTPError

        worker = SyncWorker(
            queue=mock_queue,
            dlq=mock_dlq,
            config=mock_config,
            data_dir=str(tmp_path),
        )

        # Mock Plex client to raise HTTP 500
        mock_client = MagicMock()
        mock_client.server.library.section.side_effect = HTTPError(
            url="http://plex:32400",
            code=500,
            msg="Internal Server Error",
            hdrs={},
            fp=None
        )
        worker._plex_client = mock_client

        job = {
            'scene_id': 123,
            'update_type': 'metadata',
            'data': {'path': '/media/test.mp4'},
            'pqid': 1,
        }

        with pytest.raises((TransientError, PlexTemporaryError)):
            worker._process_job(job)


@pytest.mark.integration
class TestPlexNotFoundScenarios:
    """Tests for when Plex item cannot be found."""

    def test_no_match_raises_plex_not_found(self, integration_worker_no_match):
        """No matching Plex item raises PlexNotFound for extended retry."""
        from plex.exceptions import PlexNotFound

        worker = integration_worker_no_match

        job = {
            'scene_id': 123,
            'update_type': 'metadata',
            'data': {'path': '/nonexistent/file.mp4'},
            'pqid': 1,
        }

        with pytest.raises(PlexNotFound):
            worker._process_job(job)

    def test_plex_not_found_gets_more_retries(self, integration_worker_no_match):
        """PlexNotFound gets 12 max retries (vs 5 for other transient)."""
        from plex.exceptions import PlexNotFound

        worker = integration_worker_no_match
        error = PlexNotFound("Item not found")

        max_retries = worker._get_max_retries_for_error(error)
        assert max_retries == 12

    def test_plex_not_found_gets_longer_base_delay(self):
        """PlexNotFound gets 30s base delay (vs 5s for other transient)."""
        from worker.backoff import get_retry_params
        from plex.exceptions import PlexNotFound, PlexTemporaryError

        base_nf, _, _ = get_retry_params(PlexNotFound("test"))
        base_temp, _, _ = get_retry_params(PlexTemporaryError("test"))

        assert base_nf == 30.0
        assert base_temp == 5.0
        assert base_nf > base_temp


@pytest.mark.integration
class TestPermanentErrorScenarios:
    """Tests for non-retryable permanent errors."""

    def test_missing_path_raises_permanent(self, integration_worker):
        """Job without file path raises PermanentError (no retry)."""
        from worker.processor import PermanentError

        worker, _ = integration_worker

        job = {
            'scene_id': 123,
            'update_type': 'metadata',
            'data': {},  # No path!
            'pqid': 1,
        }

        with pytest.raises(PermanentError, match="missing file path"):
            worker._process_job(job)

    def test_library_not_found_raises_permanent(self, mock_queue, mock_dlq, mock_config, tmp_path):
        """Configured library not existing raises PermanentError."""
        from worker.processor import SyncWorker, PermanentError

        mock_config.plex_library = "NonexistentLibrary"

        worker = SyncWorker(
            queue=mock_queue,
            dlq=mock_dlq,
            config=mock_config,
            data_dir=str(tmp_path),
        )

        # Mock client to raise on section lookup
        mock_client = MagicMock()
        mock_client.server.library.section.side_effect = Exception("Library not found")
        worker._plex_client = mock_client

        job = {
            'scene_id': 123,
            'update_type': 'metadata',
            'data': {'path': '/test.mp4'},
            'pqid': 1,
        }

        with pytest.raises(PermanentError, match="not found"):
            worker._process_job(job)

    def test_http_401_raises_permanent(self, mock_queue, mock_dlq, mock_config, tmp_path):
        """HTTP 401 Unauthorized raises PermanentError (no retry)."""
        from worker.processor import SyncWorker, PermanentError
        from plex.exceptions import PlexPermanentError
        from urllib.error import HTTPError

        worker = SyncWorker(
            queue=mock_queue,
            dlq=mock_dlq,
            config=mock_config,
            data_dir=str(tmp_path),
        )

        # Mock Plex client to raise HTTP 401
        mock_client = MagicMock()
        mock_client.server.library.section.side_effect = HTTPError(
            url="http://plex:32400",
            code=401,
            msg="Unauthorized",
            hdrs={},
            fp=None
        )
        worker._plex_client = mock_client

        job = {
            'scene_id': 123,
            'update_type': 'metadata',
            'data': {'path': '/test.mp4'},
            'pqid': 1,
        }

        with pytest.raises((PermanentError, PlexPermanentError)):
            worker._process_job(job)


@pytest.mark.integration
class TestStrictMatchingScenarios:
    """Tests for strict_matching configuration."""

    def test_multiple_matches_with_strict_raises_permanent(self, mock_queue, mock_dlq, mock_config, mock_plex_item, tmp_path):
        """Multiple Plex matches with strict_matching=True raises PermanentError."""
        from worker.processor import SyncWorker, PermanentError

        mock_config.strict_matching = True
        mock_config.plex_library = "Movies"

        worker = SyncWorker(
            queue=mock_queue,
            dlq=mock_dlq,
            config=mock_config,
            data_dir=str(tmp_path),
        )

        # Create two different mock items (multiple matches)
        mock_item1 = MagicMock()
        mock_item1.key = "/library/item/1"
        mock_item1.media = [MagicMock()]
        mock_item1.media[0].parts = [MagicMock()]
        mock_item1.media[0].parts[0].file = "/media/test1.mp4"

        mock_item2 = MagicMock()
        mock_item2.key = "/library/item/2"
        mock_item2.media = [MagicMock()]
        mock_item2.media[0].parts = [MagicMock()]
        mock_item2.media[0].parts[0].file = "/media/test2.mp4"

        mock_section = MagicMock()
        mock_section.search.return_value = [mock_item1, mock_item2]
        mock_section.title = "Movies"

        mock_client = MagicMock()
        mock_client.server.library.section.return_value = mock_section
        worker._plex_client = mock_client

        job = {
            'scene_id': 123,
            'update_type': 'metadata',
            'data': {'path': '/media/ambiguous.mp4'},
            'pqid': 1,
        }

        with pytest.raises(PermanentError, match="strict_matching"):
            worker._process_job(job)

    def test_multiple_matches_without_strict_uses_first(self, mock_queue, mock_dlq, mock_config, tmp_path):
        """Multiple Plex matches with strict_matching=False uses first match."""
        from worker.processor import SyncWorker

        mock_config.strict_matching = False
        mock_config.plex_library = "Movies"

        worker = SyncWorker(
            queue=mock_queue,
            dlq=mock_dlq,
            config=mock_config,
            data_dir=str(tmp_path),
        )

        # Create two different mock items
        mock_item1 = MagicMock()
        mock_item1.key = "/library/item/1"
        mock_item1.title = "First Match"
        mock_item1.media = [MagicMock()]
        mock_item1.media[0].parts = [MagicMock()]
        mock_item1.media[0].parts[0].file = "/media/test1.mp4"
        mock_item1.actors = []
        mock_item1.genres = []
        mock_item1.collections = []

        mock_item2 = MagicMock()
        mock_item2.key = "/library/item/2"

        mock_section = MagicMock()
        mock_section.search.return_value = [mock_item1, mock_item2]
        mock_section.title = "Movies"

        mock_client = MagicMock()
        mock_client.server.library.section.return_value = mock_section
        worker._plex_client = mock_client

        job = {
            'scene_id': 123,
            'update_type': 'metadata',
            'data': {'path': '/media/ambiguous.mp4', 'title': 'New Title'},
            'pqid': 1,
        }

        # Should not raise - uses first match
        worker._process_job(job)
        mock_item1.edit.assert_called()


@pytest.mark.integration
class TestSceneUnmarkedOnError:
    """Tests verifying scene is unmarked from pending on all outcomes."""

    def test_scene_unmarked_on_transient_error(self, integration_worker_connection_error):
        """Scene unmarked from pending even on transient error."""
        from plex.exceptions import PlexTemporaryError
        from worker.processor import TransientError

        worker = integration_worker_connection_error

        job = {
            'scene_id': 999,
            'update_type': 'metadata',
            'data': {'path': '/test.mp4'},
            'pqid': 1,
        }

        with patch('worker.processor.unmark_scene_pending') as mock_unmark:
            try:
                worker._process_job(job)
            except (TransientError, PlexTemporaryError):
                pass

            mock_unmark.assert_called_once_with(999)

    def test_scene_unmarked_on_not_found(self, integration_worker_no_match):
        """Scene unmarked from pending on PlexNotFound."""
        from plex.exceptions import PlexNotFound

        worker = integration_worker_no_match

        job = {
            'scene_id': 888,
            'update_type': 'metadata',
            'data': {'path': '/missing.mp4'},
            'pqid': 1,
        }

        with patch('worker.processor.unmark_scene_pending') as mock_unmark:
            try:
                worker._process_job(job)
            except PlexNotFound:
                pass

            mock_unmark.assert_called_once_with(888)
```

Test classes cover:
- Plex server unavailable (connection refused, timeout, HTTP 500)
- Plex item not found (with extended retry window verification)
- Permanent errors (missing path, library not found, HTTP 401)
- Strict matching mode with multiple candidates
- Scene unmarked from pending on all error types
  </action>
  <verify>
Run: `pytest tests/integration/test_error_scenarios.py -v`
All tests should pass.
  </verify>
  <done>
test_error_scenarios.py created with tests for:
- Plex down scenarios (connection, timeout, HTTP 500)
- PlexNotFound scenarios (extended retry window)
- Permanent error scenarios (missing path, 401, library not found)
- Strict matching mode
- Scene unmarked on all error types
All tests pass.
  </done>
</task>

</tasks>

<verification>
```bash
# Run all error scenario tests
pytest tests/integration/test_error_scenarios.py -v

# Run with integration marker only
pytest -m integration tests/integration/test_error_scenarios.py -v

# Check no regressions in existing tests
pytest tests/ -v --ignore=tests/integration/
```
</verification>

<success_criteria>
- test_error_scenarios.py passes all tests for error conditions
- Tests properly marked with @pytest.mark.integration
- Error classification matches design (transient vs permanent)
- No regressions in existing unit tests
</success_criteria>

<output>
After completion, create `.planning/phases/03-integration-tests/03-04-SUMMARY.md`
</output>
