---
phase: 03-integration-tests
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - tests/integration/test_full_sync_workflow.py
  - tests/integration/test_error_scenarios.py
autonomous: true

must_haves:
  truths:
    - "Full sync workflow processes job and updates Plex metadata"
    - "Connection errors translate to PlexTemporaryError and trigger retry"
    - "PlexNotFound triggers longer retry window (12 retries vs 5)"
    - "Permanent errors move jobs directly to DLQ without retry"
    - "Multiple matches in strict_matching mode raises PermanentError"
  artifacts:
    - path: "tests/integration/test_full_sync_workflow.py"
      provides: "End-to-end sync workflow tests"
      min_lines: 80
    - path: "tests/integration/test_error_scenarios.py"
      provides: "Error scenario tests for Plex down, Stash timeout"
      min_lines: 100
  key_links:
    - from: "tests/integration/test_full_sync_workflow.py"
      to: "worker/processor.py"
      via: "_process_job method"
      pattern: "_process_job"
    - from: "tests/integration/test_error_scenarios.py"
      to: "plex/exceptions.py"
      via: "Exception translation"
      pattern: "PlexTemporaryError|PlexNotFound|PlexPermanentError"
---

<objective>
Create integration tests for full sync workflows and error scenarios.

Purpose: Verify end-to-end sync flow works correctly, and error conditions are handled as designed.
Output: test_full_sync_workflow.py (happy path) and test_error_scenarios.py (failure handling).
</objective>

<execution_context>
@/Users/trekkie/.claude/get-shit-done/workflows/execute-plan.md
@/Users/trekkie/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-integration-tests/03-RESEARCH.md

# Integration fixtures from Plan 01
@tests/integration/conftest.py

# Source modules being tested
@worker/processor.py
@plex/exceptions.py
@plex/matcher.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create full sync workflow integration tests</name>
  <files>tests/integration/test_full_sync_workflow.py</files>
  <action>
Create tests/integration/test_full_sync_workflow.py with tests for the complete sync flow:

```python
"""
Integration tests for full sync workflow.

Tests verify end-to-end sync flow:
- Job processing updates Plex metadata correctly
- All metadata fields sync (title, studio, summary, performers, tags)
- Sync timestamp updated after successful sync
- Scene unmarked from pending after processing

These tests use mocked Plex/Stash but exercise the full code path
through SyncWorker._process_job().
"""

import pytest
import time
from unittest.mock import Mock, MagicMock, patch


@pytest.mark.integration
class TestFullSyncWorkflow:
    """Integration tests for complete sync flow."""

    def test_metadata_syncs_to_plex_item(self, integration_worker, sample_sync_job):
        """Job processing updates Plex item with all metadata fields."""
        worker, mock_plex_item = integration_worker

        # Process the job
        worker._process_job(sample_sync_job)

        # Verify edit was called with expected fields
        mock_plex_item.edit.assert_called()
        call_kwargs = mock_plex_item.edit.call_args.kwargs
        assert 'title.value' in call_kwargs or 'summary.value' in call_kwargs

    def test_title_synced_to_plex(self, integration_worker, sample_sync_job):
        """Title field syncs from Stash to Plex."""
        worker, mock_plex_item = integration_worker
        sample_sync_job['data']['title'] = 'New Test Title'

        worker._process_job(sample_sync_job)

        mock_plex_item.edit.assert_called()
        call_kwargs = mock_plex_item.edit.call_args.kwargs
        assert call_kwargs.get('title.value') == 'New Test Title'

    def test_studio_synced_to_plex(self, integration_worker, sample_sync_job):
        """Studio field syncs from Stash to Plex."""
        worker, mock_plex_item = integration_worker
        sample_sync_job['data']['studio'] = 'New Studio Name'

        worker._process_job(sample_sync_job)

        # Studio might be in first or second edit call (metadata vs collection)
        assert mock_plex_item.edit.called

    def test_summary_synced_from_details(self, integration_worker, sample_sync_job):
        """Stash 'details' field syncs to Plex 'summary'."""
        worker, mock_plex_item = integration_worker
        sample_sync_job['data']['details'] = 'This is a detailed description.'

        worker._process_job(sample_sync_job)

        mock_plex_item.edit.assert_called()
        call_kwargs = mock_plex_item.edit.call_args.kwargs
        assert call_kwargs.get('summary.value') == 'This is a detailed description.'

    def test_performers_synced_as_actors(self, integration_worker, sample_sync_job):
        """Performers sync to Plex as actors."""
        worker, mock_plex_item = integration_worker
        mock_plex_item.actors = []  # No existing actors
        sample_sync_job['data']['performers'] = ['Jane Doe', 'John Smith']

        worker._process_job(sample_sync_job)

        # Edit should be called at least twice (metadata + actors)
        assert mock_plex_item.edit.call_count >= 1

    def test_tags_synced_as_genres(self, integration_worker, sample_sync_job):
        """Tags sync to Plex as genres."""
        worker, mock_plex_item = integration_worker
        mock_plex_item.genres = []  # No existing genres
        sample_sync_job['data']['tags'] = ['HD', 'Interview']

        worker._process_job(sample_sync_job)

        # Edit should include genre tags
        assert mock_plex_item.edit.called

    def test_plex_item_reloaded_after_edit(self, integration_worker, sample_sync_job):
        """Plex item.reload() called after edit to confirm changes."""
        worker, mock_plex_item = integration_worker

        worker._process_job(sample_sync_job)

        mock_plex_item.reload.assert_called()

    def test_sync_timestamp_saved_after_success(self, integration_worker, sample_sync_job, tmp_path):
        """Sync timestamp saved to data_dir after successful sync."""
        worker, mock_plex_item = integration_worker
        # Worker already has tmp_path as data_dir from fixture

        with patch('worker.processor.save_sync_timestamp') as mock_save:
            worker._process_job(sample_sync_job)

            mock_save.assert_called_once()
            args = mock_save.call_args[0]
            assert args[1] == sample_sync_job['scene_id']  # scene_id
            assert isinstance(args[2], float)  # timestamp

    def test_scene_unmarked_pending_after_processing(self, integration_worker, sample_sync_job):
        """Scene removed from pending set after processing."""
        worker, mock_plex_item = integration_worker

        with patch('worker.processor.unmark_scene_pending') as mock_unmark:
            worker._process_job(sample_sync_job)

            mock_unmark.assert_called_once_with(sample_sync_job['scene_id'])


@pytest.mark.integration
class TestPreservePlexEditsMode:
    """Tests for preserve_plex_edits configuration."""

    def test_preserve_mode_skips_existing_title(self, integration_worker, sample_sync_job):
        """preserve_plex_edits=True skips fields that already have values."""
        worker, mock_plex_item = integration_worker
        worker.config.preserve_plex_edits = True
        mock_plex_item.title = "Existing Title"  # Already has a title

        worker._process_job(sample_sync_job)

        # Edit should not include title.value since Plex already has one
        if mock_plex_item.edit.called:
            call_kwargs = mock_plex_item.edit.call_args.kwargs
            assert 'title.value' not in call_kwargs

    def test_overwrite_mode_replaces_existing_title(self, integration_worker, sample_sync_job):
        """preserve_plex_edits=False overwrites existing Plex values."""
        worker, mock_plex_item = integration_worker
        worker.config.preserve_plex_edits = False
        mock_plex_item.title = "Existing Title"
        sample_sync_job['data']['title'] = 'New Title From Stash'

        worker._process_job(sample_sync_job)

        mock_plex_item.edit.assert_called()
        call_kwargs = mock_plex_item.edit.call_args.kwargs
        assert call_kwargs.get('title.value') == 'New Title From Stash'


@pytest.mark.integration
class TestJobWithMissingFields:
    """Tests for jobs with missing or partial data."""

    def test_job_without_title_still_syncs_other_fields(self, integration_worker):
        """Job missing title can still sync studio, summary, etc."""
        worker, mock_plex_item = integration_worker

        job = {
            'scene_id': 456,
            'update_type': 'metadata',
            'data': {
                'path': '/media/test.mp4',
                'studio': 'Some Studio',
                'details': 'Description only',
                # No title field
            },
            'pqid': 1,
        }

        # Should not raise
        worker._process_job(job)
        assert mock_plex_item.edit.called

    def test_job_with_only_path_processes_without_error(self, integration_worker):
        """Job with only path field processes (finds item, no metadata to sync)."""
        worker, mock_plex_item = integration_worker

        job = {
            'scene_id': 789,
            'update_type': 'metadata',
            'data': {
                'path': '/media/test.mp4',
                # No metadata fields
            },
            'pqid': 1,
        }

        # Should not raise - item found, just no edits
        worker._process_job(job)
```

Note: Tests use the integration_worker and sample_sync_job fixtures from conftest.py.
Mark all test classes with @pytest.mark.integration.
  </action>
  <verify>
Run: `pytest tests/integration/test_full_sync_workflow.py -v`
All tests should pass.
  </verify>
  <done>
test_full_sync_workflow.py created with tests for:
- Complete metadata sync (title, studio, summary, performers, tags)
- Plex item reload after edit
- Sync timestamp saved
- Scene unmarked from pending
- preserve_plex_edits mode
- Jobs with missing/partial fields
All tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create error scenario integration tests</name>
  <files>tests/integration/test_error_scenarios.py</files>
  <action>
Create tests/integration/test_error_scenarios.py with tests for error handling:

```python
"""
Integration tests for error scenarios.

Tests verify error handling for:
- Plex server down (connection errors)
- Plex item not found
- Stash timeout
- Authentication failures
- Multiple matches (strict mode)
- Missing file path

Error classification is critical for retry behavior:
- TransientError/PlexTemporaryError: Retry with backoff
- PlexNotFound: Retry with longer window (library scanning)
- PermanentError/PlexPermanentError: Move to DLQ immediately
"""

import pytest
from unittest.mock import Mock, MagicMock, patch


@pytest.mark.integration
class TestPlexDownScenarios:
    """Tests for when Plex server is unavailable."""

    def test_connection_refused_raises_transient(self, integration_worker_connection_error):
        """Connection refused translates to TransientError for retry."""
        from worker.processor import TransientError
        from plex.exceptions import PlexTemporaryError

        worker = integration_worker_connection_error

        job = {
            'scene_id': 123,
            'update_type': 'metadata',
            'data': {'path': '/media/test.mp4'},
            'pqid': 1,
        }

        with pytest.raises((TransientError, PlexTemporaryError)):
            worker._process_job(job)

    def test_timeout_error_raises_transient(self, mock_queue, mock_dlq, mock_config, tmp_path):
        """Socket timeout translates to TransientError for retry."""
        from worker.processor import SyncWorker, TransientError
        from plex.exceptions import PlexTemporaryError
        import socket

        worker = SyncWorker(
            queue=mock_queue,
            dlq=mock_dlq,
            config=mock_config,
            data_dir=str(tmp_path),
        )

        # Mock Plex client to raise timeout
        mock_client = MagicMock()
        mock_client.server.library.section.side_effect = socket.timeout("timed out")
        worker._plex_client = mock_client

        job = {
            'scene_id': 123,
            'update_type': 'metadata',
            'data': {'path': '/media/test.mp4'},
            'pqid': 1,
        }

        with pytest.raises((TransientError, PlexTemporaryError)):
            worker._process_job(job)

    def test_http_500_raises_transient(self, mock_queue, mock_dlq, mock_config, tmp_path):
        """HTTP 500 error translates to TransientError for retry."""
        from worker.processor import SyncWorker, TransientError
        from plex.exceptions import PlexTemporaryError
        from urllib.error import HTTPError

        worker = SyncWorker(
            queue=mock_queue,
            dlq=mock_dlq,
            config=mock_config,
            data_dir=str(tmp_path),
        )

        # Mock Plex client to raise HTTP 500
        mock_client = MagicMock()
        mock_client.server.library.section.side_effect = HTTPError(
            url="http://plex:32400",
            code=500,
            msg="Internal Server Error",
            hdrs={},
            fp=None
        )
        worker._plex_client = mock_client

        job = {
            'scene_id': 123,
            'update_type': 'metadata',
            'data': {'path': '/media/test.mp4'},
            'pqid': 1,
        }

        with pytest.raises((TransientError, PlexTemporaryError)):
            worker._process_job(job)


@pytest.mark.integration
class TestPlexNotFoundScenarios:
    """Tests for when Plex item cannot be found."""

    def test_no_match_raises_plex_not_found(self, integration_worker_no_match):
        """No matching Plex item raises PlexNotFound for extended retry."""
        from plex.exceptions import PlexNotFound

        worker = integration_worker_no_match

        job = {
            'scene_id': 123,
            'update_type': 'metadata',
            'data': {'path': '/nonexistent/file.mp4'},
            'pqid': 1,
        }

        with pytest.raises(PlexNotFound):
            worker._process_job(job)

    def test_plex_not_found_gets_more_retries(self, integration_worker_no_match):
        """PlexNotFound gets 12 max retries (vs 5 for other transient)."""
        from plex.exceptions import PlexNotFound

        worker = integration_worker_no_match
        error = PlexNotFound("Item not found")

        max_retries = worker._get_max_retries_for_error(error)
        assert max_retries == 12

    def test_plex_not_found_gets_longer_base_delay(self):
        """PlexNotFound gets 30s base delay (vs 5s for other transient)."""
        from worker.backoff import get_retry_params
        from plex.exceptions import PlexNotFound, PlexTemporaryError

        base_nf, _, _ = get_retry_params(PlexNotFound("test"))
        base_temp, _, _ = get_retry_params(PlexTemporaryError("test"))

        assert base_nf == 30.0
        assert base_temp == 5.0
        assert base_nf > base_temp


@pytest.mark.integration
class TestPermanentErrorScenarios:
    """Tests for non-retryable permanent errors."""

    def test_missing_path_raises_permanent(self, integration_worker):
        """Job without file path raises PermanentError (no retry)."""
        from worker.processor import PermanentError

        worker, _ = integration_worker

        job = {
            'scene_id': 123,
            'update_type': 'metadata',
            'data': {},  # No path!
            'pqid': 1,
        }

        with pytest.raises(PermanentError, match="missing file path"):
            worker._process_job(job)

    def test_library_not_found_raises_permanent(self, mock_queue, mock_dlq, mock_config, tmp_path):
        """Configured library not existing raises PermanentError."""
        from worker.processor import SyncWorker, PermanentError

        mock_config.plex_library = "NonexistentLibrary"

        worker = SyncWorker(
            queue=mock_queue,
            dlq=mock_dlq,
            config=mock_config,
            data_dir=str(tmp_path),
        )

        # Mock client to raise on section lookup
        mock_client = MagicMock()
        mock_client.server.library.section.side_effect = Exception("Library not found")
        worker._plex_client = mock_client

        job = {
            'scene_id': 123,
            'update_type': 'metadata',
            'data': {'path': '/test.mp4'},
            'pqid': 1,
        }

        with pytest.raises(PermanentError, match="not found"):
            worker._process_job(job)

    def test_http_401_raises_permanent(self, mock_queue, mock_dlq, mock_config, tmp_path):
        """HTTP 401 Unauthorized raises PermanentError (no retry)."""
        from worker.processor import SyncWorker, PermanentError
        from plex.exceptions import PlexPermanentError
        from urllib.error import HTTPError

        worker = SyncWorker(
            queue=mock_queue,
            dlq=mock_dlq,
            config=mock_config,
            data_dir=str(tmp_path),
        )

        # Mock Plex client to raise HTTP 401
        mock_client = MagicMock()
        mock_client.server.library.section.side_effect = HTTPError(
            url="http://plex:32400",
            code=401,
            msg="Unauthorized",
            hdrs={},
            fp=None
        )
        worker._plex_client = mock_client

        job = {
            'scene_id': 123,
            'update_type': 'metadata',
            'data': {'path': '/test.mp4'},
            'pqid': 1,
        }

        with pytest.raises((PermanentError, PlexPermanentError)):
            worker._process_job(job)


@pytest.mark.integration
class TestStrictMatchingScenarios:
    """Tests for strict_matching configuration."""

    def test_multiple_matches_with_strict_raises_permanent(self, mock_queue, mock_dlq, mock_config, mock_plex_item, tmp_path):
        """Multiple Plex matches with strict_matching=True raises PermanentError."""
        from worker.processor import SyncWorker, PermanentError

        mock_config.strict_matching = True
        mock_config.plex_library = "Movies"

        worker = SyncWorker(
            queue=mock_queue,
            dlq=mock_dlq,
            config=mock_config,
            data_dir=str(tmp_path),
        )

        # Create two different mock items (multiple matches)
        mock_item1 = MagicMock()
        mock_item1.key = "/library/item/1"
        mock_item1.media = [MagicMock()]
        mock_item1.media[0].parts = [MagicMock()]
        mock_item1.media[0].parts[0].file = "/media/test1.mp4"

        mock_item2 = MagicMock()
        mock_item2.key = "/library/item/2"
        mock_item2.media = [MagicMock()]
        mock_item2.media[0].parts = [MagicMock()]
        mock_item2.media[0].parts[0].file = "/media/test2.mp4"

        mock_section = MagicMock()
        mock_section.search.return_value = [mock_item1, mock_item2]
        mock_section.title = "Movies"

        mock_client = MagicMock()
        mock_client.server.library.section.return_value = mock_section
        worker._plex_client = mock_client

        job = {
            'scene_id': 123,
            'update_type': 'metadata',
            'data': {'path': '/media/ambiguous.mp4'},
            'pqid': 1,
        }

        with pytest.raises(PermanentError, match="strict_matching"):
            worker._process_job(job)

    def test_multiple_matches_without_strict_uses_first(self, mock_queue, mock_dlq, mock_config, tmp_path):
        """Multiple Plex matches with strict_matching=False uses first match."""
        from worker.processor import SyncWorker

        mock_config.strict_matching = False
        mock_config.plex_library = "Movies"

        worker = SyncWorker(
            queue=mock_queue,
            dlq=mock_dlq,
            config=mock_config,
            data_dir=str(tmp_path),
        )

        # Create two different mock items
        mock_item1 = MagicMock()
        mock_item1.key = "/library/item/1"
        mock_item1.title = "First Match"
        mock_item1.media = [MagicMock()]
        mock_item1.media[0].parts = [MagicMock()]
        mock_item1.media[0].parts[0].file = "/media/test1.mp4"
        mock_item1.actors = []
        mock_item1.genres = []
        mock_item1.collections = []

        mock_item2 = MagicMock()
        mock_item2.key = "/library/item/2"

        mock_section = MagicMock()
        mock_section.search.return_value = [mock_item1, mock_item2]
        mock_section.title = "Movies"

        mock_client = MagicMock()
        mock_client.server.library.section.return_value = mock_section
        worker._plex_client = mock_client

        job = {
            'scene_id': 123,
            'update_type': 'metadata',
            'data': {'path': '/media/ambiguous.mp4', 'title': 'New Title'},
            'pqid': 1,
        }

        # Should not raise - uses first match
        worker._process_job(job)
        mock_item1.edit.assert_called()


@pytest.mark.integration
class TestSceneUnmarkedOnError:
    """Tests verifying scene is unmarked from pending on all outcomes."""

    def test_scene_unmarked_on_transient_error(self, integration_worker_connection_error):
        """Scene unmarked from pending even on transient error."""
        from plex.exceptions import PlexTemporaryError
        from worker.processor import TransientError

        worker = integration_worker_connection_error

        job = {
            'scene_id': 999,
            'update_type': 'metadata',
            'data': {'path': '/test.mp4'},
            'pqid': 1,
        }

        with patch('worker.processor.unmark_scene_pending') as mock_unmark:
            try:
                worker._process_job(job)
            except (TransientError, PlexTemporaryError):
                pass

            mock_unmark.assert_called_once_with(999)

    def test_scene_unmarked_on_not_found(self, integration_worker_no_match):
        """Scene unmarked from pending on PlexNotFound."""
        from plex.exceptions import PlexNotFound

        worker = integration_worker_no_match

        job = {
            'scene_id': 888,
            'update_type': 'metadata',
            'data': {'path': '/missing.mp4'},
            'pqid': 1,
        }

        with patch('worker.processor.unmark_scene_pending') as mock_unmark:
            try:
                worker._process_job(job)
            except PlexNotFound:
                pass

            mock_unmark.assert_called_once_with(888)
```

Test classes cover:
- Plex server unavailable (connection refused, timeout, HTTP 500)
- Plex item not found (with extended retry window verification)
- Permanent errors (missing path, library not found, HTTP 401)
- Strict matching mode with multiple candidates
- Scene unmarked from pending on all error types
  </action>
  <verify>
Run: `pytest tests/integration/test_error_scenarios.py -v`
All tests should pass.
  </verify>
  <done>
test_error_scenarios.py created with tests for:
- Plex down scenarios (connection, timeout, HTTP 500)
- PlexNotFound scenarios (extended retry window)
- Permanent error scenarios (missing path, 401, library not found)
- Strict matching mode
- Scene unmarked on all error types
All tests pass.
  </done>
</task>

</tasks>

<verification>
```bash
# Run all workflow tests
pytest tests/integration/test_full_sync_workflow.py -v

# Run all error scenario tests
pytest tests/integration/test_error_scenarios.py -v

# Run with integration marker only
pytest -m integration tests/integration/ -v

# Check no regressions in existing tests
pytest tests/ -v --ignore=tests/integration/
```
</verification>

<success_criteria>
- test_full_sync_workflow.py passes all tests for happy path sync
- test_error_scenarios.py passes all tests for error conditions
- Tests properly marked with @pytest.mark.integration
- Error classification matches design (transient vs permanent)
- No regressions in existing unit tests
</success_criteria>

<output>
After completion, create `.planning/phases/03-integration-tests/03-02-SUMMARY.md`
</output>
