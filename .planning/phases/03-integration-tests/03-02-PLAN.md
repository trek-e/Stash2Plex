---
phase: 03-integration-tests
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - tests/integration/test_full_sync_workflow.py
autonomous: true

must_haves:
  truths:
    - "Full sync workflow processes job and updates Plex metadata"
    - "Plex item returned by fixture mock is the same item that gets edited"
    - "All metadata fields sync (title, studio, summary, performers, tags)"
    - "Sync timestamp updated after successful sync"
  artifacts:
    - path: "tests/integration/test_full_sync_workflow.py"
      provides: "End-to-end sync workflow tests"
      min_lines: 80
  key_links:
    - from: "tests/integration/test_full_sync_workflow.py"
      to: "tests/integration/conftest.py"
      via: "integration_worker fixture returns (worker, mock_plex_item) tuple"
      pattern: "worker, mock_plex_item = integration_worker"
    - from: "tests/integration/test_full_sync_workflow.py"
      to: "worker/processor.py"
      via: "_process_job method"
      pattern: "_process_job"
---

<objective>
Create integration tests for full sync workflow happy paths.

Purpose: Verify end-to-end sync flow works correctly with all metadata fields.
Output: test_full_sync_workflow.py covering metadata sync, preserve_plex_edits mode, and partial data handling.
</objective>

<execution_context>
@/Users/trekkie/.claude/get-shit-done/workflows/execute-plan.md
@/Users/trekkie/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-integration-tests/03-RESEARCH.md

# Integration fixtures from Plan 01
@tests/integration/conftest.py

# Source modules being tested
@worker/processor.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create full sync workflow integration tests</name>
  <files>tests/integration/test_full_sync_workflow.py</files>
  <action>
Create tests/integration/test_full_sync_workflow.py with tests for the complete sync flow:

```python
"""
Integration tests for full sync workflow.

Tests verify end-to-end sync flow:
- Job processing updates Plex metadata correctly
- All metadata fields sync (title, studio, summary, performers, tags)
- Sync timestamp updated after successful sync
- Scene unmarked from pending after processing

These tests use mocked Plex/Stash but exercise the full code path
through SyncWorker._process_job().

CRITICAL WIRING: The integration_worker fixture returns (worker, mock_plex_item).
The worker's Plex client is wired to return mock_plex_item on search.
When tests call worker._process_job(), the worker finds mock_plex_item
and calls mock_plex_item.edit(). Tests verify this by checking
mock_plex_item.edit.assert_called() - confirming the fixture wiring works.
"""

import pytest
import time
from unittest.mock import Mock, MagicMock, patch


@pytest.mark.integration
class TestFullSyncWorkflow:
    """Integration tests for complete sync flow."""

    def test_metadata_syncs_to_plex_item(self, integration_worker, sample_sync_job):
        """Job processing updates Plex item with all metadata fields.

        Verifies critical wiring: mock_plex_item.edit() is called,
        confirming the fixture's Plex client mock returns the correct
        item and worker processes it through _process_job().
        """
        worker, mock_plex_item = integration_worker

        # Process the job
        worker._process_job(sample_sync_job)

        # CRITICAL: Verify mock_plex_item.edit() is called.
        # This confirms the integration_worker fixture wiring works:
        # worker._plex_client.server.library.section().search() returns [mock_plex_item]
        # worker finds this item and calls mock_plex_item.edit()
        mock_plex_item.edit.assert_called()
        call_kwargs = mock_plex_item.edit.call_args.kwargs
        assert 'title.value' in call_kwargs or 'summary.value' in call_kwargs

    def test_title_synced_to_plex(self, integration_worker, sample_sync_job):
        """Title field syncs from Stash to Plex."""
        worker, mock_plex_item = integration_worker
        sample_sync_job['data']['title'] = 'New Test Title'

        worker._process_job(sample_sync_job)

        # Verify mock_plex_item (from fixture) receives the edit call
        mock_plex_item.edit.assert_called()
        call_kwargs = mock_plex_item.edit.call_args.kwargs
        assert call_kwargs.get('title.value') == 'New Test Title'

    def test_studio_synced_to_plex(self, integration_worker, sample_sync_job):
        """Studio field syncs from Stash to Plex."""
        worker, mock_plex_item = integration_worker
        sample_sync_job['data']['studio'] = 'New Studio Name'

        worker._process_job(sample_sync_job)

        # Studio might be in first or second edit call (metadata vs collection)
        assert mock_plex_item.edit.called

    def test_summary_synced_from_details(self, integration_worker, sample_sync_job):
        """Stash 'details' field syncs to Plex 'summary'."""
        worker, mock_plex_item = integration_worker
        sample_sync_job['data']['details'] = 'This is a detailed description.'

        worker._process_job(sample_sync_job)

        mock_plex_item.edit.assert_called()
        call_kwargs = mock_plex_item.edit.call_args.kwargs
        assert call_kwargs.get('summary.value') == 'This is a detailed description.'

    def test_performers_synced_as_actors(self, integration_worker, sample_sync_job):
        """Performers sync to Plex as actors."""
        worker, mock_plex_item = integration_worker
        mock_plex_item.actors = []  # No existing actors
        sample_sync_job['data']['performers'] = ['Jane Doe', 'John Smith']

        worker._process_job(sample_sync_job)

        # Edit should be called at least twice (metadata + actors)
        assert mock_plex_item.edit.call_count >= 1

    def test_tags_synced_as_genres(self, integration_worker, sample_sync_job):
        """Tags sync to Plex as genres."""
        worker, mock_plex_item = integration_worker
        mock_plex_item.genres = []  # No existing genres
        sample_sync_job['data']['tags'] = ['HD', 'Interview']

        worker._process_job(sample_sync_job)

        # Edit should include genre tags
        assert mock_plex_item.edit.called

    def test_plex_item_reloaded_after_edit(self, integration_worker, sample_sync_job):
        """Plex item.reload() called after edit to confirm changes."""
        worker, mock_plex_item = integration_worker

        worker._process_job(sample_sync_job)

        mock_plex_item.reload.assert_called()

    def test_sync_timestamp_saved_after_success(self, integration_worker, sample_sync_job, tmp_path):
        """Sync timestamp saved to data_dir after successful sync."""
        worker, mock_plex_item = integration_worker
        # Worker already has tmp_path as data_dir from fixture

        with patch('worker.processor.save_sync_timestamp') as mock_save:
            worker._process_job(sample_sync_job)

            mock_save.assert_called_once()
            args = mock_save.call_args[0]
            assert args[1] == sample_sync_job['scene_id']  # scene_id
            assert isinstance(args[2], float)  # timestamp

    def test_scene_unmarked_pending_after_processing(self, integration_worker, sample_sync_job):
        """Scene removed from pending set after processing."""
        worker, mock_plex_item = integration_worker

        with patch('worker.processor.unmark_scene_pending') as mock_unmark:
            worker._process_job(sample_sync_job)

            mock_unmark.assert_called_once_with(sample_sync_job['scene_id'])


@pytest.mark.integration
class TestPreservePlexEditsMode:
    """Tests for preserve_plex_edits configuration."""

    def test_preserve_mode_skips_existing_title(self, integration_worker, sample_sync_job):
        """preserve_plex_edits=True skips fields that already have values."""
        worker, mock_plex_item = integration_worker
        worker.config.preserve_plex_edits = True
        mock_plex_item.title = "Existing Title"  # Already has a title

        worker._process_job(sample_sync_job)

        # Edit should not include title.value since Plex already has one
        if mock_plex_item.edit.called:
            call_kwargs = mock_plex_item.edit.call_args.kwargs
            assert 'title.value' not in call_kwargs

    def test_overwrite_mode_replaces_existing_title(self, integration_worker, sample_sync_job):
        """preserve_plex_edits=False overwrites existing Plex values."""
        worker, mock_plex_item = integration_worker
        worker.config.preserve_plex_edits = False
        mock_plex_item.title = "Existing Title"
        sample_sync_job['data']['title'] = 'New Title From Stash'

        worker._process_job(sample_sync_job)

        mock_plex_item.edit.assert_called()
        call_kwargs = mock_plex_item.edit.call_args.kwargs
        assert call_kwargs.get('title.value') == 'New Title From Stash'


@pytest.mark.integration
class TestJobWithMissingFields:
    """Tests for jobs with missing or partial data."""

    def test_job_without_title_still_syncs_other_fields(self, integration_worker):
        """Job missing title can still sync studio, summary, etc."""
        worker, mock_plex_item = integration_worker

        job = {
            'scene_id': 456,
            'update_type': 'metadata',
            'data': {
                'path': '/media/test.mp4',
                'studio': 'Some Studio',
                'details': 'Description only',
                # No title field
            },
            'pqid': 1,
        }

        # Should not raise
        worker._process_job(job)
        assert mock_plex_item.edit.called

    def test_job_with_only_path_processes_without_error(self, integration_worker):
        """Job with only path field processes (finds item, no metadata to sync)."""
        worker, mock_plex_item = integration_worker

        job = {
            'scene_id': 789,
            'update_type': 'metadata',
            'data': {
                'path': '/media/test.mp4',
                # No metadata fields
            },
            'pqid': 1,
        }

        # Should not raise - item found, just no edits
        worker._process_job(job)
```

Note: Tests use the integration_worker and sample_sync_job fixtures from conftest.py.
Mark all test classes with @pytest.mark.integration.

CRITICAL WIRING VERIFICATION: The first test (test_metadata_syncs_to_plex_item) includes
explicit documentation that mock_plex_item.edit() being called confirms the fixture's
Plex client mock correctly returns mock_plex_item, and the worker processes it.
  </action>
  <verify>
Run: `pytest tests/integration/test_full_sync_workflow.py -v`
All tests should pass.
  </verify>
  <done>
test_full_sync_workflow.py created with tests for:
- Complete metadata sync (title, studio, summary, performers, tags)
- Explicit verification that mock_plex_item from fixture is the item that gets edited
- Plex item reload after edit
- Sync timestamp saved
- Scene unmarked from pending
- preserve_plex_edits mode
- Jobs with missing/partial fields
All tests pass.
  </done>
</task>

</tasks>

<verification>
```bash
# Run all workflow tests
pytest tests/integration/test_full_sync_workflow.py -v

# Run with integration marker only
pytest -m integration tests/integration/test_full_sync_workflow.py -v

# Check no regressions in existing tests
pytest tests/ -v --ignore=tests/integration/
```
</verification>

<success_criteria>
- test_full_sync_workflow.py passes all tests for happy path sync
- Tests properly marked with @pytest.mark.integration
- Explicit verification that fixture's mock_plex_item is the item receiving edit calls
- No regressions in existing unit tests
</success_criteria>

<output>
After completion, create `.planning/phases/03-integration-tests/03-02-SUMMARY.md`
</output>
