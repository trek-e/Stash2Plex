---
phase: 24-provider-http-skeleton
plan: 02
type: execute
wave: 2
depends_on: [24-01]
files_modified:
  - Dockerfile
  - docker-compose.yml
  - .dockerignore
autonomous: true
requirements: [PROV-05, INFR-03]

must_haves:
  truths:
    - "docker-compose build completes successfully with provider image built"
    - "docker-compose up starts the provider container and it becomes healthy"
    - "Provider container is reachable from host at http://localhost:9090"
    - "GET http://localhost:9090/ from host returns the MediaProvider manifest"
    - "GET http://localhost:9090/health from host returns health JSON"
    - "host.docker.internal resolves inside the container on both Linux and macOS"
    - "Container starts with only S2P_STASH_URL and S2P_STASH_API_KEY set (no YAML file required)"
  artifacts:
    - path: "Dockerfile"
      provides: "Single-stage python:3.12-slim image with provider + shared_lib"
      contains: "python:3.12-slim"
    - path: "docker-compose.yml"
      provides: "Service definition with ports, extra_hosts, env, healthcheck"
      contains: "host.docker.internal:host-gateway"
    - path: ".dockerignore"
      provides: "Excludes __pycache__, .venv, tests, .git from build context"
      contains: "__pycache__"
  key_links:
    - from: "docker-compose.yml"
      to: "Dockerfile"
      via: "build.dockerfile reference"
      pattern: "dockerfile: Dockerfile"
    - from: "Dockerfile"
      to: "provider/"
      via: "COPY provider/ into image"
      pattern: "COPY provider/"
    - from: "Dockerfile"
      to: "shared_lib/"
      via: "COPY shared_lib/ into image (repo root build context)"
      pattern: "COPY shared_lib/"
    - from: "docker-compose.yml"
      to: "provider/routes/health.py"
      via: "healthcheck curl to /health"
      pattern: "curl.*health"
---

<objective>
Create Docker infrastructure to containerize and run the FastAPI provider, with cross-platform host networking support.

Purpose: Package the provider application built in Plan 01 as a Docker container that Plex can reach. This is the deployment artifact that makes the provider operational — without it, the FastAPI app is just code.

Output: Dockerfile, docker-compose.yml, .dockerignore — `docker-compose up` brings the provider online and reachable at http://localhost:9090.
</objective>

<execution_context>
@/Users/trekkie/.claude/get-shit-done/workflows/execute-plan.md
@/Users/trekkie/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/24-provider-http-skeleton/24-CONTEXT.md
@.planning/phases/24-provider-http-skeleton/24-RESEARCH.md

# Plan 01 output (provider application code)
@.planning/phases/24-provider-http-skeleton/24-01-SUMMARY.md

<interfaces>
<!-- From Plan 01: provider package structure -->
provider/
├── __init__.py          # __version__ = "1.0.0"
├── config.py            # ProviderSettings (pydantic-settings, S2P_ prefix)
├── logging_config.py    # configure_logging(log_level)
├── models.py            # MediaProviderResponse, MediaContainerResponse
├── main.py              # FastAPI app, lifespan, router mounts
├── requirements.txt     # fastapi, uvicorn, pydantic-settings, etc.
└── routes/
    ├── __init__.py
    ├── manifest.py      # GET /
    ├── match.py         # POST /library/metadata/matches
    ├── metadata.py      # GET /library/metadata/{ratingKey}
    └── health.py        # GET /health

<!-- From Phase 23: shared_lib that must be COPY-able -->
shared_lib/
├── __init__.py
├── path_mapper.py       # PathMapper, PathRule
└── stash_client.py      # StashClient, StashScene, etc.

<!-- uvicorn entry point from main.py -->
CMD: uvicorn provider.main:app --host 0.0.0.0 --port 9090
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Dockerfile, docker-compose.yml, and .dockerignore</name>
  <files>
    Dockerfile
    docker-compose.yml
    .dockerignore
  </files>
  <action>
All three files go at the repo root (per user decision — docker-compose.yml at repo root, build context is repo root).

**Dockerfile** — Single-stage python:3.12-slim (locked decision):
```dockerfile
FROM python:3.12-slim

ENV PYTHONDONTWRITEBYTECODE=1 \
    PYTHONUNBUFFERED=1

WORKDIR /app

# Copy shared_lib first (from repo root build context)
COPY shared_lib/ /app/shared_lib/

# Install provider dependencies
COPY provider/requirements.txt /app/requirements.txt
RUN pip install --no-cache-dir -r /app/requirements.txt

# Copy provider application code
COPY provider/ /app/provider/

EXPOSE 9090

# Exec form CMD — required for SIGTERM to reach uvicorn (graceful shutdown)
CMD ["uvicorn", "provider.main:app", "--host", "0.0.0.0", "--port", "9090"]
```

Key points:
- Build context is repo root (`.`) so both `shared_lib/` and `provider/` are available
- COPY shared_lib before provider code — shared_lib changes less frequently, better layer caching
- requirements.txt copied separately from code for Docker layer caching (deps change less often than code)
- Exec form CMD `["uvicorn", ...]` not shell form — required for graceful shutdown (SIGTERM reaches uvicorn, lifespan shutdown fires)
- No non-root user for Phase 24 (simplicity) — can add in later phase if needed

**docker-compose.yml** — Service definition (locked decisions: bridge networking, extra_hosts, port 9090, restart: unless-stopped):
```yaml
services:
  provider:
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - "${PROVIDER_PORT:-9090}:9090"
    extra_hosts:
      - "host.docker.internal:host-gateway"
    environment:
      - S2P_STASH_URL=${S2P_STASH_URL}
      - S2P_STASH_API_KEY=${S2P_STASH_API_KEY}
      - S2P_PLEX_URL=${S2P_PLEX_URL:-http://host.docker.internal:32400}
      - S2P_PLEX_TOKEN=${S2P_PLEX_TOKEN:-}
      - S2P_LOG_LEVEL=${S2P_LOG_LEVEL:-info}
    volumes:
      - ./provider_config:/config
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:9090/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 15s
    restart: unless-stopped
```

Key points:
- `extra_hosts: host.docker.internal:host-gateway` — Linux gets host IP resolution; macOS already has it (Docker Desktop). Requires Docker Engine >= 20.10.
- Environment variables pass through from host `.env` or shell environment. Defaults match CONTEXT.md decisions.
- `volumes: ./provider_config:/config` — Optional mount point for provider.yml. If directory doesn't exist or is empty, provider starts fine (YAML config is optional).
- Healthcheck uses curl to hit /health — container needs curl installed. Add `RUN apt-get update && apt-get install -y --no-install-recommends curl && rm -rf /var/lib/apt/lists/*` to Dockerfile before the EXPOSE line.
- `start_period: 15s` — Give the app time to start before health checks begin failing.

**IMPORTANT:** The Dockerfile needs curl for the healthcheck. Add this line after the pip install RUN:
```dockerfile
RUN apt-get update && apt-get install -y --no-install-recommends curl && rm -rf /var/lib/apt/lists/*
```

**.dockerignore** — Exclude unnecessary files from build context:
```
__pycache__
*.pyc
*.pyo
.venv/
.env
.git/
.github/
.planning/
.pytest_cache/
.coverage
coverage_html/
tests/
docs/
*.md
!provider/requirements.txt
mkdocs.yml
hooks/
plex/
reconciliation/
shared/
sync_queue/
validation/
worker/
process_queue.py
Stash2Plex.py
Stash2Plex.yml
index.yml
data/
cache/
*.zip
```

This is aggressive but correct — the Docker image only needs `provider/` and `shared_lib/`. Everything else is the v1.x Stash plugin, tests, docs, or build artifacts. The .dockerignore keeps the build context small and fast.
  </action>
  <verify>
    <automated>cd /Users/trekkie/projects/Stash2Plex && test -f Dockerfile && test -f docker-compose.yml && test -f .dockerignore && grep -q "python:3.12-slim" Dockerfile && grep -q "host.docker.internal:host-gateway" docker-compose.yml && grep -q "__pycache__" .dockerignore && echo "All Docker files present and correct"</automated>
  </verify>
  <done>
    - Dockerfile uses python:3.12-slim, copies shared_lib + provider, runs uvicorn in exec form
    - docker-compose.yml has bridge networking, extra_hosts for Linux, port 9090, healthcheck, restart: unless-stopped
    - .dockerignore excludes everything except provider/ and shared_lib/
    - curl is installed in the image for healthcheck
  </done>
</task>

<task type="auto">
  <name>Task 2: Build Docker image and verify routes respond</name>
  <files></files>
  <action>
This is a verification-only task — no files created. Build the image and test the routes.

**Step 1: Build the Docker image**
```bash
cd /Users/trekkie/projects/Stash2Plex
docker-compose build
```
This must succeed without errors. If it fails, diagnose and fix the Dockerfile or requirements.

**Step 2: Start the container in detached mode with test config**
```bash
S2P_STASH_URL=http://host.docker.internal:9898 S2P_STASH_API_KEY=test-key docker-compose up -d
```
Wait a few seconds for the container to start.

**Step 3: Verify all routes from the host**
```bash
# Health check
curl -s http://localhost:9090/health | python3 -m json.tool

# Manifest
curl -s http://localhost:9090/ | python3 -m json.tool

# Stub match
curl -s -X POST http://localhost:9090/library/metadata/matches \
  -H "Content-Type: application/json" \
  -d '{"type": 1, "filename": "test.mp4"}' | python3 -m json.tool

# Stub metadata
curl -s http://localhost:9090/library/metadata/12345 | python3 -m json.tool
```

Verify:
- /health returns `{"status": "ok", "version": "1.0.0", ...}`
- / returns `{"MediaProvider": {"identifier": "tv.plex.agents.stash2plex", ...}}`
- /library/metadata/matches returns `{"MediaContainer": {"size": 0, ...}}`
- /library/metadata/12345 returns `{"MediaContainer": {"size": 0, ...}}`

**Step 4: Check container health status**
```bash
docker-compose ps
```
Container should show as "healthy" (or "starting" if within start_period). If "unhealthy", check `docker-compose logs` for errors.

**Step 5: Clean up**
```bash
docker-compose down
```

If any step fails, fix the issue in the relevant file (Dockerfile, docker-compose.yml, or provider code) and retry.
  </action>
  <verify>
    <automated>cd /Users/trekkie/projects/Stash2Plex && docker-compose build 2>&1 | tail -5 && echo "BUILD OK"</automated>
  </verify>
  <done>
    - docker-compose build completes successfully
    - Container starts and routes respond at http://localhost:9090
    - Manifest returns correct Plex protocol JSON
    - Health endpoint returns status JSON
    - Container stops cleanly with docker-compose down
  </done>
</task>

</tasks>

<verification>
1. `docker-compose build` succeeds — image builds without errors
2. `curl http://localhost:9090/` returns MediaProvider manifest with tv.plex.agents.stash2plex
3. `curl http://localhost:9090/health` returns status JSON with all required fields
4. `curl -X POST http://localhost:9090/library/metadata/matches` returns empty MediaContainer
5. `curl http://localhost:9090/library/metadata/12345` returns empty MediaContainer
6. Container healthcheck passes (docker-compose ps shows healthy)
7. docker-compose down stops cleanly
</verification>

<success_criteria>
- Docker image builds from repo root context with both provider/ and shared_lib/ included
- Container runs and is reachable at http://localhost:9090 from the host
- All four Plex protocol routes return correct HTTP 200 responses
- host.docker.internal:host-gateway is configured for Linux compatibility
- Container survives restart (restart: unless-stopped policy)
</success_criteria>

<output>
After completion, create `.planning/phases/24-provider-http-skeleton/24-02-SUMMARY.md`
</output>
