---
phase: 24-provider-http-skeleton
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - provider/__init__.py
  - provider/config.py
  - provider/logging_config.py
  - provider/models.py
  - provider/main.py
  - provider/routes/__init__.py
  - provider/routes/manifest.py
  - provider/routes/match.py
  - provider/routes/metadata.py
  - provider/routes/health.py
  - provider/requirements.txt
autonomous: true
requirements: [PROV-01, INFR-04]

must_haves:
  truths:
    - "GET / returns a valid MediaProvider manifest with identifier tv.plex.agents.stash2plex, type 1 (Movie), and Match + Metadata features"
    - "POST /library/metadata/matches returns 200 with empty Metadata array (stub)"
    - "GET /library/metadata/{ratingKey} returns 200 with empty Metadata array (stub)"
    - "GET /health returns status, version, uptime_seconds, stash_reachable, and plex_registered fields"
    - "ProviderSettings loads S2P_-prefixed env vars and optional YAML config with env-first precedence"
    - "Missing S2P_STASH_URL or S2P_STASH_API_KEY causes a clear error message and exit"
    - "Structured JSON logging is active with ts, level, msg fields"
  artifacts:
    - path: "provider/config.py"
      provides: "ProviderSettings pydantic-settings class with env + YAML precedence"
      contains: "class ProviderSettings"
    - path: "provider/main.py"
      provides: "FastAPI app factory with lifespan, router mounts, startup banner"
      contains: "app = FastAPI"
    - path: "provider/routes/manifest.py"
      provides: "GET / MediaProvider manifest endpoint"
      contains: "tv.plex.agents.stash2plex"
    - path: "provider/routes/health.py"
      provides: "GET /health status endpoint"
      contains: "/health"
    - path: "provider/models.py"
      provides: "Pydantic response models for Plex protocol"
      contains: "MediaProvider"
  key_links:
    - from: "provider/main.py"
      to: "provider/config.py"
      via: "get_settings() called in lifespan"
      pattern: "get_settings"
    - from: "provider/main.py"
      to: "provider/routes/*.py"
      via: "app.include_router"
      pattern: "include_router"
    - from: "provider/routes/manifest.py"
      to: "provider/models.py"
      via: "MediaProvider response model"
      pattern: "MediaProvider"
---

<objective>
Create the FastAPI provider application with configuration, structured logging, Plex protocol routes (manifest + stubs), and health endpoint.

Purpose: Establish the complete Python application that implements the Plex Custom Metadata Provider HTTP protocol, with proper config management and observability. This is the application code that Plan 02 will containerize.

Output: A runnable `provider/` package with all routes, config, logging, and models — ready for Docker packaging.
</objective>

<execution_context>
@/Users/trekkie/.claude/get-shit-done/workflows/execute-plan.md
@/Users/trekkie/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/24-provider-http-skeleton/24-CONTEXT.md
@.planning/phases/24-provider-http-skeleton/24-RESEARCH.md

# Phase 23 outputs (shared_lib used by provider)
@.planning/phases/23-foundation-shared-library/23-01-SUMMARY.md
@.planning/phases/23-foundation-shared-library/23-02-SUMMARY.md

<interfaces>
<!-- shared_lib public API — provider will import these in later phases (25+), not Phase 24 -->
From shared_lib/__init__.py:
```python
from shared_lib.path_mapper import PathMapper, PathRule
from shared_lib.stash_client import (
    StashClient, StashScene, StashFile,
    StashConnectionError, StashQueryError, StashSceneNotFound,
)
```

<!-- PathRule model — config.py path_rules field should mirror this structure -->
From shared_lib/path_mapper.py:
```python
class PathRule(BaseModel):
    name: str
    plex_pattern: str
    stash_pattern: str
    case_insensitive: bool = False
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create provider package with config, logging, and models</name>
  <files>
    provider/__init__.py
    provider/config.py
    provider/logging_config.py
    provider/models.py
    provider/requirements.txt
  </files>
  <action>
Create the `provider/` package directory and core modules:

**provider/__init__.py** — Package marker. Include version constant `__version__ = "1.0.0"` (used by manifest and health).

**provider/config.py** — pydantic-settings v2 class with YAML + env precedence:
```python
class ProviderSettings(BaseSettings):
    model_config = SettingsConfigDict(
        env_prefix="S2P_",
        yaml_file="/config/provider.yml",
        yaml_file_encoding="utf-8",
    )

    stash_url: str               # Required — no default (fail fast)
    stash_api_key: str           # Required — no default (fail fast)
    plex_url: str = "http://host.docker.internal:32400"
    plex_token: str = ""         # Empty = skip registration
    provider_port: int = 9090
    log_level: str = "info"
    path_rules: list[dict] = []  # Loaded from YAML config (not env-settable)
```

Implement `settings_customise_sources` returning `(env_settings, YamlConfigSettingsSource(settings_cls), init_settings)` — env vars beat YAML beats defaults.

Add a module-level `get_settings()` function that caches the ProviderSettings instance (lru_cache or module global). Wrap `ProviderSettings()` instantiation in try/except for `pydantic.ValidationError` — catch it, print a user-friendly error naming the missing S2P_ variables (e.g., "Missing required configuration: S2P_STASH_URL, S2P_STASH_API_KEY. Set these as environment variables or in /config/provider.yml"), then call `sys.exit(1)`.

Handle the case where the YAML file doesn't exist gracefully. If pydantic-settings raises FileNotFoundError, catch it and fall back to env-only settings. Log a debug message that YAML config was not found.

**provider/logging_config.py** — Structured JSON logging setup:
```python
def configure_logging(log_level: str) -> None:
```
Use `python-json-logger>=3.0.0` with the v3 import: `from pythonjsonlogger import json as jsonlogger`. Create a `JsonFormatter` with `fmt="%(asctime)s %(levelname)s %(name)s %(message)s"` and `rename_fields={"asctime": "ts", "levelname": "level", "message": "msg"}`. Clear existing root handlers, add the new handler, set level from config.

**provider/models.py** — Pydantic response models for the Plex protocol:
- `MediaProviderScheme(BaseModel)`: scheme: str
- `MediaProviderType(BaseModel)`: type: int, Scheme: list[MediaProviderScheme]  (use Field(alias="Scheme") if needed)
- `MediaProviderFeature(BaseModel)`: type: str, key: str
- `MediaProviderResponse(BaseModel)`: identifier: str, title: str, version: str, Types: list[MediaProviderType], Feature: list[MediaProviderFeature]
- `MediaContainerResponse(BaseModel)`: size: int, identifier: str, Metadata: list = [], offset: int | None = None, totalSize: int | None = None

These models give us type safety on the Plex protocol responses. Use `model_config = ConfigDict(populate_by_name=True)` where alias capitalization is needed.

**provider/requirements.txt** — Pin minimum versions:
```
fastapi>=0.115.0
uvicorn>=0.30.0
pydantic-settings>=2.3.0
python-json-logger>=3.0.0
PyYAML>=6.0
httpx>=0.27.0
```
Note: httpx is needed for the Stash connectivity check at startup (lifespan). pydantic-settings>=2.3.0 for silent-skip of missing YAML files.
  </action>
  <verify>
    <automated>cd /Users/trekkie/projects/Stash2Plex && python -c "from provider.config import ProviderSettings; from provider.models import MediaProviderResponse, MediaContainerResponse; from provider.logging_config import configure_logging; from provider import __version__; print(f'All imports OK, version={__version__}')"</automated>
  </verify>
  <done>
    - ProviderSettings class validates required fields and exits with clear error when missing
    - ProviderSettings loads S2P_-prefixed env vars with YAML fallback
    - Logging configures structured JSON output with ts/level/msg fields
    - Plex protocol response models exist with correct field names
    - requirements.txt lists all provider dependencies with minimum versions
  </done>
</task>

<task type="auto">
  <name>Task 2: Create FastAPI routes and main application with lifespan</name>
  <files>
    provider/routes/__init__.py
    provider/routes/manifest.py
    provider/routes/match.py
    provider/routes/metadata.py
    provider/routes/health.py
    provider/main.py
  </files>
  <action>
Create the `provider/routes/` package and all route modules:

**provider/routes/__init__.py** — Empty package marker.

**provider/routes/manifest.py** — GET / returning the MediaProvider manifest:
```python
AGENT_ID = "tv.plex.agents.stash2plex"

@router.get("/")
async def manifest():
```
Return a JSONResponse with the MediaProvider object:
- identifier: AGENT_ID
- title: "Stash2Plex"
- version: from `provider.__version__`
- Types: [{ type: 1 (Movie), Scheme: [{ scheme: AGENT_ID }] }]
- Feature: [{ type: "match", key: "/library/metadata/matches" }, { type: "metadata", key: "/library/metadata" }]

Use the Pydantic models from `provider.models` to construct the response, then call `.model_dump(by_alias=True)` to get the correctly-cased dict for JSONResponse. Wrap in `{"MediaProvider": ...}` envelope.

**provider/routes/match.py** — POST /library/metadata/matches (Phase 24 stub):
```python
@router.post("/library/metadata/matches")
async def match(request: Request):
```
Log the incoming request body at info level (including filename if present). Return MediaContainerResponse with size=0, offset=0, totalSize=0, identifier=AGENT_ID, Metadata=[]. Wrap in `{"MediaContainer": ...}` envelope.

**provider/routes/metadata.py** — GET /library/metadata/{ratingKey} (Phase 24 stub):
```python
@router.get("/library/metadata/{ratingKey}")
async def get_metadata(ratingKey: str):
```
Log the requested ratingKey at info level. Return MediaContainerResponse with size=0, identifier=AGENT_ID, Metadata=[]. Wrap in `{"MediaContainer": ...}` envelope.

**provider/routes/health.py** — GET /health:
```python
import time
_start_time = time.time()

@router.get("/health")
async def health():
```
Return JSON with: status ("ok"), version (from provider.__version__), uptime_seconds (int, computed from _start_time), stash_reachable (bool — read from app.state or module-level flag set by lifespan), plex_registered (False for Phase 24 — manual registration). Import the stash_reachable state from a shared location (app.state set in lifespan).

**provider/main.py** — FastAPI app factory with lifespan:
```python
from contextlib import asynccontextmanager

@asynccontextmanager
async def lifespan(app: FastAPI):
    settings = get_settings()
    configure_logging(settings.log_level)

    # Stash connectivity check — warn if unreachable, but start anyway
    stash_ok = await _check_stash_connectivity(settings)
    app.state.stash_reachable = stash_ok

    # Startup banner
    _print_startup_banner(settings, stash_ok)

    yield

    # Shutdown — no cleanup needed in Phase 24

app = FastAPI(lifespan=lifespan, docs_url=None, redoc_url=None)
app.include_router(manifest.router)
app.include_router(match.router)
app.include_router(metadata.router)
app.include_router(health.router)
```

Implement `_check_stash_connectivity(settings)`:
- Use httpx.AsyncClient to GET `{settings.stash_url}/` with a 5-second timeout
- Return True if response status < 500, False otherwise
- Catch httpx.ConnectError, httpx.TimeoutException → return False
- Log result at info level ("Stash reachable at {url}" or "Stash unreachable at {url} — will retry on requests")

Implement `_print_startup_banner(settings, stash_ok)`:
- Print to logger at info level (not print() — goes through JSON formatter)
- Include: version, port, Stash URL + reachable status, Plex URL, path rule count
- Example format:
  ```
  Stash2Plex Provider v1.0.0
  Port: 9090
  Stash: http://localhost:9898 [reachable] / [unreachable]
  Plex: http://host.docker.internal:32400
  Path rules: 0 loaded
  ```

Add request logging middleware or use FastAPI middleware to log all incoming requests at info level with path, method, and response time (milliseconds). Keep it simple — a @app.middleware("http") that records start time, awaits call_next, then logs.

Disable FastAPI's auto-generated /docs and /redoc endpoints (docs_url=None, redoc_url=None) — this is a machine-to-machine API, not a user-facing one.
  </action>
  <verify>
    <automated>cd /Users/trekkie/projects/Stash2Plex && S2P_STASH_URL=http://localhost:9898 S2P_STASH_API_KEY=test-key python -c "
from provider.main import app
from fastapi.testclient import TestClient
client = TestClient(app, raise_server_exceptions=False)
r = client.get('/')
assert r.status_code == 200
mp = r.json()['MediaProvider']
assert mp['identifier'] == 'tv.plex.agents.stash2plex'
assert len(mp['Feature']) == 2
r2 = client.post('/library/metadata/matches', json={'type': 1, 'filename': 'test.mp4'})
assert r2.status_code == 200
assert r2.json()['MediaContainer']['size'] == 0
r3 = client.get('/library/metadata/12345')
assert r3.status_code == 200
r4 = client.get('/health')
assert r4.status_code == 200
h = r4.json()
assert 'status' in h and 'version' in h and 'uptime_seconds' in h
print('All route tests passed')
"</automated>
  </verify>
  <done>
    - GET / returns valid MediaProvider manifest with tv.plex.agents.stash2plex identifier, Movie type, Match + Metadata features
    - POST /library/metadata/matches returns 200 with empty MediaContainer (stub)
    - GET /library/metadata/{ratingKey} returns 200 with empty MediaContainer (stub)
    - GET /health returns status, version, uptime_seconds, stash_reachable, plex_registered
    - Lifespan runs Stash connectivity check and prints startup banner
    - Request logging middleware logs method, path, and response time for all requests
  </done>
</task>

</tasks>

<verification>
1. All provider Python modules import without errors
2. FastAPI TestClient confirms all four route patterns return correct HTTP status codes and JSON shapes
3. ProviderSettings validates required fields and rejects missing S2P_STASH_URL/S2P_STASH_API_KEY
4. Manifest response matches Plex protocol: MediaProvider.identifier, Types[0].type=1, Feature types match+metadata
5. Health endpoint returns all required fields
</verification>

<success_criteria>
- `provider/` package is importable and all modules resolve
- All four routes (/, /library/metadata/matches, /library/metadata/{ratingKey}, /health) return correct 200 responses
- Config loads from S2P_ env vars with YAML fallback
- Structured JSON logging is configured
- Application is ready for Docker containerization in Plan 02
</success_criteria>

<output>
After completion, create `.planning/phases/24-provider-http-skeleton/24-01-SUMMARY.md`
</output>
