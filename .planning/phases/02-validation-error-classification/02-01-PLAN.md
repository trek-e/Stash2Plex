---
phase: 02-validation-error-classification
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - validation/__init__.py
  - validation/sanitizers.py
  - validation/errors.py
autonomous: true

must_haves:
  truths:
    - "Text sanitization removes control characters without losing content"
    - "Smart quotes and dashes convert to ASCII equivalents"
    - "Error classification returns TransientError or PermanentError type"
    - "HTTP 429/5xx classified as transient, 4xx as permanent"
  artifacts:
    - path: "validation/__init__.py"
      provides: "Module initialization"
    - path: "validation/sanitizers.py"
      provides: "sanitize_for_plex function"
      exports: ["sanitize_for_plex", "QUOTE_MAP"]
    - path: "validation/errors.py"
      provides: "Error classification functions"
      exports: ["classify_exception", "classify_http_error", "TRANSIENT_CODES", "PERMANENT_CODES"]
  key_links:
    - from: "validation/errors.py"
      to: "worker/processor.py"
      via: "imports TransientError, PermanentError"
      pattern: "from worker\\.processor import"
---

<objective>
Create foundational validation utilities: text sanitization for Plex API compatibility and centralized error classification for retry/DLQ routing.

Purpose: These utilities are dependencies for metadata validation (Plan 02) and will be used throughout the sync pipeline. Sanitization ensures text fields don't cause Plex API errors. Error classification provides consistent retry vs DLQ routing.

Output: Two new modules in validation/ directory ready for use by other components.
</objective>

<execution_context>
@/Users/trekkie/.claude/get-shit-done/workflows/execute-plan.md
@/Users/trekkie/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-validation-error-classification/02-RESEARCH.md

# Existing exception classes to import
@worker/processor.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create validation module with sanitizers</name>
  <files>validation/__init__.py, validation/sanitizers.py</files>
  <action>
Create validation/ directory and module:

1. Create `validation/__init__.py` with empty init (will be populated as module grows)

2. Create `validation/sanitizers.py` with:
   - `QUOTE_MAP`: str.maketrans dict for smart quote conversion (left/right double quotes to ", left/right single quotes to ', en/em dashes to -, ellipsis to ...)
   - `sanitize_for_plex(text: str, max_length: int = 255) -> str`:
     - Return empty string if text is None or empty
     - Normalize Unicode with `unicodedata.normalize('NFC', text)`
     - Remove control characters (category 'Cc') and format characters ('Cf') using list comprehension with `unicodedata.category()`
     - Apply QUOTE_MAP translation
     - Collapse whitespace (split + join)
     - Truncate at max_length if > 0, preferring word boundary (rfind space, keep if > 80% of max_length)
     - Return sanitized text

Use Python stdlib only (unicodedata). No external dependencies.

Log sanitization at module level for debugging: add optional `logger` parameter with default None.
  </action>
  <verify>
```bash
cd /Users/trekkie/projects/PlexSync && python -c "
from validation.sanitizers import sanitize_for_plex, QUOTE_MAP

# Test basic sanitization
assert sanitize_for_plex('Hello World') == 'Hello World'
assert sanitize_for_plex('Test\x00Control\x1fChars') == 'TestControlChars'
assert sanitize_for_plex('Smart "quotes" and 'apostrophe'') == 'Smart \"quotes\" and \\'apostrophe\\''
assert sanitize_for_plex('  Multiple   spaces  ') == 'Multiple spaces'
assert len(sanitize_for_plex('x' * 300)) <= 255
print('All sanitizer tests passed')
"
```
  </verify>
  <done>sanitize_for_plex function handles control chars, smart quotes, whitespace, and truncation correctly</done>
</task>

<task type="auto">
  <name>Task 2: Create error classification module</name>
  <files>validation/errors.py</files>
  <action>
Create `validation/errors.py` with centralized error classification:

1. Import existing exception classes:
   ```python
   from worker.processor import TransientError, PermanentError
   ```

2. Define status code sets:
   - `TRANSIENT_CODES = frozenset({429, 500, 502, 503, 504})`
   - `PERMANENT_CODES = frozenset({400, 401, 403, 404, 405, 410, 422})`

3. Implement `classify_http_error(status_code: int) -> Type[Exception]`:
   - If in TRANSIENT_CODES: return TransientError
   - If in PERMANENT_CODES: return PermanentError
   - If 400-499: return PermanentError (default 4xx)
   - If >= 500: return TransientError (default 5xx)
   - Otherwise: return TransientError (unknown = allow retry)

4. Implement `classify_exception(exc: Exception) -> Type[Exception]`:
   - Check for HTTP response: `hasattr(exc, 'response')` and `exc.response is not None`
     - Extract status_code and call classify_http_error
   - Check network errors: isinstance(exc, (ConnectionError, TimeoutError, OSError)) -> TransientError
   - Check validation errors: isinstance(exc, (ValueError, TypeError, KeyError, AttributeError)) -> PermanentError
   - Check already classified: isinstance(exc, TransientError) or PermanentError -> return same type
   - Default unknown to TransientError (safer, allows retry)

Add debug logging for classification decisions (use standard logging module).
  </action>
  <verify>
```bash
cd /Users/trekkie/projects/PlexSync && python -c "
from validation.errors import classify_exception, classify_http_error, TRANSIENT_CODES, PERMANENT_CODES
from worker.processor import TransientError, PermanentError

# Test HTTP classification
assert classify_http_error(429) == TransientError
assert classify_http_error(500) == TransientError
assert classify_http_error(503) == TransientError
assert classify_http_error(400) == PermanentError
assert classify_http_error(401) == PermanentError
assert classify_http_error(404) == PermanentError

# Test exception classification
assert classify_exception(ConnectionError()) == TransientError
assert classify_exception(TimeoutError()) == TransientError
assert classify_exception(ValueError()) == PermanentError
assert classify_exception(TypeError()) == PermanentError

print('All error classification tests passed')
"
```
  </verify>
  <done>Error classification returns correct type for HTTP codes, network errors, and validation errors</done>
</task>

<task type="auto">
  <name>Task 3: Update validation module exports</name>
  <files>validation/__init__.py</files>
  <action>
Update `validation/__init__.py` to export public API:

```python
"""
Validation module for PlexSync.

Provides metadata validation, text sanitization, and error classification.
"""

from validation.sanitizers import sanitize_for_plex
from validation.errors import classify_exception, classify_http_error

__all__ = [
    'sanitize_for_plex',
    'classify_exception',
    'classify_http_error',
]
```

This allows clean imports: `from validation import sanitize_for_plex, classify_exception`
  </action>
  <verify>
```bash
cd /Users/trekkie/projects/PlexSync && python -c "
from validation import sanitize_for_plex, classify_exception, classify_http_error
print('Module exports working correctly')
"
```
  </verify>
  <done>validation module exports sanitize_for_plex, classify_exception, classify_http_error</done>
</task>

</tasks>

<verification>
All three tasks verified individually. Combined check:

```bash
cd /Users/trekkie/projects/PlexSync && python -c "
# Full module verification
from validation import sanitize_for_plex, classify_exception
from validation.sanitizers import QUOTE_MAP
from validation.errors import TRANSIENT_CODES, PERMANENT_CODES

# Verify sanitizer
text = 'Test "smart quotes" with\x00control chars'
clean = sanitize_for_plex(text)
assert '\x00' not in clean
assert '"' in clean  # smart quotes converted

# Verify error classifier
from worker.processor import TransientError
assert classify_exception(TimeoutError('test')) == TransientError

print('Full validation module verification passed')
"
```
</verification>

<success_criteria>
- validation/ directory exists with __init__.py, sanitizers.py, errors.py
- sanitize_for_plex handles: control chars, smart quotes, whitespace, truncation
- classify_exception correctly routes: HTTP codes, network errors, validation errors
- All verification commands pass
- No external dependencies added (stdlib only for sanitizers)
</success_criteria>

<output>
After completion, create `.planning/phases/02-validation-error-classification/02-01-SUMMARY.md`
</output>
