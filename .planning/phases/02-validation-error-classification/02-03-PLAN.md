---
phase: 02-validation-error-classification
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - validation/config.py
  - PlexSync.py
  - validation/__init__.py
autonomous: true

must_haves:
  truths:
    - "Config with missing plex_url or plex_token raises ValidationError"
    - "Config with invalid URL format is rejected"
    - "Plugin logs validated config on startup (token masked)"
    - "Plugin fails loudly with clear error message on invalid config"
    - "Optional config tunables have sensible defaults"
  artifacts:
    - path: "validation/config.py"
      provides: "PlexSyncConfig pydantic model"
      exports: ["PlexSyncConfig", "validate_config"]
    - path: "PlexSync.py"
      provides: "Modified plugin with config validation"
      contains: "validate_config"
  key_links:
    - from: "PlexSync.py"
      to: "validation/config.py"
      via: "imports validate_config"
      pattern: "from validation\\.config import"
    - from: "PlexSync.py"
      to: "worker/processor.py"
      via: "passes max_retries from config"
      pattern: "SyncWorker.*max_retries"
---

<objective>
Create pydantic config validation model and integrate it into plugin initialization for fail-fast config validation.

Purpose: Ensures plugin configuration is valid before any sync operations. Invalid config fails loudly at startup rather than during sync, making debugging easier. Config tunables allow customization while providing sensible defaults.

Output: PlexSyncConfig model with validation, validate_config helper, and updated PlexSync.py that validates config on init.
</objective>

<execution_context>
@/Users/trekkie/.claude/get-shit-done/workflows/execute-plan.md
@/Users/trekkie/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-validation-error-classification/02-RESEARCH.md
@.planning/phases/02-validation-error-classification/02-01-SUMMARY.md

# Files to reference
@PlexSync.py
@worker/processor.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PlexSyncConfig pydantic model</name>
  <files>validation/config.py</files>
  <action>
Create `validation/config.py` with pydantic v2 config validation:

1. Imports:
   ```python
   from pydantic import BaseModel, Field, field_validator, ValidationError
   from typing import Optional
   import logging
   ```

2. Create logger: `log = logging.getLogger('PlexSync.config')`

3. Define `PlexSyncConfig(BaseModel)`:
   Required fields:
   - `plex_url: str` - Plex server URL (e.g., http://192.168.1.100:32400)
   - `plex_token: str` - Plex authentication token

   Optional tunables with defaults:
   - `enabled: bool = True` - master on/off switch
   - `max_retries: int = Field(default=5, ge=1, le=20)` - retry attempts before DLQ
   - `poll_interval: float = Field(default=1.0, ge=0.1, le=60.0)` - worker poll interval
   - `strict_mode: bool = False` - if True, reject invalid metadata; if False, sanitize and continue

4. Add field validators:
   ```python
   @field_validator('plex_url', mode='after')
   @classmethod
   def validate_plex_url(cls, v: str) -> str:
       if not v:
           raise ValueError('plex_url is required')
       if not v.startswith(('http://', 'https://')):
           raise ValueError('plex_url must start with http:// or https://')
       return v.rstrip('/')  # Normalize: remove trailing slash

   @field_validator('plex_token', mode='after')
   @classmethod
   def validate_plex_token(cls, v: str) -> str:
       if not v:
           raise ValueError('plex_token is required')
       if len(v) < 10:
           raise ValueError('plex_token appears invalid (too short)')
       return v
   ```

5. Add helper method for safe logging:
   ```python
   def log_config(self) -> None:
       """Log configuration with masked token for security."""
       if len(self.plex_token) > 8:
           masked = self.plex_token[:4] + '****' + self.plex_token[-4:]
       else:
           masked = '****'
       log.info(
           f"PlexSync config: url={self.plex_url}, token={masked}, "
           f"max_retries={self.max_retries}, enabled={self.enabled}, "
           f"strict_mode={self.strict_mode}"
       )
   ```

6. Create helper function `validate_config(config_dict: dict) -> tuple[Optional[PlexSyncConfig], Optional[str]]`:
   - Try to create PlexSyncConfig from dict
   - On success: return (config, None)
   - On ValidationError: return (None, error_message)

7. Export ValidationError from pydantic.
  </action>
  <verify>
```bash
cd /Users/trekkie/projects/PlexSync && python -c "
from validation.config import PlexSyncConfig, validate_config

# Test valid config
config, err = validate_config({
    'plex_url': 'http://192.168.1.100:32400',
    'plex_token': 'abcdefghij1234567890'
})
assert config is not None and err is None
assert config.plex_url == 'http://192.168.1.100:32400'
assert config.max_retries == 5  # default
assert config.enabled == True  # default

# Test URL normalization (trailing slash removed)
config, _ = validate_config({
    'plex_url': 'http://192.168.1.100:32400/',
    'plex_token': 'abcdefghij1234567890'
})
assert not config.plex_url.endswith('/')

# Test missing plex_url
config, err = validate_config({'plex_token': 'abcdefghij1234567890'})
assert config is None and 'plex_url' in err.lower()

# Test invalid URL format
config, err = validate_config({
    'plex_url': 'not-a-url',
    'plex_token': 'abcdefghij1234567890'
})
assert config is None and 'http' in err.lower()

# Test short token
config, err = validate_config({
    'plex_url': 'http://localhost:32400',
    'plex_token': 'short'
})
assert config is None and 'token' in err.lower()

# Test optional overrides
config, _ = validate_config({
    'plex_url': 'http://localhost:32400',
    'plex_token': 'abcdefghij1234567890',
    'max_retries': 10,
    'strict_mode': True
})
assert config.max_retries == 10
assert config.strict_mode == True

print('All config validation tests passed')
"
```
  </verify>
  <done>PlexSyncConfig model validates required fields, URL format, and token; provides sensible defaults for tunables</done>
</task>

<task type="auto">
  <name>Task 2: Integrate config validation into plugin initialization</name>
  <files>PlexSync.py</files>
  <action>
Update `PlexSync.py` to validate config on initialization:

1. Add import at top (after existing imports):
   ```python
   from validation.config import validate_config, PlexSyncConfig
   ```

2. Add global for config:
   ```python
   config: PlexSyncConfig = None
   ```

3. Modify `initialize()` function to:
   - Accept optional config_dict parameter (for when config comes from Stash)
   - Validate config using validate_config()
   - If validation fails: print clear error message and raise exception
   - If validation succeeds: log config (masked token) and store globally
   - Pass config values to components that need them (e.g., max_retries to SyncWorker)

4. Modify `main()` to extract config from Stash input:
   - Stash passes plugin config in the input JSON
   - Check for config in input_data (location TBD - may be 'serverConnection' or 'pluginSettings')
   - For now, check common locations: input_data.get('server_connection') or input_data.get('args', {}).get('config')
   - If no config found, use environment variables as fallback:
     - PLEX_URL, PLEX_TOKEN
   - Pass extracted config to initialize()

5. Update SyncWorker initialization to use config:
   ```python
   worker = SyncWorker(
       queue_manager.get_queue(),
       dlq,
       max_retries=config.max_retries
   )
   ```

6. Add graceful error handling:
   - If config validation fails, print error to stderr and exit with code 1
   - Error message should be user-friendly: "PlexSync configuration error: {details}"

Note: The exact location of Plex config in Stash's input JSON may need adjustment based on actual Stash plugin protocol. For now, implement with reasonable assumptions and fallback to env vars.
  </action>
  <verify>
```bash
cd /Users/trekkie/projects/PlexSync && python -c "
import os
import sys
import json
from io import StringIO

# Test config validation integration
# Set env vars for fallback
os.environ['PLEX_URL'] = 'http://test:32400'
os.environ['PLEX_TOKEN'] = 'test_token_12345'

# Import after setting env vars
from PlexSync import initialize, get_plugin_data_dir
from validation.config import PlexSyncConfig

# Test that initialize works with env var config
# (Full test would require mocking stdin, just verify imports work)

print('Config integration imports working')

# Clean up
del os.environ['PLEX_URL']
del os.environ['PLEX_TOKEN']
"
```
  </verify>
  <done>Plugin validates config on init, fails loudly with clear error message if invalid, logs masked config on success</done>
</task>

<task type="auto">
  <name>Task 3: Update validation module exports</name>
  <files>validation/__init__.py</files>
  <action>
Update `validation/__init__.py` to include config exports:

```python
"""
Validation module for PlexSync.

Provides metadata validation, text sanitization, error classification,
and plugin configuration validation.
"""

from validation.sanitizers import sanitize_for_plex
from validation.errors import classify_exception, classify_http_error
from validation.metadata import SyncMetadata, validate_metadata
from validation.config import PlexSyncConfig, validate_config

__all__ = [
    'sanitize_for_plex',
    'classify_exception',
    'classify_http_error',
    'SyncMetadata',
    'validate_metadata',
    'PlexSyncConfig',
    'validate_config',
]
```
  </action>
  <verify>
```bash
cd /Users/trekkie/projects/PlexSync && python -c "
from validation import PlexSyncConfig, validate_config
config, err = validate_config({
    'plex_url': 'http://localhost:32400',
    'plex_token': 'test_token_12345'
})
assert config is not None
print('Config exports working')
"
```
  </verify>
  <done>validation module exports PlexSyncConfig and validate_config</done>
</task>

</tasks>

<verification>
End-to-end config validation check:

```bash
cd /Users/trekkie/projects/PlexSync && python -c "
from validation import PlexSyncConfig, validate_config

# 1. Verify required field enforcement
config, err = validate_config({'plex_url': 'http://localhost:32400'})
assert config is None, 'Should fail without plex_token'
assert 'token' in err.lower()

# 2. Verify URL validation
config, err = validate_config({
    'plex_url': 'ftp://invalid',
    'plex_token': 'valid_token_12345'
})
assert config is None, 'Should reject non-HTTP URL'

# 3. Verify defaults applied
config, _ = validate_config({
    'plex_url': 'https://plex.local:32400',
    'plex_token': 'valid_token_12345'
})
assert config.max_retries == 5
assert config.enabled == True
assert config.strict_mode == False

# 4. Verify log_config works (doesn't expose token)
import logging
logging.basicConfig(level=logging.INFO)
config.log_config()  # Should not print full token

print('End-to-end config validation passed')
"
```
</verification>

<success_criteria>
- PlexSyncConfig model requires: plex_url (valid HTTP/HTTPS), plex_token (min 10 chars)
- Optional tunables have defaults: max_retries=5, poll_interval=1.0, enabled=True, strict_mode=False
- URL normalized (trailing slash removed)
- log_config() masks token (shows first/last 4 chars only)
- Plugin validates config on init before starting worker
- Invalid config produces clear error message and exits
- All verification commands pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-validation-error-classification/02-03-SUMMARY.md`
</output>
