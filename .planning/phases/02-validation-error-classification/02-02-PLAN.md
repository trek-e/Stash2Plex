---
phase: 02-validation-error-classification
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - validation/metadata.py
  - hooks/handlers.py
autonomous: true

must_haves:
  truths:
    - "Metadata with missing scene_id or title raises ValidationError"
    - "Metadata with invalid types is coerced or rejected"
    - "String fields are sanitized before validation (control chars removed)"
    - "Sanitization logged at WARN level when text is modified"
    - "Hook handler validates metadata before enqueue"
    - "Hook handler still completes in <100ms"
  artifacts:
    - path: "validation/metadata.py"
      provides: "SyncMetadata pydantic model"
      exports: ["SyncMetadata", "validate_metadata"]
    - path: "hooks/handlers.py"
      provides: "Modified hook handler with validation"
      contains: "validate_metadata"
  key_links:
    - from: "validation/metadata.py"
      to: "validation/sanitizers.py"
      via: "imports sanitize_for_plex"
      pattern: "from validation\\.sanitizers import"
    - from: "hooks/handlers.py"
      to: "validation/metadata.py"
      via: "imports validate_metadata"
      pattern: "from validation\\.metadata import"
---

<objective>
Create pydantic metadata validation model and integrate it into the hook handler for pre-enqueue validation.

Purpose: Ensures invalid data never enters the queue. Sanitizes text fields to prevent Plex API errors. Maintains <100ms hook handler performance by keeping validation lightweight.

Output: SyncMetadata model with field validators, validate_metadata helper function, and updated hook handler that validates before enqueueing.
</objective>

<execution_context>
@/Users/trekkie/.claude/get-shit-done/workflows/execute-plan.md
@/Users/trekkie/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-validation-error-classification/02-RESEARCH.md
@.planning/phases/02-validation-error-classification/02-01-SUMMARY.md

# Files to reference
@validation/sanitizers.py
@hooks/handlers.py
@queue/models.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SyncMetadata pydantic model</name>
  <files>validation/metadata.py</files>
  <action>
Create `validation/metadata.py` with pydantic v2 metadata validation:

1. Imports:
   ```python
   from pydantic import BaseModel, Field, field_validator, ValidationError
   from typing import Optional, Any
   import logging
   from validation.sanitizers import sanitize_for_plex
   ```

2. Create logger: `log = logging.getLogger('PlexSync.validation')`

3. Define `SyncMetadata(BaseModel)`:
   - Required fields:
     - `scene_id: int = Field(..., gt=0)` - must be positive integer
     - `title: str = Field(..., min_length=1, max_length=255)` - required, non-empty
   - Optional fields:
     - `details: Optional[str] = Field(default=None, max_length=10000)` - summary/description
     - `date: Optional[str] = None` - release date
     - `rating100: Optional[int] = Field(default=None, ge=0, le=100)` - 0-100 rating
     - `studio: Optional[str] = Field(default=None, max_length=255)`
     - `performers: Optional[list[str]] = None`
     - `tags: Optional[list[str]] = None`

4. Add field validators with `mode='before'` for sanitization:
   ```python
   @field_validator('title', 'details', 'studio', mode='before')
   @classmethod
   def sanitize_string_field(cls, v: Any) -> Optional[str]:
       if v is None:
           return None
       if not isinstance(v, str):
           v = str(v)
       original = v
       # Use appropriate max_length based on field
       sanitized = sanitize_for_plex(v)
       if sanitized != original:
           log.warning(f"Sanitized text: '{original[:50]}...' -> '{sanitized[:50]}...'")
       return sanitized

   @field_validator('performers', 'tags', mode='before')
   @classmethod
   def sanitize_string_list(cls, v: Any) -> Optional[list[str]]:
       if v is None:
           return None
       if not isinstance(v, list):
           return None
       return [sanitize_for_plex(str(item), max_length=255) for item in v if item]
   ```

5. Create helper function `validate_metadata(data: dict) -> tuple[Optional[SyncMetadata], Optional[str]]`:
   - Try to create SyncMetadata from data dict
   - On success: return (model, None)
   - On ValidationError: return (None, error_message)
   - This allows caller to decide reject vs sanitize+continue

6. Export ValidationError from pydantic for use by callers.
  </action>
  <verify>
```bash
cd /Users/trekkie/projects/PlexSync && python -c "
from validation.metadata import SyncMetadata, validate_metadata
from pydantic import ValidationError

# Test valid metadata
meta, err = validate_metadata({'scene_id': 123, 'title': 'Test Movie'})
assert meta is not None and err is None
assert meta.scene_id == 123
assert meta.title == 'Test Movie'

# Test missing required field
meta, err = validate_metadata({'scene_id': 123})
assert meta is None and 'title' in err.lower()

# Test invalid scene_id
meta, err = validate_metadata({'scene_id': -1, 'title': 'Test'})
assert meta is None and 'scene_id' in err.lower()

# Test sanitization
meta, err = validate_metadata({
    'scene_id': 456,
    'title': 'Test\x00Movie',  # control char
})
assert meta is not None
assert '\x00' not in meta.title

# Test optional fields
meta, err = validate_metadata({
    'scene_id': 789,
    'title': 'Full Test',
    'details': 'Description',
    'rating100': 85,
    'performers': ['Actor One', 'Actor Two'],
})
assert meta is not None
assert meta.rating100 == 85
assert len(meta.performers) == 2

print('All metadata validation tests passed')
"
```
  </verify>
  <done>SyncMetadata model validates required fields, enforces constraints, and sanitizes text fields</done>
</task>

<task type="auto">
  <name>Task 2: Integrate validation into hook handler</name>
  <files>hooks/handlers.py</files>
  <action>
Update `hooks/handlers.py` to validate metadata before enqueue:

1. Add import at top:
   ```python
   from validation.metadata import validate_metadata
   ```

2. Modify `on_scene_update()` function:
   - After the `requires_plex_sync` check, before enqueue:
   - Extract title from update_data (may be in 'title' key or need lookup)
   - Build validation dict: `{'scene_id': scene_id, 'title': title, ...other fields from update_data}`
   - Call `validate_metadata(validation_dict)`
   - If validation fails:
     - Log warning with error message
     - Per CONTEXT.md: sanitize and continue (don't reject) - but if title is missing, we must skip
     - If title is truly missing (not just invalid), return False and log
   - If validation succeeds:
     - Use validated/sanitized data for enqueue
     - Pass sanitized data dict to enqueue function

3. Keep total function under 100ms:
   - Pydantic validation is ~50 microseconds, well within budget
   - No additional I/O or API calls

4. Update the job data to use sanitized fields when available.

Note: The update_data from Stash hook contains the fields. Build the validation dict from available fields:
```python
validation_data = {
    'scene_id': scene_id,
    'title': update_data.get('title'),
    'details': update_data.get('details'),
    'rating100': update_data.get('rating100'),
    'date': update_data.get('date'),
    'studio': update_data.get('studio'),
    'performers': update_data.get('performers'),
    'tags': update_data.get('tags'),
}
# Remove None values for optional fields
validation_data = {k: v for k, v in validation_data.items() if v is not None}
```
  </action>
  <verify>
```bash
cd /Users/trekkie/projects/PlexSync && python -c "
import time
from hooks.handlers import on_scene_update, requires_plex_sync

# Mock queue for testing
class MockQueue:
    def __init__(self):
        self.jobs = []
    def put(self, job):
        self.jobs.append(job)

queue = MockQueue()

# Test with valid data (should enqueue)
start = time.time()
result = on_scene_update(123, {'title': 'Test Movie', 'rating100': 85}, queue)
elapsed = (time.time() - start) * 1000
print(f'Valid data enqueue took {elapsed:.1f}ms')
assert elapsed < 100, 'Hook handler exceeded 100ms'

# Test with control characters (should sanitize and enqueue)
result = on_scene_update(456, {'title': 'Test\x00Movie'}, queue)
# Should have enqueued sanitized version

# Test with missing title (should fail gracefully)
result = on_scene_update(789, {'rating100': 50}, queue)
# Should return False or handle gracefully

print('Hook handler integration tests passed')
"
```
  </verify>
  <done>Hook handler validates and sanitizes metadata before enqueue, maintains <100ms performance</done>
</task>

<task type="auto">
  <name>Task 3: Update validation module exports</name>
  <files>validation/__init__.py</files>
  <action>
Update `validation/__init__.py` to include metadata exports:

```python
"""
Validation module for PlexSync.

Provides metadata validation, text sanitization, and error classification.
"""

from validation.sanitizers import sanitize_for_plex
from validation.errors import classify_exception, classify_http_error
from validation.metadata import SyncMetadata, validate_metadata

__all__ = [
    'sanitize_for_plex',
    'classify_exception',
    'classify_http_error',
    'SyncMetadata',
    'validate_metadata',
]
```
  </action>
  <verify>
```bash
cd /Users/trekkie/projects/PlexSync && python -c "
from validation import SyncMetadata, validate_metadata
meta, err = validate_metadata({'scene_id': 1, 'title': 'Test'})
assert meta is not None
print('Metadata exports working')
"
```
  </verify>
  <done>validation module exports SyncMetadata and validate_metadata</done>
</task>

</tasks>

<verification>
End-to-end validation check:

```bash
cd /Users/trekkie/projects/PlexSync && python -c "
import time
from validation import SyncMetadata, validate_metadata, sanitize_for_plex

# 1. Verify sanitization integrated into model
meta, _ = validate_metadata({
    'scene_id': 100,
    'title': 'Test "Movie" with control\x00chars',
    'details': 'Long description...',
})
assert meta is not None
assert '\x00' not in meta.title
assert '\"' in meta.title  # smart quotes converted

# 2. Verify performance
start = time.time()
for _ in range(100):
    validate_metadata({'scene_id': 1, 'title': 'Performance Test'})
elapsed = time.time() - start
print(f'100 validations took {elapsed*1000:.1f}ms ({elapsed*10:.2f}ms each)')
assert elapsed < 0.1, 'Validation too slow'

# 3. Verify required field enforcement
meta, err = validate_metadata({'title': 'No Scene ID'})
assert meta is None
assert 'scene_id' in err.lower()

print('End-to-end validation verification passed')
"
```
</verification>

<success_criteria>
- SyncMetadata model enforces: scene_id > 0, title required and non-empty
- String fields sanitized via field_validator before type checking
- Sanitization logged at WARN level when text modified
- validate_metadata returns (model, None) or (None, error_string)
- Hook handler validates before enqueue
- Hook handler still <100ms (validation adds ~1ms max)
- All verification commands pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-validation-error-classification/02-02-SUMMARY.md`
</output>
