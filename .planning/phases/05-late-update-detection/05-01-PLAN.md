---
phase: 05-late-update-detection
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - queue/operations.py
  - validation/config.py
autonomous: true

must_haves:
  truths:
    - "Sync timestamps persist across restarts in JSON file"
    - "Config includes strict_matching and preserve_plex_edits flags"
  artifacts:
    - path: "queue/operations.py"
      provides: "Sync timestamp helpers for late update detection"
      exports: ["load_sync_timestamps", "save_sync_timestamp"]
    - path: "validation/config.py"
      provides: "Extended config with matching flags"
      contains: "strict_matching"
  key_links:
    - from: "queue/operations.py"
      to: "JSON file storage"
      via: "json.load/dump"
      pattern: "sync_timestamps\\.json"
---

<objective>
Create sync timestamp tracking infrastructure and extend configuration for late update detection.

Purpose: Enable timestamp-based change detection by storing last_synced_at per scene in a JSON file alongside the queue, and add config flags to control confidence-based matching behavior.

Output:
- Sync timestamp helpers in queue/operations.py (load_sync_timestamps, save_sync_timestamp)
- Extended PlexSyncConfig with strict_matching and preserve_plex_edits boolean flags
</objective>

<execution_context>
@/Users/trekkie/.claude/get-shit-done/workflows/execute-plan.md
@/Users/trekkie/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-late-update-detection/05-CONTEXT.md

# Existing files to extend
@queue/operations.py
@validation/config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add sync timestamp helpers to queue/operations.py</name>
  <files>queue/operations.py</files>
  <action>
Add sync timestamp helper functions to queue/operations.py for tracking last_synced_at per scene.

This approach piggybacks on existing queue structure by storing timestamps in a JSON file alongside the queue database (same data directory). Simple and persistent without requiring a new module.

Add these functions:

```python
import json

def _get_sync_timestamps_path(data_dir: str) -> str:
    """Get path to sync timestamps JSON file."""
    return os.path.join(data_dir, 'sync_timestamps.json')


def load_sync_timestamps(data_dir: str) -> dict[int, float]:
    """
    Load sync timestamps from JSON file.

    Args:
        data_dir: Queue data directory (same as queue_path)

    Returns:
        Dict mapping scene_id -> last_synced_at timestamp
    """
    path = _get_sync_timestamps_path(data_dir)
    if not os.path.exists(path):
        return {}

    try:
        with open(path, 'r') as f:
            data = json.load(f)
            # JSON keys are strings, convert back to int
            return {int(k): v for k, v in data.items()}
    except (json.JSONDecodeError, IOError):
        return {}


def save_sync_timestamp(data_dir: str, scene_id: int, timestamp: float) -> None:
    """
    Save sync timestamp for a scene.

    Args:
        data_dir: Queue data directory
        scene_id: Scene ID that was synced
        timestamp: time.time() when sync completed
    """
    path = _get_sync_timestamps_path(data_dir)

    # Load existing timestamps
    timestamps = load_sync_timestamps(data_dir)

    # Update with new timestamp
    timestamps[scene_id] = timestamp

    # Write back atomically (write to temp, rename)
    temp_path = path + '.tmp'
    with open(temp_path, 'w') as f:
        json.dump(timestamps, f)
    os.replace(temp_path, path)
```

Add `import json` at the top with other imports.

Do NOT create a separate sync/ module - this approach is simpler and honors the user's decision to "piggyback on existing queue job structure".
  </action>
  <verify>
python -c "from queue.operations import load_sync_timestamps, save_sync_timestamp; import tempfile, os; d = tempfile.mkdtemp(); save_sync_timestamp(d, 123, 1000.5); ts = load_sync_timestamps(d); print(f'Loaded: {ts}'); assert ts[123] == 1000.5; import shutil; shutil.rmtree(d); print('Sync timestamps OK')"
  </verify>
  <done>queue/operations.py has load_sync_timestamps() and save_sync_timestamp() functions using JSON file storage</done>
</task>

<task type="auto">
  <name>Task 2: Add strict_matching and preserve_plex_edits config flags</name>
  <files>validation/config.py</files>
  <action>
Extend PlexSyncConfig in validation/config.py with two new boolean fields:

1. Add strict_matching field:
   ```python
   strict_matching: bool = Field(
       default=True,
       description="Skip sync on low-confidence matches (safer). False = sync anyway with warning logged."
   )
   ```
   Default True per CONTEXT.md decision (safer behavior).

2. Add preserve_plex_edits field:
   ```python
   preserve_plex_edits: bool = Field(
       default=False,
       description="Preserve manual Plex edits. True = only update empty fields, False = Stash always wins."
   )
   ```
   Default False per CONTEXT.md decision (Stash is source of truth).

3. Update log_config() method to include new fields in logging output.

4. Add field_validator for both fields to ensure they are actual booleans (not truthy strings).

Do NOT use Pydantic StrictBool - use regular bool with explicit validator to match existing codebase pattern.
  </action>
  <verify>
python -c "from validation.config import PlexSyncConfig; c = PlexSyncConfig(plex_url='http://plex:32400', plex_token='test-token-12345'); print(f'strict_matching={c.strict_matching}, preserve_plex_edits={c.preserve_plex_edits}'); assert c.strict_matching == True; assert c.preserve_plex_edits == False; print('Config flags OK')"
  </verify>
  <done>PlexSyncConfig has strict_matching (default True) and preserve_plex_edits (default False) boolean fields</done>
</task>

</tasks>

<verification>
Run all verification commands:
```bash
# Test sync timestamp helpers
python -c "from queue.operations import load_sync_timestamps, save_sync_timestamp; import tempfile, os, shutil; d = tempfile.mkdtemp(); save_sync_timestamp(d, 123, 1000.5); save_sync_timestamp(d, 456, 2000.0); ts = load_sync_timestamps(d); assert ts[123] == 1000.5; assert ts[456] == 2000.0; shutil.rmtree(d); print('Sync timestamps: PASS')"

# Test config flags
python -c "from validation.config import PlexSyncConfig; c = PlexSyncConfig(plex_url='http://plex:32400', plex_token='test-token-12345'); assert c.strict_matching == True; assert c.preserve_plex_edits == False; print('Config flags: PASS')"

# Verify existing tests still pass
python -m pytest tests/ -v --tb=short 2>/dev/null || echo "No existing tests affected"
```
</verification>

<success_criteria>
1. queue/operations.py has load_sync_timestamps() function
2. queue/operations.py has save_sync_timestamp() function
3. Timestamps persist to {data_dir}/sync_timestamps.json
4. PlexSyncConfig has strict_matching boolean field (default True)
5. PlexSyncConfig has preserve_plex_edits boolean field (default False)
6. Existing tests pass (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/05-late-update-detection/05-01-SUMMARY.md`
</output>
