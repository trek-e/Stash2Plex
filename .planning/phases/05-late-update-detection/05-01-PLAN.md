---
phase: 05-late-update-detection
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - sync/__init__.py
  - sync/state.py
  - validation/config.py
autonomous: true

must_haves:
  truths:
    - "Sync state persists last_synced_at timestamp per scene"
    - "Config includes strict_matching and preserve_plex_edits flags"
  artifacts:
    - path: "sync/state.py"
      provides: "SyncState SQLite table operations"
      exports: ["SyncState"]
    - path: "sync/__init__.py"
      provides: "Module exports"
      exports: ["SyncState"]
    - path: "validation/config.py"
      provides: "Extended config with matching flags"
      contains: "strict_matching"
  key_links:
    - from: "sync/state.py"
      to: "SQLite database"
      via: "sqlite3.connect"
      pattern: "sqlite3\\.connect"
---

<objective>
Create sync state tracking infrastructure and extend configuration for late update detection.

Purpose: Enable timestamp-based change detection by storing last_synced_at per scene, and add config flags to control confidence-based matching behavior.

Output:
- New sync/state.py with SyncState class for tracking sync timestamps
- Extended PlexSyncConfig with strict_matching and preserve_plex_edits boolean flags
</objective>

<execution_context>
@/Users/trekkie/.claude/get-shit-done/workflows/execute-plan.md
@/Users/trekkie/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-late-update-detection/05-CONTEXT.md
@.planning/phases/05-late-update-detection/05-RESEARCH.md

# Existing config to extend
@validation/config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SyncState SQLite table for timestamp tracking</name>
  <files>sync/__init__.py, sync/state.py</files>
  <action>
Create new sync/ module with SyncState class for tracking last_synced_at timestamps.

In sync/state.py:
1. Create SyncState class with __init__(db_path: str)
2. Use sqlite3.connect() with check_same_thread=False for thread safety
3. Create table on init:
   ```sql
   CREATE TABLE IF NOT EXISTS sync_state (
       scene_id INTEGER PRIMARY KEY,
       last_synced_at REAL NOT NULL,
       last_sync_status TEXT NOT NULL,
       plex_item_key TEXT,
       updated_at REAL NOT NULL
   )
   ```
4. Implement methods:
   - update_success(scene_id: int, plex_item_key: str) - record successful sync with current time.time()
   - get_last_synced_at(scene_id: int) -> Optional[float] - return timestamp for successful syncs only
   - close() - close database connection

In sync/__init__.py:
- Export SyncState class

Follow existing patterns from queue/dlq.py for SQLite handling. Use REAL type for timestamps (sufficient precision for microseconds).
  </action>
  <verify>
python -c "from sync.state import SyncState; import tempfile, os; db = tempfile.mktemp(suffix='.db'); s = SyncState(db); s.update_success(123, '/library/123'); print(f'last_synced_at: {s.get_last_synced_at(123)}'); s.close(); os.unlink(db); print('SyncState OK')"
  </verify>
  <done>SyncState class exists with update_success() and get_last_synced_at() methods, stores timestamps in SQLite</done>
</task>

<task type="auto">
  <name>Task 2: Add strict_matching and preserve_plex_edits config flags</name>
  <files>validation/config.py</files>
  <action>
Extend PlexSyncConfig in validation/config.py with two new boolean fields:

1. Add strict_matching field:
   ```python
   strict_matching: bool = Field(
       default=True,
       description="Skip sync on low-confidence matches (safer). False = sync anyway with warning logged."
   )
   ```
   Default True per CONTEXT.md decision (safer behavior).

2. Add preserve_plex_edits field:
   ```python
   preserve_plex_edits: bool = Field(
       default=False,
       description="Preserve manual Plex edits. True = only update empty fields, False = Stash always wins."
   )
   ```
   Default False per CONTEXT.md decision (Stash is source of truth).

3. Update log_config() method to include new fields in logging output.

4. Add field_validator for both fields to ensure they are actual booleans (not truthy strings).

Do NOT use Pydantic StrictBool - use regular bool with explicit validator to match existing codebase pattern.
  </action>
  <verify>
python -c "from validation.config import PlexSyncConfig; c = PlexSyncConfig(plex_url='http://plex:32400', plex_token='test-token-12345'); print(f'strict_matching={c.strict_matching}, preserve_plex_edits={c.preserve_plex_edits}'); assert c.strict_matching == True; assert c.preserve_plex_edits == False; print('Config flags OK')"
  </verify>
  <done>PlexSyncConfig has strict_matching (default True) and preserve_plex_edits (default False) boolean fields</done>
</task>

</tasks>

<verification>
Run all verification commands:
```bash
# Test SyncState
python -c "from sync.state import SyncState; import tempfile, os; db = tempfile.mktemp(suffix='.db'); s = SyncState(db); s.update_success(123, '/library/123'); assert s.get_last_synced_at(123) is not None; assert s.get_last_synced_at(999) is None; s.close(); os.unlink(db); print('SyncState: PASS')"

# Test config flags
python -c "from validation.config import PlexSyncConfig; c = PlexSyncConfig(plex_url='http://plex:32400', plex_token='test-token-12345'); assert c.strict_matching == True; assert c.preserve_plex_edits == False; print('Config flags: PASS')"

# Verify existing tests still pass
python -m pytest tests/ -v --tb=short 2>/dev/null || echo "No existing tests affected"
```
</verification>

<success_criteria>
1. sync/state.py exists with SyncState class
2. SyncState.update_success() stores timestamp in SQLite
3. SyncState.get_last_synced_at() retrieves timestamp for successful syncs
4. PlexSyncConfig has strict_matching boolean field (default True)
5. PlexSyncConfig has preserve_plex_edits boolean field (default False)
6. Existing tests pass (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/05-late-update-detection/05-01-SUMMARY.md`
</output>
