---
phase: 14-gap-detection-engine
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - reconciliation/__init__.py
  - reconciliation/detector.py
  - tests/reconciliation/__init__.py
  - tests/reconciliation/test_detector.py
autonomous: true

must_haves:
  truths:
    - "Empty metadata detector identifies scenes where Plex has no meaningful metadata but Stash does"
    - "Stale sync detector identifies scenes where Stash updated_at is newer than sync_timestamps entry"
    - "Missing item detector identifies scenes with no recorded sync and no Plex match"
    - "Detector skips scenes where sync timestamp is newer than Stash updated_at (intentional empty per LOCKED decision)"
    - "Detector handles edge cases: no sync timestamps file, empty Stash library, scenes without files"
  artifacts:
    - path: "reconciliation/detector.py"
      provides: "GapDetector class with detect_empty, detect_stale, detect_missing methods"
      min_lines: 120
    - path: "reconciliation/__init__.py"
      provides: "Package init with exports"
    - path: "tests/reconciliation/test_detector.py"
      provides: "Unit tests for all three gap detection types"
      min_lines: 150
  key_links:
    - from: "reconciliation/detector.py"
      to: "hooks/handlers.py"
      via: "Same meaningful metadata gate logic (studio/performers/tags/details/date)"
      pattern: "any.*studio.*performers.*tags.*details.*date"
---

<objective>
Build the gap detection engine core: a GapDetector class with three detection methods (empty metadata, stale sync, missing items) using TDD.

Purpose: This is the foundation of Phase 14. The detector is pure business logic with defined inputs/outputs -- it takes scene data dicts, sync timestamps, and Plex item metadata and returns lists of gap results. No external API calls in this plan; all dependencies are injected as data.

Output: Working, fully tested GapDetector class in `reconciliation/detector.py`.
</objective>

<execution_context>
@/Users/trekkie/.claude/get-shit-done/workflows/execute-plan.md
@/Users/trekkie/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-gap-detection-engine/14-CONTEXT.md
@hooks/handlers.py
@sync_queue/operations.py
@tests/conftest.py
</context>

<feature>
  <name>GapDetector - Three-type metadata gap detection</name>
  <files>reconciliation/detector.py, tests/reconciliation/test_detector.py</files>
  <behavior>
    The GapDetector class provides three detection methods that operate on pre-fetched data (no API calls):

    **1. detect_empty_metadata(stash_scenes, plex_items_metadata) -> list[GapResult]**
    - Input: list of Stash scene dicts (from GQL), dict mapping file_path -> plex metadata dict (with studio/performers/tags/details/date fields)
    - A scene is an "empty metadata gap" when:
      - The Plex item exists (matched by file path) AND
      - The Plex item lacks ALL of: studio, performers (actors), tags (genres), details (summary), date AND
      - The Stash scene has at least one of those fields populated
    - This reuses the same "meaningful metadata" gate logic from handlers.py (lines 301-307) but applied to the Plex side
    - Per user decision: do NOT compare field-by-field; use the same gate (any of the 5 fields present = meaningful)

    **2. detect_stale_syncs(stash_scenes, sync_timestamps) -> list[GapResult]**
    - Input: list of Stash scene dicts (with updated_at field as ISO datetime string), dict[int, float] from sync_timestamps.json
    - A scene is a "stale sync gap" when:
      - The scene has a sync timestamp entry AND
      - The Stash scene's updated_at (converted to epoch) is newer than the sync timestamp
    - Edge case (Claude's Discretion): If sync timestamp is newer than updated_at, SKIP -- the sync already happened with current data. If the Stash fields are now empty, that was intentional (per LOCKED "missing fields clear Plex values" decision)
    - Scenes with NO sync timestamp entry are NOT stale -- they are either "missing" (never synced) or handled by detect_missing

    **3. detect_missing(stash_scenes, sync_timestamps, matched_paths) -> list[GapResult]**
    - Input: list of Stash scene dicts, sync timestamps dict, set of file paths that have known Plex matches
    - A scene is "missing" when:
      - It has NO entry in sync_timestamps (never successfully synced) AND
      - Its file path is NOT in matched_paths set (no known Plex match)
    - The lighter pre-check strategy: sync_timestamps lookup first, then matched_paths (which the caller builds from cache/matcher). The detector itself does not call the matcher -- that's Plan 02's job.
    - Per user decision: report ALL missing scenes including those where file doesn't exist in Plex library

    **GapResult dataclass:**
    - scene_id: int
    - gap_type: str ("empty_metadata" | "stale_sync" | "missing")
    - scene_data: dict (the Stash scene dict, needed for enqueue)
    - reason: str (human-readable explanation)

    **has_meaningful_metadata(data: dict) -> bool** (standalone function):
    - Returns True if data dict has any of: studio, performers, tags, details, date
    - Reusable by both the detector and any future code (extracted from the inline check in handlers.py)

    Cases for detect_empty_metadata:
    - Stash has studio+performers, Plex has none -> gap detected
    - Stash has tags only, Plex has none -> gap detected
    - Both have metadata -> no gap
    - Neither has metadata -> no gap (Stash has nothing to offer)
    - Plex has studio but no others -> no gap (Plex has meaningful metadata)
    - Stash scene has no Plex match (not in plex_items_metadata) -> skip (not an "empty" gap)

    Cases for detect_stale_syncs:
    - Stash updated_at 2026-02-10, sync_timestamp 2026-02-01 epoch -> gap (stale)
    - Stash updated_at 2026-02-01, sync_timestamp 2026-02-10 epoch -> no gap (already synced)
    - Scene not in sync_timestamps -> no gap (handled by detect_missing)
    - Stash updated_at is None/missing -> no gap (can't determine staleness)

    Cases for detect_missing:
    - Scene not in sync_timestamps, not in matched_paths -> gap (missing)
    - Scene not in sync_timestamps, but IS in matched_paths -> no gap (Plex has it, just never synced by us)
    - Scene in sync_timestamps -> no gap (was synced before)
    - Scene has no files -> skip (nothing to match)
  </behavior>
  <implementation>
    1. Create reconciliation/__init__.py with package exports
    2. Create reconciliation/detector.py with:
       - GapResult dataclass (scene_id, gap_type, scene_data, reason)
       - has_meaningful_metadata(data: dict) -> bool standalone function
       - GapDetector class with detect_empty_metadata, detect_stale_syncs, detect_missing methods
       - All methods return list[GapResult]
       - detect_stale_syncs must parse ISO datetime strings (Stash returns "2026-02-10T12:00:00Z" format)
       - Use datetime.fromisoformat for parsing (with Z -> +00:00 replacement, matching existing pattern in Stash2Plex.py line 871)
    3. Create tests/reconciliation/__init__.py
    4. Create tests/reconciliation/test_detector.py with comprehensive tests covering all cases above
    5. Ensure 80% coverage threshold is maintained: run pytest --cov --cov-fail-under=80
  </implementation>
</feature>

<verification>
```bash
# Tests pass
cd /Users/trekkie/projects/PlexSync && python -m pytest tests/reconciliation/test_detector.py -v

# Full test suite still passes
cd /Users/trekkie/projects/PlexSync && python -m pytest --cov --cov-fail-under=80

# Module imports correctly
cd /Users/trekkie/projects/PlexSync && python -c "from reconciliation.detector import GapDetector, GapResult, has_meaningful_metadata; print('OK')"
```
</verification>

<success_criteria>
- GapDetector.detect_empty_metadata correctly identifies scenes where Plex has no meaningful metadata but Stash does
- GapDetector.detect_stale_syncs correctly identifies scenes with Stash updated_at newer than sync timestamp
- GapDetector.detect_missing correctly identifies scenes with no sync history and no known Plex match
- has_meaningful_metadata function works identically to the inline check in handlers.py
- Edge case: scenes with sync timestamp newer than updated_at are skipped (intentional clear)
- Edge case: scenes without files are skipped
- All tests pass, 80% coverage maintained
</success_criteria>

<output>
After completion, create `.planning/phases/14-gap-detection-engine/14-01-SUMMARY.md`
</output>
