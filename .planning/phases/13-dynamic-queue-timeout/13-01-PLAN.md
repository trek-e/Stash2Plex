---
phase: 13-dynamic-queue-timeout
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - worker/stats.py
  - Stash2Plex.py
autonomous: true

must_haves:
  truths:
    - "Timeout calculation uses measured average processing time when available"
    - "Cold start (no history) uses conservative default estimate"
    - "Timeout is clamped between 30s minimum and 600s maximum"
    - "Timeout message guides users to Process Queue when queue not fully processed"
  artifacts:
    - path: "worker/stats.py"
      provides: "get_estimated_timeout() method for dynamic timeout calculation"
      contains: "def get_estimated_timeout"
    - path: "Stash2Plex.py"
      provides: "Dynamic timeout using SyncStats, improved timeout message"
      contains: "get_estimated_timeout"
  key_links:
    - from: "Stash2Plex.py"
      to: "worker/stats.py"
      via: "SyncStats.get_estimated_timeout() call"
      pattern: "stats\\.get_estimated_timeout|SyncStats\\.load_from_file"
---

<objective>
Implement dynamic queue timeout calculation based on measured processing times

Purpose: Replace the crude `initial_size * 2` timeout formula with actual measured average processing time from SyncStats. This provides more accurate timeout estimates and better user experience when processing large queues.

Output:
- SyncStats extended with get_estimated_timeout() method
- Stash2Plex.py using dynamic timeout from stats
- Improved timeout message guiding to Process Queue task
</objective>

<execution_context>
@/Users/trekkie/.claude/get-shit-done/workflows/execute-plan.md
@/Users/trekkie/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-dynamic-queue-timeout/13-RESEARCH.md

# Source files to modify
@worker/stats.py
@Stash2Plex.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add get_estimated_timeout method to SyncStats</name>
  <files>worker/stats.py</files>
  <action>
Add a class constant and method to SyncStats:

1. Add constant at class level (after docstring):
   ```python
   DEFAULT_TIME_PER_ITEM: float = 2.0  # Conservative default for cold start
   ```

2. Add method after avg_processing_time property:
   ```python
   def get_estimated_timeout(
       self,
       item_count: int,
       buffer_factor: float = 1.5,
       min_timeout: float = 30.0,
       max_timeout: float = 600.0
   ) -> float:
       """
       Calculate estimated timeout for processing item_count items.

       Uses avg_processing_time if available (jobs_processed >= 5),
       otherwise falls back to DEFAULT_TIME_PER_ITEM. Applies buffer_factor
       for safety margin and clamps result to [min_timeout, max_timeout].

       Args:
           item_count: Number of items to process
           buffer_factor: Multiplier for safety margin (default 1.5 = 50% buffer)
           min_timeout: Minimum timeout in seconds (default 30.0)
           max_timeout: Maximum timeout in seconds (default 600.0)

       Returns:
           Calculated timeout in seconds
       """
       # Use measured average if we have sufficient sample size
       if self.jobs_processed >= 5:
           time_per_item = self.avg_processing_time
       elif self.jobs_processed > 0:
           # Blend measured with default for small samples
           weight = self.jobs_processed / 5.0
           time_per_item = (weight * self.avg_processing_time) + ((1 - weight) * self.DEFAULT_TIME_PER_ITEM)
       else:
           time_per_item = self.DEFAULT_TIME_PER_ITEM

       estimated = item_count * time_per_item * buffer_factor
       return max(min_timeout, min(estimated, max_timeout))
   ```

This handles:
- Cold start: No jobs processed -> uses 2.0s default
- Small sample: 1-4 jobs -> blends measured with default
- Normal operation: 5+ jobs -> uses measured average
- Safety buffer: 1.5x multiplier by default
- Clamping: 30s floor, 600s ceiling
  </action>
  <verify>
Run Python to verify method exists and calculates correctly:
```bash
cd /Users/trekkie/projects/PlexSync && python3 -c "
from worker.stats import SyncStats

# Test cold start
s1 = SyncStats()
assert s1.get_estimated_timeout(10) == 30.0, 'Cold start: 10 items should hit min (10*2*1.5=30)'
assert s1.get_estimated_timeout(100) == 300.0, 'Cold start: 100 items (100*2*1.5=300)'
assert s1.get_estimated_timeout(300) == 600.0, 'Cold start: 300 items should hit max (300*2*1.5=900->600)'

# Test with history
s2 = SyncStats(jobs_processed=10, total_processing_time=10.0)  # 1.0s avg
assert 15 <= s2.get_estimated_timeout(10) <= 30, 'With history: 10 items at 1s (10*1*1.5=15->30 min)'

print('All timeout calculation tests passed')
"
```
  </verify>
  <done>SyncStats has get_estimated_timeout() method that returns dynamic timeout based on measured average or default, with proper clamping</done>
</task>

<task type="auto">
  <name>Task 2: Use dynamic timeout and improve message in Stash2Plex.py</name>
  <files>Stash2Plex.py</files>
  <action>
Modify the timeout calculation section (around lines 847-876) in the scene_hook processing:

1. Load stats from the standard stats file location (data_dir/stats.json):
   - Import SyncStats at top of file if not already imported
   - Load stats using SyncStats.load_from_file() before timeout calculation

2. Replace the static formula:
   ```python
   # OLD (remove):
   # max_wait = max(30, min(initial_size * 2, 600))

   # NEW:
   from worker.stats import SyncStats
   stats_path = os.path.join(data_dir, 'stats.json')
   stats = SyncStats.load_from_file(stats_path)
   max_wait = stats.get_estimated_timeout(initial_size)
   ```

3. Calculate time_per_item for the improved message:
   ```python
   time_per_item = stats.avg_processing_time if stats.jobs_processed >= 5 else stats.DEFAULT_TIME_PER_ITEM
   ```

4. Improve the timeout warning message (around line 876):
   ```python
   # OLD (remove):
   # log_warn(f"Timeout after {max_wait}s ({queue.size} items remaining - run 'Sync Recent' task to continue)")

   # NEW:
   remaining = queue.size
   estimated_remaining_time = remaining * time_per_item
   log_warn(
       f"Timeout after {max_wait:.0f}s with {remaining} items remaining "
       f"(est. {estimated_remaining_time:.0f}s more needed). "
       f"Run 'Process Queue' task to continue without timeout limits."
   )
   ```

5. Add info log showing the timeout basis:
   ```python
   if initial_size > 0:
       if stats.jobs_processed >= 5:
           log_info(f"Processing {initial_size} queued item(s), timeout {max_wait:.0f}s (based on {stats.avg_processing_time:.2f}s/item avg)")
       else:
           log_info(f"Processing {initial_size} queued item(s), timeout {max_wait:.0f}s (using default estimate)")
   ```

Key changes:
- Uses measured avg_processing_time when available
- Falls back to conservative 2.0s default for cold start
- Improved timeout message mentions "Process Queue" instead of "Sync Recent"
- Shows estimated remaining time in timeout message
  </action>
  <verify>
1. Verify syntax is correct:
```bash
cd /Users/trekkie/projects/PlexSync && python3 -m py_compile Stash2Plex.py && echo "Syntax OK"
```

2. Verify the new imports and patterns exist:
```bash
cd /Users/trekkie/projects/PlexSync && grep -n "get_estimated_timeout\|Process Queue" Stash2Plex.py
```

3. Verify the old static formula is removed:
```bash
cd /Users/trekkie/projects/PlexSync && grep -c "initial_size \* 2" Stash2Plex.py | grep -q "^0$" && echo "Old formula removed" || echo "ERROR: Old formula still present"
```
  </verify>
  <done>
- Stash2Plex.py uses SyncStats.get_estimated_timeout() for dynamic timeout
- Timeout message guides users to Process Queue task
- Old static formula removed
- Logs show whether using measured average or default estimate
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Code compiles:**
   ```bash
   python3 -m py_compile worker/stats.py Stash2Plex.py
   ```

2. **Method exists and works:**
   ```bash
   python3 -c "from worker.stats import SyncStats; s = SyncStats(); print(f'Default timeout for 50 items: {s.get_estimated_timeout(50):.0f}s')"
   ```

3. **Integration pattern present:**
   ```bash
   grep -l "get_estimated_timeout" Stash2Plex.py worker/stats.py | wc -l
   # Should output: 2
   ```

4. **Process Queue mentioned in timeout message:**
   ```bash
   grep "Process Queue" Stash2Plex.py
   ```

5. **Requirements coverage:**
   - TIME-01: SyncStats already tracks avg time (existing), get_estimated_timeout uses it
   - TIME-02: get_estimated_timeout calculates items x avg_time x buffer
   - TIME-03: N/A (Stash doesn't expose timeout limits - confirmed by research)
   - TIME-04: max_timeout=600 handles Stash limit cap
   - TIME-05: Timeout message guides to Process Queue for fallback
</verification>

<success_criteria>
- [ ] SyncStats.get_estimated_timeout() method exists and calculates correctly
- [ ] Cold start returns conservative estimate (uses 2.0s default)
- [ ] With history, uses measured avg_processing_time
- [ ] Timeout clamped between 30s and 600s
- [ ] Stash2Plex.py uses get_estimated_timeout() instead of static formula
- [ ] Timeout message mentions "Process Queue" for continuation
- [ ] All Python files compile without errors
</success_criteria>

<output>
After completion, create `.planning/phases/13-dynamic-queue-timeout/13-01-SUMMARY.md`
</output>
