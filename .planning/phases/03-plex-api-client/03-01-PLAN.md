---
phase: 03-plex-api-client
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - plex/__init__.py
  - plex/exceptions.py
  - validation/config.py
autonomous: true

must_haves:
  truths:
    - "Plex API errors can be classified as temporary or permanent"
    - "PlexNotFound is distinct from other temporary errors"
    - "Config has explicit timeout settings with sensible defaults"
  artifacts:
    - path: "plex/exceptions.py"
      provides: "Plex exception hierarchy"
      exports: ["PlexTemporaryError", "PlexPermanentError", "PlexNotFound", "translate_plex_exception"]
    - path: "plex/__init__.py"
      provides: "Module initialization"
      min_lines: 5
    - path: "validation/config.py"
      provides: "Extended config with timeouts"
      contains: "plex_connect_timeout"
  key_links:
    - from: "plex/exceptions.py"
      to: "worker/processor.py"
      via: "subclassing TransientError/PermanentError"
      pattern: "class Plex.*\\(TransientError\\)|class Plex.*\\(PermanentError\\)"
---

<objective>
Create the Plex exception hierarchy and extend configuration with timeout settings.

Purpose: Establish the foundation for Plex API error handling that integrates with Phase 2's error classification, and make timeouts configurable (not hardcoded).

Output: plex/exceptions.py with PlexTemporaryError, PlexPermanentError, PlexNotFound classes and translate_plex_exception function. PlexSyncConfig extended with plex_connect_timeout and plex_read_timeout fields.
</objective>

<execution_context>
@/Users/trekkie/.claude/get-shit-done/workflows/execute-plan.md
@/Users/trekkie/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-plex-api-client/03-CONTEXT.md
@.planning/phases/03-plex-api-client/03-RESEARCH.md
@worker/processor.py
@validation/config.py
@validation/errors.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Plex exception hierarchy</name>
  <files>plex/__init__.py, plex/exceptions.py</files>
  <action>
Create plex/ module directory with __init__.py and exceptions.py.

In plex/exceptions.py:
1. Import TransientError, PermanentError from worker.processor
2. Create PlexTemporaryError(TransientError) - for retry-able errors (network, timeout, 5xx, rate limits)
3. Create PlexPermanentError(PermanentError) - for non-retry-able errors (auth, bad request)
4. Create PlexNotFound(TransientError) - distinct class for "item not in Plex library" which may appear after library scan
5. Create translate_plex_exception(exc: Exception) -> Exception function that:
   - Handles plexapi.exceptions (Unauthorized -> Permanent, NotFound -> PlexNotFound, BadRequest -> Permanent)
   - Handles requests.exceptions (ConnectionError, Timeout -> Temporary)
   - Handles HTTP status codes via hasattr(exc, 'response')
   - Returns PlexTemporaryError for unknown errors (safer default, consistent with Phase 2)

In plex/__init__.py:
1. Export PlexTemporaryError, PlexPermanentError, PlexNotFound, translate_plex_exception
2. Add module docstring

Use the pattern from 03-RESEARCH.md "Exception Translation from PlexAPI to Phase 2 Hierarchy" section.
  </action>
  <verify>
python -c "from plex.exceptions import PlexTemporaryError, PlexPermanentError, PlexNotFound, translate_plex_exception; from worker.processor import TransientError, PermanentError; assert issubclass(PlexTemporaryError, TransientError); assert issubclass(PlexPermanentError, PermanentError); assert issubclass(PlexNotFound, TransientError); print('OK')"
  </verify>
  <done>
PlexTemporaryError/PlexPermanentError/PlexNotFound classes exist and properly subclass Phase 2 base classes. translate_plex_exception function handles plexapi and requests exceptions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend PlexSyncConfig with timeout settings</name>
  <files>validation/config.py</files>
  <action>
Extend PlexSyncConfig in validation/config.py with timeout fields:

1. Add plex_connect_timeout: float = Field(default=5.0, ge=1.0, le=30.0) - connect timeout in seconds
2. Add plex_read_timeout: float = Field(default=30.0, ge=5.0, le=120.0) - read timeout in seconds

These are optional tunables with sensible defaults (5s connect, 30s read) as recommended in 03-RESEARCH.md.

Update log_config() method to include the new timeout fields in the logged output.

Note: ge/le constraints prevent unreasonable values (too short causes failures, too long defeats purpose).
  </action>
  <verify>
python -c "from validation.config import PlexSyncConfig; c = PlexSyncConfig(plex_url='http://localhost:32400', plex_token='xxxx1234xxxx'); assert c.plex_connect_timeout == 5.0; assert c.plex_read_timeout == 30.0; print('OK')"
  </verify>
  <done>
PlexSyncConfig has plex_connect_timeout and plex_read_timeout fields with defaults of 5.0s and 30.0s respectively.
  </done>
</task>

</tasks>

<verification>
All verification commands must pass:
1. Plex exceptions import and subclass correctly
2. Config timeout fields have correct defaults
3. No import errors or circular dependencies
</verification>

<success_criteria>
- plex/exceptions.py exists with 3 exception classes + translate function
- plex/__init__.py exports the exception module public API
- PlexSyncConfig has plex_connect_timeout (default 5.0) and plex_read_timeout (default 30.0)
- All exception classes properly subclass TransientError or PermanentError
- translate_plex_exception handles plexapi and requests exceptions
</success_criteria>

<output>
After completion, create `.planning/phases/03-plex-api-client/03-01-SUMMARY.md`
</output>
