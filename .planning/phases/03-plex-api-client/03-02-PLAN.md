---
phase: 03-plex-api-client
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - plex/client.py
  - plex/matcher.py
  - plex/__init__.py
autonomous: true

must_haves:
  truths:
    - "PlexClient connects with explicit timeouts"
    - "Network blips trigger immediate retry with backoff"
    - "File path matching uses fallback strategies"
    - "Case-insensitive matching handles cross-platform paths"
  artifacts:
    - path: "plex/client.py"
      provides: "PlexClient wrapper with timeouts and retry"
      exports: ["PlexClient"]
      min_lines: 40
    - path: "plex/matcher.py"
      provides: "File path matching logic"
      exports: ["find_plex_item_by_path"]
      min_lines: 30
  key_links:
    - from: "plex/client.py"
      to: "plexapi.server.PlexServer"
      via: "constructor with timeout parameter"
      pattern: "PlexServer\\(.*timeout="
    - from: "plex/client.py"
      to: "tenacity"
      via: "@retry decorator"
      pattern: "@retry\\("
    - from: "plex/matcher.py"
      to: "plexapi library search"
      via: "Media__Part__file operators"
      pattern: "Media__Part__file"
---

<objective>
Create the PlexClient wrapper with timeout configuration and tenacity retry, plus the file path matcher with fallback strategies.

Purpose: Implement reliable Plex communication that never hangs (explicit timeouts), handles network blips (tenacity retry), and finds Plex items even when paths differ between Stash and Plex.

Output: plex/client.py with PlexClient class, plex/matcher.py with find_plex_item_by_path function.
</objective>

<execution_context>
@/Users/trekkie/.claude/get-shit-done/workflows/execute-plan.md
@/Users/trekkie/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-plex-api-client/03-CONTEXT.md
@.planning/phases/03-plex-api-client/03-RESEARCH.md
@plex/exceptions.py
@validation/config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PlexClient wrapper with timeouts and retry</name>
  <files>plex/client.py</files>
  <action>
Create plex/client.py with PlexClient class:

1. Import dependencies:
   - from plexapi.server import PlexServer
   - from tenacity import retry, retry_if_exception_type, wait_exponential_jitter, stop_after_attempt, before_sleep_log
   - import requests.exceptions
   - import logging
   - from plex.exceptions import PlexTemporaryError, PlexPermanentError, translate_plex_exception

2. Define RETRIABLE_EXCEPTIONS tuple:
   (ConnectionError, TimeoutError, OSError, requests.exceptions.ConnectionError, requests.exceptions.Timeout)

3. Create PlexClient class:
   - __init__(self, url: str, token: str, connect_timeout: float = 5.0, read_timeout: float = 30.0)
   - Store config, create PlexServer lazily (not in __init__)
   - _get_server() method with @retry decorator for connection errors:
     @retry(
       retry=retry_if_exception_type(RETRIABLE_EXCEPTIONS),
       wait=wait_exponential_jitter(initial=0.1, max=0.4, jitter=0.1),
       stop=stop_after_attempt(3),
       before_sleep=before_sleep_log(logger, logging.WARNING),
       reraise=True
     )
   - server property that returns cached PlexServer or calls _get_server()
   - get_library(section_name: str) method to get a library section by name

4. Use PlexServer(baseurl=url, token=token, timeout=read_timeout) for connection
   Note: PlexAPI uses single timeout value, not tuple. Use read_timeout as the primary timeout.

5. Wrap PlexAPI exceptions with translate_plex_exception in a try/except block

Follow patterns from 03-RESEARCH.md "PlexServer Connection with Timeout" and "Tenacity Retry" sections.
  </action>
  <verify>
python -c "from plex.client import PlexClient, RETRIABLE_EXCEPTIONS; assert ConnectionError in RETRIABLE_EXCEPTIONS; print('OK')"
  </verify>
  <done>
PlexClient class exists with timeout configuration, @retry decorator for connection errors, and lazy PlexServer initialization.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create file path matcher with fallback strategies</name>
  <files>plex/matcher.py</files>
  <action>
Create plex/matcher.py with find_plex_item_by_path function:

1. Import dependencies:
   - from pathlib import Path
   - from typing import Optional
   - import logging
   - Type hints for plexapi types (use TYPE_CHECKING block)

2. Create find_plex_item_by_path function:
   def find_plex_item_by_path(
       library,  # LibrarySection
       stash_path: str,
       plex_path_prefix: Optional[str] = None,
       stash_path_prefix: Optional[str] = None
   ) -> Optional[any]:

3. Implement 3-strategy matching (from 03-RESEARCH.md):
   Strategy 1: Exact path match
   - Apply path prefix mapping if both prefixes provided
   - library.search(Media__Part__file=search_path)
   - Return first result if found

   Strategy 2: Filename-only match
   - Extract filename with Path(stash_path).name
   - library.search(Media__Part__file__endswith=f"/{filename}")
   - Return if exactly 1 result (avoid ambiguity)

   Strategy 3: Case-insensitive filename
   - library.search(Media__Part__file__iendswith=f"/{filename.lower()}")
   - Return if exactly 1 result

4. Log which strategy succeeded (debug level)
5. Log warning if multiple matches found (ambiguous)
6. Return None if no match

Follow pattern from 03-RESEARCH.md "File Path Matching with PlexAPI Operators" section.
  </action>
  <verify>
python -c "from plex.matcher import find_plex_item_by_path; print('OK')"
  </verify>
  <done>
find_plex_item_by_path function exists with 3 fallback matching strategies: exact path, filename-only, case-insensitive.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update plex module exports</name>
  <files>plex/__init__.py</files>
  <action>
Update plex/__init__.py to export the new modules:

1. Add imports:
   - from plex.client import PlexClient
   - from plex.matcher import find_plex_item_by_path

2. Add to __all__ list:
   - "PlexClient"
   - "find_plex_item_by_path"

Keep existing exception exports from 03-01.
  </action>
  <verify>
python -c "from plex import PlexClient, find_plex_item_by_path, PlexTemporaryError, PlexPermanentError, PlexNotFound; print('OK')"
  </verify>
  <done>
plex module exports PlexClient, find_plex_item_by_path, and all exception classes.
  </done>
</task>

</tasks>

<verification>
All verification commands must pass:
1. PlexClient imports correctly with RETRIABLE_EXCEPTIONS
2. find_plex_item_by_path imports correctly
3. plex module exports all public API
4. No import errors or circular dependencies
</verification>

<success_criteria>
- plex/client.py exists with PlexClient class using timeout and @retry
- plex/matcher.py exists with find_plex_item_by_path using 3 strategies
- plex/__init__.py exports PlexClient, find_plex_item_by_path, and exceptions
- @retry decorator configured for connection errors only (100ms initial, 400ms max, 3 attempts)
- Path matching handles exact, filename-only, and case-insensitive strategies
</success_criteria>

<output>
After completion, create `.planning/phases/03-plex-api-client/03-02-SUMMARY.md`
</output>
