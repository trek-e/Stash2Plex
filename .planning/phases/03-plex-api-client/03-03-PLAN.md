---
phase: 03-plex-api-client
plan: 03
type: execute
wave: 3
depends_on: ["03-02"]
files_modified:
  - worker/processor.py
autonomous: true

must_haves:
  truths:
    - "Worker uses PlexClient to connect to Plex"
    - "Worker uses find_plex_item_by_path to locate items"
    - "Plex errors are translated to TransientError/PermanentError hierarchy"
    - "_process_job is no longer a stub"
  artifacts:
    - path: "worker/processor.py"
      provides: "Worker with real Plex integration"
      contains: "PlexClient"
      min_lines: 100
  key_links:
    - from: "worker/processor.py"
      to: "plex/client.py"
      via: "import and instantiation"
      pattern: "from plex.client import PlexClient|from plex import PlexClient"
    - from: "worker/processor.py"
      to: "plex/matcher.py"
      via: "find_plex_item_by_path call"
      pattern: "find_plex_item_by_path\\("
    - from: "worker/processor.py"
      to: "plex/exceptions.py"
      via: "exception handling"
      pattern: "PlexNotFound|PlexTemporaryError|PlexPermanentError"
---

<objective>
Wire the PlexClient and matcher into the worker processor, replacing the Phase 1 stub with real Plex integration.

Purpose: Connect all the Phase 3 components so that the worker can actually sync metadata to Plex when processing jobs from the queue.

Output: Updated worker/processor.py with real _process_job implementation using PlexClient and find_plex_item_by_path.
</objective>

<execution_context>
@/Users/trekkie/.claude/get-shit-done/workflows/execute-plan.md
@/Users/trekkie/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-plex-api-client/03-CONTEXT.md
@.planning/phases/03-plex-api-client/03-RESEARCH.md
@.planning/phases/03-plex-api-client/03-02-SUMMARY.md
@worker/processor.py
@plex/client.py
@plex/matcher.py
@plex/exceptions.py
@validation/config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire PlexClient into SyncWorker</name>
  <files>worker/processor.py</files>
  <action>
Update worker/processor.py to use PlexClient for real Plex operations:

1. Add imports at top:
   - from plex.client import PlexClient
   - from plex.matcher import find_plex_item_by_path
   - from plex.exceptions import PlexTemporaryError, PlexPermanentError, PlexNotFound, translate_plex_exception
   - from validation.config import PlexSyncConfig

2. Update SyncWorker.__init__ to accept and store config:
   - Add config: PlexSyncConfig parameter
   - Store self.config = config
   - Create self.plex_client = None (lazy initialization)

3. Add _get_plex_client() method:
   - Lazy initialization pattern
   - If self.plex_client is None:
     - Create PlexClient(
         url=self.config.plex_url,
         token=self.config.plex_token,
         connect_timeout=self.config.plex_connect_timeout,
         read_timeout=self.config.plex_read_timeout
       )
     - Store in self.plex_client
   - Return self.plex_client

4. Replace _process_job stub implementation with real logic:
   def _process_job(self, job: dict):
       """Process a sync job by updating Plex metadata."""
       scene_id = job.get('scene_id')
       update_type = job.get('update_type')
       data = job.get('data', {})
       file_path = data.get('path')

       if not file_path:
           raise PermanentError(f"Job {scene_id} missing file path")

       try:
           # Get Plex client (lazy init)
           client = self._get_plex_client()

           # Get library section (assume first library or make configurable later)
           # For now, iterate all library sections to find the item
           plex_item = None
           for section in client.server.library.sections():
               plex_item = find_plex_item_by_path(section, file_path)
               if plex_item:
                   break

           if not plex_item:
               raise PlexNotFound(f"Could not find Plex item for path: {file_path}")

           # Update metadata based on update_type
           if update_type == 'metadata':
               self._update_metadata(plex_item, data)
           else:
               print(f"[PlexSync Worker] Unknown update_type: {update_type}")

       except (PlexTemporaryError, PlexPermanentError, PlexNotFound):
           raise  # Already classified
       except Exception as e:
           # Translate unknown Plex/network errors
           raise translate_plex_exception(e)

5. Add _update_metadata helper method:
   def _update_metadata(self, plex_item, data: dict):
       """Update Plex item metadata from sync job data."""
       # Build edits dict for plex_item.edit()
       edits = {}
       if 'title' in data:
           edits['title.value'] = data['title']
       if 'studio' in data:
           edits['studio.value'] = data['studio']
       # Add more fields as needed

       if edits:
           plex_item.edit(**edits)
           plex_item.reload()
           print(f"[PlexSync Worker] Updated metadata for: {plex_item.title}")

Note: Keep TransientError and PermanentError class definitions at module level (they're imported by other modules).
  </action>
  <verify>
python -c "from worker.processor import SyncWorker; import inspect; sig = inspect.signature(SyncWorker.__init__); assert 'config' in sig.parameters; print('OK')"
  </verify>
  <done>
SyncWorker accepts config parameter, creates PlexClient lazily, and _process_job performs real Plex operations using find_plex_item_by_path and metadata updates.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add integration smoke test</name>
  <files>tests/test_plex_integration.py</files>
  <action>
Create tests/test_plex_integration.py with unit tests that mock PlexAPI:

1. Test PlexClient initialization (mock PlexServer)
2. Test find_plex_item_by_path with mocked library
3. Test exception translation
4. Test SyncWorker._process_job with mocked client

Use unittest.mock to avoid requiring real Plex server.

Example structure:
```python
import unittest
from unittest.mock import Mock, patch, MagicMock
from plex.client import PlexClient
from plex.matcher import find_plex_item_by_path
from plex.exceptions import PlexNotFound, translate_plex_exception

class TestPlexClient(unittest.TestCase):
    @patch('plex.client.PlexServer')
    def test_client_uses_timeout(self, mock_server):
        client = PlexClient('http://localhost:32400', 'token123', read_timeout=60)
        _ = client.server
        mock_server.assert_called_once()
        call_kwargs = mock_server.call_args.kwargs
        assert call_kwargs.get('timeout') == 60

class TestMatcher(unittest.TestCase):
    def test_exact_match(self):
        mock_library = Mock()
        mock_item = Mock()
        mock_library.search.return_value = [mock_item]
        result = find_plex_item_by_path(mock_library, '/path/to/file.mp4')
        assert result == mock_item

    def test_no_match_returns_none(self):
        mock_library = Mock()
        mock_library.search.return_value = []
        result = find_plex_item_by_path(mock_library, '/nonexistent.mp4')
        assert result is None
```
  </action>
  <verify>
python -m pytest tests/test_plex_integration.py -v --tb=short 2>/dev/null || python -m unittest tests.test_plex_integration -v
  </verify>
  <done>
Integration tests exist and pass with mocked PlexAPI, verifying client timeout usage and matcher behavior.
  </done>
</task>

</tasks>

<verification>
All verification commands must pass:
1. SyncWorker accepts config parameter
2. Integration tests pass
3. No import errors
4. Worker can be instantiated with PlexSyncConfig
</verification>

<success_criteria>
- worker/processor.py imports and uses PlexClient and find_plex_item_by_path
- SyncWorker.__init__ accepts PlexSyncConfig parameter
- _process_job is no longer a stub - it finds Plex items and updates metadata
- Exception handling translates Plex errors to TransientError/PermanentError hierarchy
- Integration tests verify client and matcher behavior with mocks
</success_criteria>

<output>
After completion, create `.planning/phases/03-plex-api-client/03-03-SUMMARY.md`
</output>
