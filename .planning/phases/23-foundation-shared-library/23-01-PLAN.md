---
phase: 23-foundation-shared-library
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - shared_lib/__init__.py
  - shared_lib/path_mapper.py
  - tests/shared_lib/__init__.py
  - tests/shared_lib/test_path_mapper.py
  - requirements-dev.txt
  - pytest.ini
autonomous: true
requirements:
  - PATH-01
  - PATH-02
  - INFR-01

must_haves:
  truths:
    - "PathMapper.plex_to_stash() translates a Plex path to a Stash path using regex capture groups"
    - "PathMapper.stash_to_plex() translates a Stash path to a Plex path using regex capture groups"
    - "Multiple named rules are evaluated in array order — first match wins"
    - "Returns None when no rule matches a given path"
    - "PathMapper.from_env() parses a JSON string into validated PathRule models"
    - "Backslash paths are normalized to forward slashes before matching"
    - "shared_lib package is importable from the repo root"
  artifacts:
    - path: "shared_lib/__init__.py"
      provides: "Package marker for shared_lib"
    - path: "shared_lib/path_mapper.py"
      provides: "PathRule model + PathMapper class"
      exports: ["PathRule", "PathMapper"]
      min_lines: 50
    - path: "tests/shared_lib/test_path_mapper.py"
      provides: "Test coverage for bidirectional path mapping"
      min_lines: 80
  key_links:
    - from: "shared_lib/path_mapper.py"
      to: "pydantic.BaseModel"
      via: "PathRule inherits BaseModel"
      pattern: "class PathRule\\(BaseModel\\)"
    - from: "shared_lib/path_mapper.py"
      to: "re module"
      via: "compiled regex for matching and substitution"
      pattern: "re\\.compile"
    - from: "tests/shared_lib/test_path_mapper.py"
      to: "shared_lib/path_mapper.py"
      via: "import PathMapper, PathRule"
      pattern: "from shared_lib\\.path_mapper import"
---

<objective>
Create the shared_lib package with a bidirectional regex path mapping engine and comprehensive tests using TDD.

Purpose: PATH-01 and PATH-02 require a regex-based bidirectional path mapper that supports multiple named rules in priority order. This is the core translation layer between Plex file paths and Stash scene paths. INFR-01 requires the shared_lib package to exist as an importable Python package.

Output: Working `shared_lib/path_mapper.py` with PathRule Pydantic model, PathMapper class, and full test suite proving bidirectional translation, multi-rule priority, edge cases.
</objective>

<execution_context>
@/Users/trekkie/.claude/get-shit-done/workflows/execute-plan.md
@/Users/trekkie/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/23-foundation-shared-library/23-CONTEXT.md
@.planning/phases/23-foundation-shared-library/23-RESEARCH.md
@validation/config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create shared_lib package and install dev dependencies</name>
  <files>
    shared_lib/__init__.py
    tests/shared_lib/__init__.py
    requirements-dev.txt
    pytest.ini
  </files>
  <action>
1. Create `shared_lib/__init__.py` with a docstring:
   ```python
   """
   shared_lib — Cross-service shared code for Stash2Plex v2.0.

   Importable by both the Stash plugin (via sys.path at repo root)
   and the provider service (via Docker COPY).

   NOT the same as the existing shared/ package (Stash binary logging protocol).
   """
   ```

2. Create `tests/shared_lib/__init__.py` (empty file).

3. Add to `requirements-dev.txt` (append after existing entries):
   ```
   httpx>=0.27.0
   pytest-asyncio>=0.25.0
   respx>=0.22.0
   ```

4. Update `pytest.ini`:
   - Add `--cov=shared_lib` to the addopts line (after the existing `--cov=hooks` line)
   - Add `asyncio_mode = strict` under `[pytest]` section (this requires explicit `@pytest.mark.asyncio` on async tests, does NOT affect existing sync tests)

5. Run `pip install -r requirements-dev.txt` inside the venv to install new deps.
  </action>
  <verify>
    <automated>cd /Users/trekkie/projects/Stash2Plex && source .venv/bin/activate && python -c "import shared_lib; print('shared_lib importable')" && python -c "import httpx; import respx; import pytest_asyncio; print('deps installed')"</automated>
  </verify>
  <done>shared_lib package exists and is importable. httpx, respx, pytest-asyncio installed. pytest.ini updated with shared_lib coverage and asyncio_mode.</done>
</task>

<task type="auto">
  <name>Task 2: TDD — Path mapper RED+GREEN+REFACTOR</name>
  <files>
    shared_lib/path_mapper.py
    tests/shared_lib/test_path_mapper.py
  </files>
  <action>
**This is a TDD task. Follow RED -> GREEN -> REFACTOR strictly.**

**RED phase — Write failing tests first in `tests/shared_lib/test_path_mapper.py`:**

Test cases to cover (import `PathRule` and `PathMapper` from `shared_lib.path_mapper`):

1. **test_plex_to_stash_simple_prefix_swap** — Rule: plex_pattern=`^/plex/media/(.*)`, stash_pattern=`/stash/media/\1`. Input: `/plex/media/video.mkv` -> Output: `/stash/media/video.mkv`

2. **test_stash_to_plex_simple_prefix_swap** — Reverse of above. Input: `/stash/media/video.mkv` -> Output: `/plex/media/video.mkv`

3. **test_plex_to_stash_nested_path** — Same rule. Input: `/plex/media/dir/subdir/file.mp4` -> Output: `/stash/media/dir/subdir/file.mp4`

4. **test_no_match_returns_none** — Rule only matches `/plex/media/`. Input: `/other/path/file.mkv` -> Returns None

5. **test_multiple_rules_first_match_wins** — Two rules: rule_a matches `/plex/nas/(.*)` -> `/stash/nas/\1`, rule_b matches `/plex/local/(.*)` -> `/stash/local/\1`. Input: `/plex/nas/file.mkv` -> matches rule_a (not rule_b). Input: `/plex/local/file.mkv` -> matches rule_b.

6. **test_multiple_rules_priority_order** — Two rules that could BOTH match: rule_a=`^/media/(.*)` -> `/stash_a/\1`, rule_b=`^/media/special/(.*)` -> `/stash_b/\1`. Input: `/media/special/file.mkv` matches rule_a first (first-match-wins). Assert result is `/stash_a/special/file.mkv` (NOT `/stash_b/file.mkv`).

7. **test_backslash_normalization** — Input with backslashes: `\\plex\\media\\file.mkv` with plex_pattern=`^/plex/media/(.*)`. Backslashes normalized to forward slashes before matching.

8. **test_case_insensitive_flag** — Rule with `case_insensitive=True`. Input: `/PLEX/Media/FILE.mkv` matches pattern `/plex/media/(.*)`.

9. **test_case_sensitive_default** — Rule without case_insensitive flag (default False). Input: `/PLEX/media/file.mkv` does NOT match `/plex/media/(.*)`. Returns None.

10. **test_from_env_parses_json** — `PathMapper.from_env('[{"name":"nas","plex_pattern":"^/plex/(.*)","stash_pattern":"/stash/\\\\1"}]')` creates a PathMapper with 1 rule. Verify with a plex_to_stash call. Note: JSON `\\\\1` becomes Python string `\\1` which re.sub interprets as group 1.

11. **test_from_env_empty_array** — `PathMapper.from_env('[]')` creates a mapper with 0 rules. All paths return None.

12. **test_from_env_invalid_json_raises** — `PathMapper.from_env('not json')` raises ValueError or json.JSONDecodeError.

13. **test_bidirectional_roundtrip** — plex_to_stash then stash_to_plex returns the original path.

Commit after RED: `test(23-01): add failing tests for bidirectional path mapper`

**GREEN phase — Implement `shared_lib/path_mapper.py`:**

Follow the architecture pattern from 23-RESEARCH.md exactly:

- `PathRule(BaseModel)` with fields: `name: str`, `plex_pattern: str`, `stash_pattern: str`, `case_insensitive: bool = False`
- `PathMapper` class:
  - `__init__(self, rules: list[PathRule])` — pre-compile regexes at init (`re.compile` with `re.IGNORECASE` flag when `case_insensitive=True`)
  - `_normalize(self, path: str) -> str` — replace backslashes with forward slashes
  - `plex_to_stash(self, plex_path: str) -> Optional[str]` — iterate rules, first match wins, use `re.sub(plex_compiled, rule.stash_pattern, normalized_path, count=1)` for substitution. Debug-level log on match, info-level log on miss.
  - `stash_to_plex(self, stash_path: str) -> Optional[str]` — same logic in reverse direction using stash_compiled patterns
  - `from_env(cls, env_value: str) -> PathMapper` — classmethod, json.loads + PathRule validation
- Use `logging.getLogger("shared_lib.path_mapper")` for the logger

IMPORTANT: Use `count=1` in `re.sub()` to replace only the first match (per Pitfall 2 in research). Use `re.match()` to check if the pattern matches at string start, then `re.sub()` with `count=1` for the actual substitution.

Commit after GREEN: `feat(23-01): implement bidirectional path mapper`

**REFACTOR phase (if needed):** Clean up, ensure docstrings are clear. Run all tests again.

Commit after REFACTOR: `refactor(23-01): clean up path mapper`
  </action>
  <verify>
    <automated>cd /Users/trekkie/projects/Stash2Plex && source .venv/bin/activate && python -m pytest tests/shared_lib/test_path_mapper.py -v --no-header --tb=short -p no:cacheprovider</automated>
  </verify>
  <done>All 13 path mapper tests pass. PathMapper correctly translates bidirectionally with multiple rules in priority order. Backslash normalization and case-insensitive flags work. from_env parses JSON and validates with Pydantic.</done>
</task>

</tasks>

<verification>
1. `python -c "from shared_lib.path_mapper import PathMapper, PathRule; print('imports work')"` succeeds
2. `python -m pytest tests/shared_lib/test_path_mapper.py -v` — all tests pass
3. PathMapper round-trip: `plex_to_stash(path)` then `stash_to_plex(result)` equals original path
4. `from_env()` accepts valid JSON array and rejects invalid JSON
</verification>

<success_criteria>
- shared_lib/ package exists with __init__.py and path_mapper.py
- PathMapper supports plex_to_stash and stash_to_plex with regex capture groups
- Multiple rules evaluated in order — first match wins
- Returns None on no match
- Backslash normalization and case_insensitive flag both work
- from_env parses JSON string into validated rules
- All tests pass with zero failures
- Dev deps (httpx, respx, pytest-asyncio) installed for Plan 02
</success_criteria>

<output>
After completion, create `.planning/phases/23-foundation-shared-library/23-01-SUMMARY.md`
</output>
