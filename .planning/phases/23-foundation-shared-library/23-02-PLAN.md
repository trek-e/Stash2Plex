---
phase: 23-foundation-shared-library
plan: 02
type: tdd
wave: 2
depends_on:
  - 23-01
files_modified:
  - shared_lib/stash_client.py
  - tests/shared_lib/test_stash_client.py
autonomous: true
requirements:
  - INFR-01
  - INFR-02

must_haves:
  truths:
    - "StashClient.find_scene_by_id() returns a typed StashScene for a valid scene ID"
    - "StashClient.find_scene_by_id() raises StashSceneNotFound when scene does not exist"
    - "StashClient.find_scene_by_path() returns a typed StashScene when path matches"
    - "StashClient.find_scene_by_path() returns None when no scene matches the path"
    - "StashClient raises StashConnectionError when Stash server is unreachable"
    - "StashClient raises StashQueryError when GraphQL returns errors"
    - "StashScene model contains flattened fields (studio_name, performer_names, tag_names)"
    - "shared_lib is importable with both path_mapper and stash_client modules"
  artifacts:
    - path: "shared_lib/stash_client.py"
      provides: "Async Stash GraphQL client with typed returns"
      exports: ["StashClient", "StashScene", "StashFile", "StashConnectionError", "StashQueryError", "StashSceneNotFound"]
      min_lines: 100
    - path: "tests/shared_lib/test_stash_client.py"
      provides: "Test coverage for async Stash client with mocked httpx"
      min_lines: 100
  key_links:
    - from: "shared_lib/stash_client.py"
      to: "httpx.AsyncClient"
      via: "POST requests to Stash GraphQL endpoint"
      pattern: "httpx\\.AsyncClient"
    - from: "shared_lib/stash_client.py"
      to: "pydantic.BaseModel"
      via: "StashScene and StashFile typed models"
      pattern: "class StashScene\\(BaseModel\\)"
    - from: "tests/shared_lib/test_stash_client.py"
      to: "respx"
      via: "Mock httpx responses for GraphQL queries"
      pattern: "respx\\.(mock|post)"
    - from: "tests/shared_lib/test_stash_client.py"
      to: "shared_lib/stash_client.py"
      via: "import StashClient and models"
      pattern: "from shared_lib\\.stash_client import"
---

<objective>
Create the async Stash GraphQL client in shared_lib with comprehensive tests using TDD.

Purpose: INFR-02 requires an async GraphQL client that queries Stash scenes by path and by ID, returning typed Pydantic models. This client will be used by the provider service (Phase 25) for match requests and by the plugin in future phases. Completing this plan also finalizes INFR-01 — both shared_lib modules exist and the package is fully importable.

Output: Working `shared_lib/stash_client.py` with StashClient class, Pydantic models (StashScene, StashFile), custom exceptions, and full async test suite using respx mocks.
</objective>

<execution_context>
@/Users/trekkie/.claude/get-shit-done/workflows/execute-plan.md
@/Users/trekkie/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/23-foundation-shared-library/23-CONTEXT.md
@.planning/phases/23-foundation-shared-library/23-RESEARCH.md
@.planning/phases/23-foundation-shared-library/23-01-SUMMARY.md
@hooks/handlers.py
@plex/exceptions.py
@validation/config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: TDD — Stash GraphQL client RED+GREEN+REFACTOR</name>
  <files>
    shared_lib/stash_client.py
    tests/shared_lib/test_stash_client.py
  </files>
  <action>
**This is a TDD task. Follow RED -> GREEN -> REFACTOR strictly.**

**RED phase — Write failing tests first in `tests/shared_lib/test_stash_client.py`:**

All tests must use `@pytest.mark.asyncio` decorator (asyncio_mode is "strict" from Plan 01). Use `respx` to mock httpx responses. Use `httpx.Response` to construct mock responses.

Test cases:

1. **test_find_scene_by_id_success** — Mock POST to `http://stash:9999/graphql` returning a valid findScene response with all fields (id, title, details, date, rating100, files, studio, performers, tags, paths). Assert returned StashScene has correct field values including flattened fields: `studio_name`, `performer_names` (list of strings), `tag_names` (list of strings), `screenshot_url`, `preview_url`.

2. **test_find_scene_by_id_not_found** — Mock response with `{"data": {"findScene": null}}`. Assert raises `StashSceneNotFound`.

3. **test_find_scene_by_id_accepts_int** — Call `find_scene_by_id(42)` (int, not str). Assert the query variable sent to GraphQL has `"id": "42"` (string). Verify by inspecting the respx captured request.

4. **test_find_scene_by_path_found** — Mock POST returning a findScenes response with one scene in `scenes` array. Assert returns a StashScene with correct values.

5. **test_find_scene_by_path_not_found** — Mock POST returning `{"data": {"findScenes": {"scenes": []}}}`. Assert returns None (not raises).

6. **test_connection_error** — Use `respx.post(...).mock(side_effect=httpx.ConnectError("refused"))`. Assert raises `StashConnectionError`.

7. **test_timeout_error** — Use `respx.post(...).mock(side_effect=httpx.TimeoutException("timed out"))`. Assert raises `StashConnectionError` (timeout is a connection-class error).

8. **test_graphql_errors_response** — Mock response with `{"errors": [{"message": "bad query"}]}`. Assert raises `StashQueryError`.

9. **test_api_key_header_sent** — Create client with `api_key="secret123"`. Mock a successful response. Inspect the captured request headers to verify `ApiKey: secret123` header was sent.

10. **test_scene_with_missing_optional_fields** — Mock response where studio is null, performers is empty, tags is empty, paths has no screenshot. Assert StashScene has `studio_name=None`, `performer_names=[]`, `tag_names=[]`, `screenshot_url=None`.

11. **test_close_calls_aclose** — Create client, call `await client.close()`. Verify no error (the httpx client is properly closed).

12. **test_graphql_url_construction** — Create `StashClient("http://stash:9999")` and `StashClient("http://stash:9999/")`. Both should POST to `http://stash:9999/graphql` (trailing slash stripped).

Pattern for respx mocking:
```python
@pytest.mark.asyncio
async def test_example():
    with respx.mock:
        respx.post("http://stash:9999/graphql").mock(
            return_value=httpx.Response(200, json={...})
        )
        client = StashClient("http://stash:9999")
        try:
            result = await client.find_scene_by_id(1)
            # assertions
        finally:
            await client.close()
```

Commit after RED: `test(23-02): add failing tests for async Stash GraphQL client`

**GREEN phase — Implement `shared_lib/stash_client.py`:**

Follow the architecture pattern from 23-RESEARCH.md exactly:

**Exceptions** (mirror plex/exceptions.py pattern):
- `StashConnectionError(Exception)` — Stash server unreachable or timed out
- `StashQueryError(Exception)` — GraphQL returned errors array
- `StashSceneNotFound(Exception)` — findScene returned null

**Pydantic models:**
- `StashFile(BaseModel)` with `path: str`
- `StashScene(BaseModel)` with fields:
  - `id: str`
  - `title: Optional[str] = None`
  - `details: Optional[str] = None` (maps to Plex summary)
  - `date: Optional[str] = None`
  - `rating100: Optional[int] = None`
  - `files: list[StashFile] = []`
  - `studio_name: Optional[str] = None` (flattened from `studio.name`)
  - `performer_names: list[str] = []` (flattened from `performers[].name`)
  - `tag_names: list[str] = []` (flattened from `tags[].name`)
  - `screenshot_url: Optional[str] = None` (from `paths.screenshot`)
  - `preview_url: Optional[str] = None` (from `paths.preview`)

**GraphQL queries** (use exact field names confirmed in hooks/handlers.py SCENE_QUERY):
- `_FIND_SCENE_BY_ID` — query FindScene($id: ID!) with fields: id, title, details, date, rating100, files { path }, studio { name }, performers { name }, tags { name }, paths { screenshot, preview }
- `_FIND_SCENES_BY_PATH` — query FindScenesByPath($path: String!) using findScenes with scene_filter: { path: { value: $path, modifier: EQUALS } }. Add docstring note: "Path filter needs live validation against Stash instance in Phase 25 (see STATE.md concerns)."

**StashClient class:**
- `__init__(self, stash_url: str, api_key: Optional[str] = None, timeout: float = 10.0)`:
  - Build GraphQL URL: `stash_url.rstrip("/") + "/graphql"`
  - Headers: `{"Content-Type": "application/json"}` + `{"ApiKey": api_key}` if provided
  - Create `httpx.AsyncClient(headers=headers, timeout=httpx.Timeout(timeout, connect=5.0))`
- `async def close(self)` — calls `await self._client.aclose()`
- `async def _gql(self, query: str, variables: dict) -> dict`:
  - POST to self._url with json={"query": query, "variables": variables}
  - Catch `httpx.ConnectError` -> raise `StashConnectionError`
  - Catch `httpx.TimeoutException` -> raise `StashConnectionError`
  - Call `resp.raise_for_status()`
  - Parse JSON. If `"errors"` key exists in response, raise `StashQueryError`
  - Return `data.get("data", {})`
- `async def find_scene_by_id(self, scene_id: str | int) -> StashScene`:
  - Call `_gql` with `_FIND_SCENE_BY_ID` and `{"id": str(scene_id)}`
  - If findScene is null, raise StashSceneNotFound
  - Return `_parse_scene(raw)`
- `async def find_scene_by_path(self, path: str) -> Optional[StashScene]`:
  - Call `_gql` with `_FIND_SCENES_BY_PATH` and `{"path": path}`
  - Extract scenes list. Return `_parse_scene(scenes[0])` if non-empty, else None.

**Module-level `_parse_scene(raw: dict) -> StashScene` helper:**
- Flatten nested GraphQL response into flat StashScene model
- Handle null studio: `raw.get("studio", {}).get("name") if raw.get("studio") else None`
- Handle performers/tags: list comprehension extracting "name" from each dict
- Handle paths: `raw.get("paths", {}).get("screenshot")` etc.

**Module docstring:** Include note about async-only design, plugin usage via `asyncio.run()`, and Phase 25 live validation need for findScenes path filter.

Use `logging.getLogger("shared_lib.stash_client")` for the logger.

Commit after GREEN: `feat(23-02): implement async Stash GraphQL client`

**REFACTOR phase (if needed):** Clean up, ensure docstrings are consistent. Run all tests.

Commit after REFACTOR: `refactor(23-02): clean up stash client`
  </action>
  <verify>
    <automated>cd /Users/trekkie/projects/Stash2Plex && source .venv/bin/activate && python -m pytest tests/shared_lib/test_stash_client.py -v --no-header --tb=short -p no:cacheprovider</automated>
    <manual>Verify all 12 stash client tests pass including async tests with respx mocks</manual>
  </verify>
  <done>All 12 stash client tests pass. StashClient queries by ID and by path, returns typed StashScene models, handles connection/timeout/query errors with custom exceptions, sends API key header when configured.</done>
</task>

<task type="auto">
  <name>Task 2: Verify complete shared_lib import chain</name>
  <files>
    shared_lib/__init__.py
  </files>
  <action>
Final integration verification to confirm INFR-01 is fully satisfied:

1. Run the full shared_lib test suite (both path_mapper and stash_client):
   ```
   python -m pytest tests/shared_lib/ -v
   ```

2. Verify cross-module imports work from a single script:
   ```python
   python -c "
   from shared_lib.path_mapper import PathMapper, PathRule
   from shared_lib.stash_client import StashClient, StashScene, StashFile
   from shared_lib.stash_client import StashConnectionError, StashQueryError, StashSceneNotFound
   print('All shared_lib imports successful')
   "
   ```

3. Update `shared_lib/__init__.py` to expose the public API for convenience imports:
   ```python
   """
   shared_lib -- Cross-service shared code for Stash2Plex v2.0.
   ...docstring from Plan 01...
   """
   from shared_lib.path_mapper import PathMapper, PathRule
   from shared_lib.stash_client import (
       StashClient,
       StashScene,
       StashFile,
       StashConnectionError,
       StashQueryError,
       StashSceneNotFound,
   )

   __all__ = [
       "PathMapper", "PathRule",
       "StashClient", "StashScene", "StashFile",
       "StashConnectionError", "StashQueryError", "StashSceneNotFound",
   ]
   ```

4. Verify convenience imports work:
   ```python
   python -c "from shared_lib import PathMapper, StashClient; print('convenience imports work')"
   ```

5. Run ALL project tests to confirm no regressions:
   ```
   python -m pytest tests/shared_lib/ -v
   ```
   (Only run shared_lib tests — existing tests have 22 pre-existing failures from mocker/plexapi import issues that are unrelated.)
  </action>
  <verify>
    <automated>cd /Users/trekkie/projects/Stash2Plex && source .venv/bin/activate && python -c "from shared_lib import PathMapper, StashClient, StashScene, PathRule; print('OK')" && python -m pytest tests/shared_lib/ -v --no-header --tb=short -p no:cacheprovider</automated>
  </verify>
  <done>shared_lib package fully importable with both modules. Convenience imports via shared_lib.__init__.py work. All shared_lib tests pass.</done>
</task>

</tasks>

<verification>
1. `python -m pytest tests/shared_lib/ -v` — all tests pass (path_mapper + stash_client)
2. `python -c "from shared_lib import PathMapper, StashClient"` — convenience imports work
3. `python -c "from shared_lib.path_mapper import PathMapper, PathRule"` — direct module imports work
4. `python -c "from shared_lib.stash_client import StashClient, StashScene, StashConnectionError"` — direct module imports work
5. StashClient tests use respx mocks (no live Stash instance required)
</verification>

<success_criteria>
- shared_lib/stash_client.py implements async StashClient with find_scene_by_id and find_scene_by_path
- StashScene Pydantic model has all flattened fields (studio_name, performer_names, tag_names, screenshot_url, preview_url)
- Custom exceptions (StashConnectionError, StashQueryError, StashSceneNotFound) follow existing plex/exceptions.py pattern
- All async tests pass with respx mocks
- shared_lib/__init__.py exposes complete public API
- No regressions in shared_lib test suite
</success_criteria>

<output>
After completion, create `.planning/phases/23-foundation-shared-library/23-02-SUMMARY.md`
</output>
