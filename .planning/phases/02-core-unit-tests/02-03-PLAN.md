---
phase: 02-core-unit-tests
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - tests/plex/test_matcher.py
  - tests/plex/test_client.py
  - tests/plex/test_exceptions.py
autonomous: true

must_haves:
  truths:
    - "find_plex_item_by_path returns single match or None"
    - "find_plex_items_with_confidence returns HIGH for single match, LOW for multiple"
    - "PlexClient lazy-connects and retries on network errors"
    - "translate_plex_exception maps errors to correct hierarchy"
  artifacts:
    - path: "tests/plex/test_matcher.py"
      provides: "Plex matcher unit tests"
      contains: "def test_find_plex_item"
    - path: "tests/plex/test_client.py"
      provides: "PlexClient unit tests"
      contains: "class TestPlexClient"
    - path: "tests/plex/test_exceptions.py"
      provides: "Exception translation tests"
      contains: "def test_translate"
  key_links:
    - from: "tests/plex/test_matcher.py"
      to: "plex/matcher.py"
      via: "imports matcher functions"
      pattern: "from plex.matcher import"
    - from: "tests/plex/test_client.py"
      to: "plex/client.py"
      via: "imports PlexClient"
      pattern: "from plex.client import"
---

<objective>
Create comprehensive unit tests for the plex module (matcher, client, exceptions).

Purpose: Test Plex matching logic and API client with mocked PlexAPI dependencies.
Output: Three test files covering matching, client operations, and exception handling.
</objective>

<execution_context>
@/Users/trekkie/.claude/get-shit-done/workflows/execute-plan.md
@/Users/trekkie/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-core-unit-tests/02-RESEARCH.md
@plex/matcher.py
@plex/client.py
@plex/exceptions.py
@tests/conftest.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Matcher Tests</name>
  <files>tests/plex/test_matcher.py</files>
  <action>
Create test_matcher.py testing find_plex_item_by_path and find_plex_items_with_confidence:

Helper function tests (_item_has_file):
- test_item_has_file_exact_match: Full path matches exactly
- test_item_has_file_filename_only: Filename matches when exact=False
- test_item_has_file_case_insensitive: Case differs but matches
- test_item_has_file_no_media: Item with no media returns False
- test_item_has_file_no_parts: Item with media but no parts returns False

find_plex_item_by_path tests:
- test_single_match_returns_item: One matching item returned
- test_no_match_returns_none: No matches returns None
- test_multiple_matches_returns_none: Ambiguous match returns None
- test_title_search_fast_path: Mock library.search() called first
- test_fallback_to_all_scan: When search fails, library.all() called

find_plex_items_with_confidence tests:
- test_single_match_high_confidence: Returns (HIGH, item, [item])
- test_no_match_raises_plex_not_found: Raises PlexNotFound exception
- test_multiple_matches_low_confidence: Returns (LOW, None, candidates)
- test_confidence_enum_values: HIGH.value == "high", LOW.value == "low"

Title parsing tests (test regex extraction):
- test_title_strips_quality_suffix: "Scene - 1080p.mp4" -> searches "Scene"
- test_title_strips_date_suffix: "Scene - 2024-01-15.mp4" -> searches "Scene"
- test_title_handles_various_formats: WEBDL, BluRay, etc stripped

Create mock Plex items using MagicMock:
```python
def create_mock_plex_item(title, file_path):
    item = MagicMock()
    item.title = title
    part = MagicMock()
    part.file = file_path
    media = MagicMock()
    media.parts = [part]
    item.media = [media]
    return item
```

Use mock_plex_section fixture from conftest.py.
  </action>
  <verify>pytest tests/plex/test_matcher.py -v</verify>
  <done>All matcher tests pass covering search paths and confidence scoring</done>
</task>

<task type="auto">
  <name>Task 2: PlexClient Tests</name>
  <files>tests/plex/test_client.py</files>
  <action>
Create test_client.py with TestPlexClient class:

Initialization tests:
- test_init_stores_connection_params: Verify url, token, timeouts stored
- test_default_timeouts: Verify defaults (5.0 connect, 30.0 read)
- test_custom_timeouts: Override timeouts, verify stored

Lazy connection tests (mock PlexServer):
- test_server_property_connects_lazily: Access .server, verify PlexServer called
- test_server_property_caches_connection: Access twice, PlexServer called once
- test_connection_passes_timeout: Verify timeout param passed to PlexServer

Retry behavior tests:
- test_retries_on_connection_error: Mock ConnectionError, verify 3 attempts
- test_retries_on_timeout: Mock TimeoutError, verify retry
- test_no_retry_on_auth_error: Mock Unauthorized, verify immediate failure
- test_exponential_backoff_applied: Verify wait between retries (mock time)

get_library tests:
- test_get_library_returns_section: Mock server.library.section(), verify return
- test_get_library_translates_not_found: Section doesn't exist, raises PlexNotFound

Exception translation:
- test_connection_error_becomes_temporary: ConnectionError -> PlexTemporaryError
- test_auth_error_becomes_permanent: Unauthorized -> PlexPermanentError

Use mocker.patch to mock:
- 'plexapi.server.PlexServer' for connection tests
- 'plex.client._get_retriable_exceptions' if needed

Note: PlexClient imports PlexServer lazily, so tests should handle this.
  </action>
  <verify>pytest tests/plex/test_client.py -v</verify>
  <done>All PlexClient tests pass covering connection, retry, and error handling</done>
</task>

<task type="auto">
  <name>Task 3: Exception Translation Tests and Coverage</name>
  <files>tests/plex/test_exceptions.py</files>
  <action>
Create test_exceptions.py testing translate_plex_exception and exception classes:

Exception hierarchy tests:
- test_plex_temporary_error_is_transient: issubclass(PlexTemporaryError, TransientError)
- test_plex_permanent_error_is_permanent: issubclass(PlexPermanentError, PermanentError)
- test_plex_not_found_is_transient: issubclass(PlexNotFound, TransientError)

translate_plex_exception tests (parametrize heavily):

PlexAPI exception handling:
- test_unauthorized_becomes_permanent: Mock Unauthorized -> PlexPermanentError
- test_not_found_becomes_plex_not_found: Mock NotFound -> PlexNotFound
- test_bad_request_becomes_permanent: Mock BadRequest -> PlexPermanentError

Requests exception handling:
- test_connection_error_becomes_temporary: requests.ConnectionError -> PlexTemporaryError
- test_timeout_becomes_temporary: requests.Timeout -> PlexTemporaryError

Python exception handling:
- test_builtin_connection_error: ConnectionError -> PlexTemporaryError
- test_builtin_timeout_error: TimeoutError -> PlexTemporaryError
- test_os_error: OSError -> PlexTemporaryError

HTTP status code handling (mock response attribute):
- test_401_becomes_permanent: status_code=401 -> PlexPermanentError
- test_404_becomes_not_found: status_code=404 -> PlexNotFound
- test_429_becomes_temporary: status_code=429 -> PlexTemporaryError
- test_500_becomes_temporary: status_code=500 -> PlexTemporaryError
- test_502_becomes_temporary: status_code=502 -> PlexTemporaryError
- test_503_becomes_temporary: status_code=503 -> PlexTemporaryError
- test_400_becomes_permanent: status_code=400 -> PlexPermanentError

Default handling:
- test_unknown_error_becomes_temporary: Random exception -> PlexTemporaryError (safe default)

Use parametrize for status code tests:
```python
@pytest.mark.parametrize("status,expected_type", [
    (401, PlexPermanentError),
    (404, PlexNotFound),
    (429, PlexTemporaryError),
    (500, PlexTemporaryError),
])
def test_http_status_translation(status, expected_type):
    ...
```

Run coverage and verify >80% on plex module:
pytest tests/plex/ --cov=plex --cov-report=term-missing --cov-fail-under=80
  </action>
  <verify>pytest tests/plex/ --cov=plex --cov-report=term-missing --cov-fail-under=80</verify>
  <done>All exception tests pass, plex module has >80% coverage</done>
</task>

</tasks>

<verification>
1. All tests pass: pytest tests/plex/ -v
2. Coverage threshold met: pytest tests/plex/ --cov=plex --cov-fail-under=80
3. PlexAPI/requests are mocked (no actual network calls)
4. Exception hierarchy properly tested
</verification>

<success_criteria>
- tests/plex/test_matcher.py exists with matcher tests
- tests/plex/test_client.py exists with TestPlexClient class
- tests/plex/test_exceptions.py exists with translation tests
- All plex tests pass
- plex module coverage >80%
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-unit-tests/02-03-SUMMARY.md`
</output>
