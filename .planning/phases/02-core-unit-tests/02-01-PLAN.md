---
phase: 02-core-unit-tests
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - tests/sync_queue/test_manager.py
  - tests/sync_queue/test_operations.py
  - tests/sync_queue/test_dlq.py
autonomous: true

must_haves:
  truths:
    - "QueueManager creates queue directory and returns working queue"
    - "enqueue adds job with correct structure"
    - "get_stats returns accurate counts by status"
    - "sync timestamps persist and load correctly"
    - "DeadLetterQueue stores and retrieves failed jobs"
  artifacts:
    - path: "tests/sync_queue/test_manager.py"
      provides: "QueueManager unit tests"
      contains: "class TestQueueManager"
    - path: "tests/sync_queue/test_operations.py"
      provides: "Queue operations unit tests"
      contains: "def test_enqueue"
    - path: "tests/sync_queue/test_dlq.py"
      provides: "DeadLetterQueue unit tests"
      contains: "class TestDeadLetterQueue"
  key_links:
    - from: "tests/sync_queue/test_manager.py"
      to: "sync_queue/manager.py"
      via: "imports QueueManager"
      pattern: "from sync_queue.manager import"
    - from: "tests/sync_queue/test_operations.py"
      to: "sync_queue/operations.py"
      via: "imports operations"
      pattern: "from sync_queue.operations import"
---

<objective>
Create comprehensive unit tests for the sync_queue module (QueueManager, operations, DeadLetterQueue).

Purpose: Test queue lifecycle, job operations, and failed job storage with SQLite isolation.
Output: Three test files covering all sync_queue functionality with >80% coverage.
</objective>

<execution_context>
@/Users/trekkie/.claude/get-shit-done/workflows/execute-plan.md
@/Users/trekkie/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-core-unit-tests/02-RESEARCH.md
@sync_queue/manager.py
@sync_queue/operations.py
@sync_queue/dlq.py
@tests/conftest.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: QueueManager and Operations Tests</name>
  <files>tests/sync_queue/test_manager.py, tests/sync_queue/test_operations.py</files>
  <action>
Create test_manager.py with TestQueueManager class:
- test_creates_queue_directory: Use tmp_path, verify queue path created
- test_get_queue_returns_sqlite_ack_queue: Verify returned queue has put/get methods
- test_shutdown_logs_message: Verify shutdown completes without error

Create test_operations.py testing all operations:
- test_enqueue_creates_job_with_required_fields: Verify job has scene_id, update_type, data, enqueued_at, job_key
- test_enqueue_adds_job_to_queue: Mock queue, verify put() called
- test_get_pending_returns_job: Mock queue.get(), verify return value
- test_get_pending_timeout_returns_none: Mock Empty exception
- test_ack_job_calls_queue_ack: Mock queue, verify ack() called
- test_nack_job_calls_queue_nack: Mock queue, verify nack() called
- test_fail_job_calls_ack_failed: Mock queue, verify ack_failed() called
- test_get_stats_returns_zeros_no_db: Use tmp_path with no database
- test_get_stats_counts_by_status: Create SQLite db with test data, verify counts
- test_load_sync_timestamps_empty_file: Use tmp_path, verify returns empty dict
- test_load_sync_timestamps_loads_existing: Create JSON file, verify loading
- test_save_sync_timestamp_creates_file: Use tmp_path, verify file created
- test_save_sync_timestamp_updates_existing: Save twice, verify both preserved

Use tmp_path fixture for all database tests to ensure isolation.
Use mocker to mock queue methods where needed.
  </action>
  <verify>pytest tests/sync_queue/test_manager.py tests/sync_queue/test_operations.py -v</verify>
  <done>All QueueManager and operations tests pass, covering initialization, job operations, stats, and timestamps</done>
</task>

<task type="auto">
  <name>Task 2: DeadLetterQueue Tests</name>
  <files>tests/sync_queue/test_dlq.py</files>
  <action>
Create test_dlq.py with TestDeadLetterQueue class:

Setup:
- Use tmp_path fixture for database isolation
- Create DLQ fixture that yields DeadLetterQueue(tmp_path)

Tests:
- test_creates_database_file: Verify dlq.db created in data_dir
- test_add_stores_job_and_error: Add job with error, verify get_count() == 1
- test_add_preserves_job_data: Add job, get_by_id, verify all fields match
- test_add_captures_error_type: Add with ValueError, verify error_type == "ValueError"
- test_add_captures_error_message: Add with specific message, verify stored
- test_add_captures_stack_trace: Verify stack_trace is non-empty
- test_add_captures_retry_count: Add with retry_count=5, verify stored
- test_get_recent_returns_empty_initially: New DLQ, verify returns []
- test_get_recent_respects_limit: Add 5 jobs, get_recent(limit=2), verify 2 returned
- test_get_recent_orders_by_failed_at_desc: Add jobs, verify newest first
- test_get_by_id_returns_none_for_missing: Verify returns None for nonexistent ID
- test_get_by_id_unpickles_job_data: Add job, get_by_id, verify original job structure
- test_get_count_returns_accurate_count: Add 3 jobs, verify count == 3
- test_delete_older_than_removes_old_entries: Add old entries (mock time or modify DB), verify removal

Use parametrize for edge cases where appropriate.
  </action>
  <verify>pytest tests/sync_queue/test_dlq.py -v</verify>
  <done>All DeadLetterQueue tests pass, covering add, query, and cleanup operations</done>
</task>

<task type="auto">
  <name>Task 3: Verify Coverage and Fix Gaps</name>
  <files>tests/sync_queue/test_manager.py, tests/sync_queue/test_operations.py, tests/sync_queue/test_dlq.py</files>
  <action>
Run coverage report for sync_queue module:
pytest tests/sync_queue/ --cov=sync_queue --cov-report=term-missing

Review uncovered lines and add tests for any gaps:
- Error paths (exception handling)
- Edge cases (empty inputs, boundary conditions)
- Conditional branches not yet covered

Common gaps to check:
- manager.py: persistqueue ImportError path
- operations.py: JSON decode error path, file not exists paths
- dlq.py: db path not found in get_by_id

Add any missing tests to achieve >80% coverage on sync_queue/ module.
  </action>
  <verify>pytest tests/sync_queue/ --cov=sync_queue --cov-report=term-missing --cov-fail-under=80</verify>
  <done>sync_queue module has >80% test coverage with all tests passing</done>
</task>

</tasks>

<verification>
1. All tests pass: pytest tests/sync_queue/ -v
2. Coverage threshold met: pytest tests/sync_queue/ --cov=sync_queue --cov-fail-under=80
3. No import errors when running tests
4. Tests use tmp_path for database isolation (no shared state)
</verification>

<success_criteria>
- tests/sync_queue/test_manager.py exists with TestQueueManager class
- tests/sync_queue/test_operations.py exists with operation tests
- tests/sync_queue/test_dlq.py exists with TestDeadLetterQueue class
- All sync_queue tests pass
- sync_queue module coverage >80%
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-unit-tests/02-01-SUMMARY.md`
</output>
